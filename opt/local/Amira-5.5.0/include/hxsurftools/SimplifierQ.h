/*
Copyright 1999-2013 Visualization Sciences Group, SAS
Copyright 1995-2013, ZIB Berlin
ALL RIGHTS RESERVED.

amira(R) is a registered trademark of ZIB.

amira(R) is being jointly developed by Zuse Institute Berlin and
Visualization Sciences Group, SAS.
Avizo® is a registered trademark of Visualization Sciences Group, SAS
HardCopy, MeshViz, VolumeViz, TerrainViz are marks of Visualization
Sciences Group, SAS 
Visualization Sciences Group, SAS is a source licensee of OpenGL®, Open Inventor® 
from Silicon Graphics, Inc. OpenGL® and Open Inventor® are 
registered trademark of Silicon Graphics, Inc. All other products and 
company names are trademarks or registered trademarks of 
their respective companies. 

FEI Visualization Sciences Group accepts no liability to any 
party for loss or damage caused by errors or omissions or by 
statements of any kind in this publication, whether such errors 
result from accident, negligence or any other cause. FEI Visualization
Sciences Group assumes  no liability for incidental or consequential
damages arising from the use of information in this publication.
FEI Visualization Sciences Group provides no 
warranties regarding the information contained in this 
publication, whether expressed, implied, or statutory, including 
implied warranties of merchantability or fitness for a 
particular purpose. 

FEI Visualization Sciences Group also does not assume any liability
for links from this publication to publications from other companies,
organizations or individuals. FEI Visualization Sciences Group does not
imply endorsement of any specific  company, organization or individual
through offering links to this content.
All information provided within this publication 
is subject to change at any time and is provided for 
informational purposes only by FEI Visualization Sciences Group.
Copyright 1994-2012 by Visualization Sciences Group, SAS Merignac, France.

*/

/// @addtogroup hxsurftools hxsurftools
/// @{
#ifndef SIMPLIFIER_QUADRIC_H
#define SIMPLIFIER_QUADRIC_H

#include <stdio.h>
#include <mclib/McFHeap.h>
#include <mclib/McDArray.h>
#include <mclib/McBitfield.h>
#include <Inventor/SbLinear.h>
#include <hxsurface/HxSurface.h>
#include <hxsurface/FaceOctree.h>
#include <hxsurftools/HxDisplaySurface.h>
#include <hxsurftools/HxSurfToolsWinDLLApi.h>

#define SURROUND_FLAG 0x01
#define DO_INTERSECTION_TEST 0x02

/** This class implements surface simplification based on edge
    collapsing with error quadrics ala Garland/Heckbert .*/

class HXSURFTOOLS_API SimplifierQ {

  public:
    /// Constructor.
    SimplifierQ(HxSurface* surface = NULL,
                int memoryless = 0);

    /// Destructor.
    ~SimplifierQ();

    /** Set the surface to be simplified. No surface information other
        than @c points, @c triangles, and @c patches is required. In fact, if
        the surface contains edges or contours, this data is deleted. */
    void setSurface(HxSurface* surface);

    /** Simplify the surface until the desired number of triangles is
        reached. */
    void simplify(int desiredNumTriangles, float maxDist=0, 
                  float maxError=0, float const *maxLength=0);
    
    /** Collapse small edges. In @c removedTris the bits of those
        triangles that were removed will be set. */
    void collapseSmallEdges(float minDist=0, McBitfield * removedTris=0);

    /** Intersection strategy as 4-digit number @c abcd.

        a - if 0 intersection test are only performed if three or more
            materials are involved

        b - determines strategy for testing new triangles against existing
            edges (0=no test, 1=surrounding edges, 2=adjacent edges,
            3=nearby edges)

        c - determines strategy for testing new edges against existing
            triangles (0=no test, 1=adjacent triangles, 2=nearby triangles)

        d - if 0 no planar intersection test is performed.

        Mode 1321 is safe but VERY slow.
    */
    void setIntersectionTestStrategy(int mode);

    /** Surfaces generated by the GMC module exhibit a certain
        slice structure. You can use this method in order to
        preserve this structure for edges belonging to patches
        adjacent to material 0 (exterior). Slice preservation
        works by adding error quadrics orthogonal to the z-direction
        to all exterior points of the surface. Default is 0. */
    void doPreserveSliceStructure(float zmin, float sliceThickness, 
                                  int stacked = 0);

    /** In order to produce nice triangulations the error metric used
        for simplification has to include edge length. This factor 
        determines the weight of edge length contribution. The factor
        is scale-invariant and should be between about 0 to 0.1. The
        default is 0.01. */
    void setEdgeLengthWeight(float weight);

    /// Enable/disable creation of LOD surface
    void createSurfaceLOD(bool doIt=true) { 
        enableSurfaceLOD = doIt;
    }

    void debug(HxDisplaySurface* displaySurface, int debugPoint);


    // This struct represent an edge which can be inserted in a McFHeap.
    struct Edge : public McFHeapElement {

        unsigned int to:31;     // Index of the first endpoint
        unsigned int from:31;   // Index of the second endpoint
        
        unsigned int testFlag:1;
        unsigned int qualityFlag:1;

        union {
            int triInfo;        // Counts neighbouring triangles
            float costs;        // The error target^T*(Q1+Q2)*target
        } c;

        McVec3f target;         // The optimal contraction target
        float  maxSqrLength;    // Squared maximal edge length
                                // (for locally adapted simplification)

        int operator < (const Edge& other) {
            return c.costs < other.c.costs;
        }
    };
    
    // This represents an error quadric, i.e. a symetric 4x4 matrix
    struct Quadric {
        float q11, q12, q13, q14, q22, q23, q24, q33, q34, q44;
        double d44;

        void operator= (const Quadric& other) {
            for (int i=0; i<10; i++)
                (&q11)[i] = (&other.q11)[i];
            d44 = other.d44;
        }

        void operator+= (const Quadric& other) {
            for (int i=0; i<10; i++)
                (&q11)[i] += (&other.q11)[i];
            d44 += other.d44;
        }

        friend Quadric operator+ (const Quadric& a, const Quadric& b) ;
        friend Quadric operator* (const float f, const Quadric& b) ;

        double error(const float& x, const float& y, const float& z) {
            double xd = x;
            double yd = y;
            double zd = z;

            double qErr = xd*(q11*xd + 2*(q12*yd + q13*zd + q14)) +
                yd*(q22*yd + 2*(q23*zd + q24)) + zd*(q33*zd + 2*q34) + d44;

            return qErr;
        }
    };


    // Very simple struct representing a plane equation
    struct Plane {
        float a, b, c, d;
        void init(const McVec3f& v0, const McVec3f& v1, const McVec3f& v2);
    };

  protected:

    // Pointer to the surface to be simplified
    HxSurface* surface;

    // Current number of triangles
    int nTriangles;

    // Provides a flag for each point; used in collapse()
    McDArray<int> pointFlag;

    // All edges are inserted into this heap
    McFHeap<Edge> edgeHeap;

    // Array of all edges
    McDArray<Edge> allEdges;

    // Contains for each point the corresponding error quadric.
    McDArray<Quadric> quadrics;

    // Contains for each point the adjacent edges.
    McDArray<McSmallArray<int,8> > edgesPerPoint;

    // Contains for each point the adjacent triangles.
    McDArray<McSmallArray<int,8> > trianglesPerPoint;

    // Flag for creation of LOD surface.
    bool enableSurfaceLOD;

    // -----------------------------------------------------------------

    /// Compute edge costs (quadric error or edge length).
    void computeEdgeCosts(int e, int verbose, int useEdgeLength=0);

    /// Collapse edge.
    void collapse(int e, int useEdgeLength=0);

    /// Cleanup.
    void cleanUp();

    /// Assign max edge length to all edges.
    void assignMaxEdgeLength();

    /// Assign max edge length to edge.
    void assignMaxEdgeLength(int iEdge);

    /// Create all edges.
    void createAllEdges();

    /// Compute triangles per point.
    void computeTrianglesPerPoint();

    /// Compute error quadrics.
    void computeErrorQuadrics();

    /// Recompute vertex quadric (for memoryless simplification).
    void recomputeVertexQuadric(int iVert);

    /// Init edges and points.
    void initEdgesAndPoints(int useEdgeLength=0);

    /// Add boundary quadrics.
    void addBoundaryQuadrics();

    /// Add slice quadrics.
    void addSliceQuadrics();

    /// Check quality of new triangles.
    float qualityTest(int e);

    /// Check lengths of new edges.
    float lengthTest(int e);

    /// Compute triangle radius ratio from edge lengths.
    float triangleRadiusRatio(float* a, float* b, float* c);

    // ---  This is needed for intersection testing

    /// Compute surrounding points.
    void computeSurroundingPoints(int e, McDArray<int>& surroundingPoints);

    /// Compute adjacent triangles.
    void computeAdjacentTriangles(int e, McDArray<int>& trianglesToBeTested);

    /// Compute nearby triangles.
    void computeNearbyTriangles(int e, McDArray<int>& trianglesToBeTested);

    /// Compute surrounding edges.
    void computeSurroundingEdges(int e, McDArray<int>& edgesToBeTested);

    /// Compute adjacent edges.
    void computeAdjacentEdges(int e, McDArray<int>& edgesToBeTested);

    /// Compute nearby edges.
    void computeNearbyEdges(int e, McDArray<int>& edgesToBeTested);

    /// Intersection test.
    int intersectionTest(int e);

    /// Avoid flipped normals.
    int normalTest(int e);

    /// Check intersections of modified triangles vs other edges.
    int modifiedTrianglesVsOtherEdges(int edgeIdx,
        const McDArray<int>& edgesToBeTested);

    /// Check intersections of modified edges vs other triangles.
    int modifiedEdgesVsOtherTriangles(int edgeIdx,
        const McDArray<int>& trianglesToBeTested);

    /// Check triangles vs other edges.
    int triangleVsOtherEdges(int t, float* a, float* b, float* c,
        const McDArray<int>& edgesToBeTested);

    /// Planar intersection test.
    int planarIntersectionTest(int v1, int v2, McVec3f& target,
        const McDArray<int>& trianglesToBeTested);

    McDArray<int> surroundingPoints; 
    McDArray<int> edgesToBeTested;
    McDArray<int> trianglesToBeTested;
    McDArray<int> modifiedTriangles;
    FaceOctree<HxSurface> octree;

    int nModifiedTrianglesVsOtherEdges;
    int nModifiedEdgesVsOtherTriangles;
    int nPlanarIntersections;
    int nBadTriangleQuality;
    int nBadTriangleQuality2;
    int nFlippedNormals;
    int nQualityTests;

    int modifiedTrianglesVsOtherEdgesStrategy;
    int modifiedEdgesVsOtherTrianglesStrategy;
    int planarIntersectionStrategy;
    int testBinaryCases;
    int useOctree;

    // -----------------------------------------------------------------

    float maxDist2;
    float edgeLengthWeight;
    float zmin;
    float sliceThickness;
    int stacked;

    int flagMemoryless;

    int stop;
    int debugPoint;
    int preDebug(int edge);
    void afterDebug(int edge);
    HxDisplaySurface* displaySurface;

    // for locally adapted simplification
    McDArray<float>  maxEdgeLengthPerTriangle;
    int scalarField;

    //static void continueCallback(Widget, XtPointer, XtPointer);

};

inline SimplifierQ::Quadric operator+ (const SimplifierQ::Quadric& a, const SimplifierQ::Quadric& b) {
    SimplifierQ::Quadric c;
    for (int i=0; i<10; i++)
        (&c.q11)[i] = (&a.q11)[i] + (&b.q11)[i];
    c.d44 = a.d44 + b.d44;
    return c;
}

inline SimplifierQ::Quadric operator* (const float f, const SimplifierQ::Quadric& b) {
    SimplifierQ::Quadric c;
    for (int i=0; i<10; i++)
        (&c.q11)[i] = f * ((&b.q11)[i]);
    c.d44 = (double) f * b.d44;
    return c;
}

#endif

/// @}
