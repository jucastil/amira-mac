/* XML application for amf.dtd.
 * Includes actions from amf.act.
 * Generated 2007/03/15 11:04:14.
 *
 * This program was generated with the FleXML XML processor generator.
 * FleXML is Copyright (C) 1999-2005 Kristoffer Rose.  All rights reserved.
 * FleXML is Copyright (C) 2003-2006 Martin Quinson.  All rights reserved.
 * (Id: flexml.pl,v 1.61 2006/09/13 16:34:33 wdowling Exp).
 * 
 * There are two, intertwined parts to this program, part A and part B.
 *
 * Part A
 * ------
 * 
 * Some parts, here collectively called "Part A", are found in the 
 * FleXML package.  They are Copyright (C) 1999-2005 Kristoffer Rose
 * and Copyright (C) 2003-2006 Martin Quinson. All rights reserved.
 *
 * You can redistribute, use, perform, display and/or modify "Part A"
 * provided the following two conditions hold:
 *
 * 1. The program is distributed WITHOUT ANY WARRANTY from the author of
 *    FleXML; without even the implied warranty of MERCHANTABILITY or
 *    FITNESS FOR A PARTICULAR PURPOSE.
 *
 * 2. The program distribution conditions do not in any way affect the
 *    distribution conditions of the FleXML system used to generate this
 *    file or any version of FleXML derived from that system.
 *
 * Notice that these are explicit rights granted to you for files
 * generated by the FleXML system.  For your rights in connection with
 * the FleXML system itself please consult the GNU General Public License.
 * 
 * Part B
 * ------
 * 
 * The other parts, here collectively called "Part B", and which came 
 * from the DTD used by FleXML to generate this program, can be 
 * distributed (or not, as the case may be) under the terms of whoever
 * wrote them, provided these terms respect and obey the two conditions 
 * above under the heading "Part A".
 *
 * The author of and contributors to FleXML specifically disclaim
 * any copyright interest in "Part B", unless "Part B" was written 
 * by the author of or contributors to FleXML.
 * 
 */

#include "amf.h"


#line 5 "amf.act"

#ifndef _WIN32
#include <unistd.h>
#endif
#include <stdlib.h>
#include <stdio.h>

AMFReaderInternal* ar;

void STag_AMF(void)
{
#line 15 "amf.act"

	ar->startAMF(A_AMF_version);

} /* STag_AMF */

void ETag_AMF(void)
{
#line 19 "amf.act"

	ar->endAMF();

} /* ETag_AMF */

void STag_MOLTRAJECTORYBUNDLE(void)
{
#line 23 "amf.act"

	ar->startMolTrajectoryBundle(A_MOLTRAJECTORYBUNDLE_name);

} /* STag_MOLTRAJECTORYBUNDLE */

void ETag_MOLTRAJECTORYBUNDLE(void)
{
#line 27 "amf.act"

	ar->endMolTrajectoryBundle();

} /* ETag_MOLTRAJECTORYBUNDLE */

void STag_MOLECULEBUNDLE(void)
{
#line 31 "amf.act"

	ar->startMoleculeBundle(A_MOLECULEBUNDLE_name);

} /* STag_MOLECULEBUNDLE */

void ETag_MOLECULEBUNDLE(void)
{
#line 35 "amf.act"

	ar->endMoleculeBundle();

} /* ETag_MOLECULEBUNDLE */

void STag_MOLTRAJECTORY(void)
{
#line 39 "amf.act"

	ar->startMolTrajectory(A_MOLTRAJECTORY_name,A_MOLTRAJECTORY_size,A_MOLTRAJECTORY_flags);

} /* STag_MOLTRAJECTORY */

void ETag_MOLTRAJECTORY(void)
{
#line 43 "amf.act"

	ar->endMolTrajectory();

} /* ETag_MOLTRAJECTORY */

void STag_MOLECULE(void)
{
#line 47 "amf.act"

	ar->startMolecule(A_MOLECULE_name);

} /* STag_MOLECULE */

void ETag_MOLECULE(void)
{
#line 51 "amf.act"

	ar->endMolecule();

} /* ETag_MOLECULE */

void STag_LEVEL(void)
{
#line 55 "amf.act"

	ar->startLevel(A_LEVEL_name,A_LEVEL_size,A_LEVEL_reflevel,A_LEVEL_fixedgroupsize);

} /* STag_LEVEL */

void ETag_LEVEL(void)
{
#line 59 "amf.act"

	ar->endLevel();

} /* ETag_LEVEL */

void STag_GROUPS(void)
{
#line 63 "amf.act"

	ar->startGroups();

} /* STag_GROUPS */

void ETag_GROUPS(void)
{
#line 67 "amf.act"

	ar->endGroups();

} /* ETag_GROUPS */

void STag_ATTRIBUTE(void)
{
#line 71 "amf.act"

	ar->startAttribute(A_ATTRIBUTE_name,A_ATTRIBUTE_type);

} /* STag_ATTRIBUTE */

void ETag_ATTRIBUTE(void)
{
#line 75 "amf.act"

	ar->endAttribute();

} /* ETag_ATTRIBUTE */

void STag_DATA(void)
{
#line 79 "amf.act"

	ar->startData(A_DATA_name,A_DATA_type,A_DATA_size);

} /* STag_DATA */

void ETag_DATA(void)
{
#line 83 "amf.act"

	ar->endData();

} /* ETag_DATA */

void STag_COORDINATES(void)
{
#line 87 "amf.act"

	ar->startCoordinates();

} /* STag_COORDINATES */

void ETag_COORDINATES(void)
{
#line 91 "amf.act"

	ar->endCoordinates();

} /* ETag_COORDINATES */

void STag_OBSERVABLE(void)
{
#line 95 "amf.act"

	ar->startObservable(A_OBSERVABLE_name,A_OBSERVABLE_type);

} /* STag_OBSERVABLE */

void ETag_OBSERVABLE(void)
{
#line 99 "amf.act"

	ar->endObservable();

} /* ETag_OBSERVABLE */

void STag_SCALARFIELD3(void)
{
#line 103 "amf.act"

	ar->startScalarField3(A_SCALARFIELD3_name,A_SCALARFIELD3_type,A_SCALARFIELD3_dims,A_SCALARFIELD3_bbox);

} /* STag_SCALARFIELD3 */

void ETag_SCALARFIELD3(void)
{
#line 107 "amf.act"

	ar->endScalarField3();

} /* ETag_SCALARFIELD3 */


/* XML application entry points. */
void STag_TOPOLOGY(void) {}
void ETag_TOPOLOGY(void) {}
