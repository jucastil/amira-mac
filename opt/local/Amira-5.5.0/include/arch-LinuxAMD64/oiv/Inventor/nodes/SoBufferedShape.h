/*=======================================================================
** VSG_COPYRIGHT_TAG
**=======================================================================*/
/*=======================================================================
** Author      : VSG (MMM YYYY)
**=======================================================================*/
#if !defined SOBUFFEREDSHAPE_H
#define SOBUFFEREDSHAPE_H

#include <Inventor/fields/SoSFEnum.h>
#include <Inventor/fields/SoSFInt32.h>
#include <Inventor/fields/SoMFInt32.h>
#include <Inventor/fields/SoSFShort.h>
#include <Inventor/fields/SoSFBox3f.h>
#include <Inventor/fields/SoSFBufferObject.h>

#include <Inventor/nodes/SoNode.h>
// - Includes SoVertexProperty for the SoVertexPropertyCache class
#include <Inventor/nodes/SoVertexProperty.h>
#include <Inventor/nodes/SoShape.h>

#include <Inventor/threads/SbThreadRWMutex.h>
#include <Inventor/caches/SoBufferedShapeCacheList.h>
#include <Inventor/caches/SoVertexPropertyCache.h>

class SoBufferObject;
class SoCube;
class SoDetail;


/**
* @VSGEXT Node to render geometry stored in SoBufferObject objects.
* 
* @ingroup ShapeNodes
* 
* @DESCRIPTION
* SoBufferedShape is useful to manage the rendering of large geometry, provide 
* application control over where the data is stored (CPU or GPU) and to 
* integrate rendering with the Open Inventor computing framework (through the 
* SoBufferObject classes).
*
* SoBufferedShape provides fields for:
*
* - Vertices
* - Indices (optional)
* - Colors (optional)
* - Normals (optional)
* - Texture coordinates (optional)
*
* In this sense it is similar to the SoVertexProperty node, but SoVertexProperty 
* is just a property node. SoBufferedShape also does the rendering of the shape. 
* Properties that are not specified are taken from the traversal state (e.g. colors) 
* or computed (e.g. normals).
*
* SoBufferedShape can render many types of geometric primitives including points, lines,
* quads and triangles. (A single type must be specified per instance of SoBufferedShape.)
* You specify the type of primitive in the SoSFEnum field #shapeType.
*
* SoBufferedShape can render multiple primitives of the same type.  You can
* specify the number of vertices (or indices if provided) to use for each primitive 
* in the SoMFInt32 field #numVertices (similar to SoFaceSet).
*
* You can also use the primitive restart feature to define multiple indexed strip shapes,
* for example TRIANGLE_STRIP or LINE_STRIP. The end of each primitive is marked by a 
* special index value in the index buffer and this value can be specified
* in the #primitiveRestartValue field.  The behavior is similar to the "-1" value that can
* be used in Open Inventor indexed shape nodes like SoIndexedFaceSet, but is implemented 
* on the GPU.  @BR
* NOTE:
*   - Primitive restart must be explicitly enabled using the #primitiveRestartEnabled field.
*   - Primitive restart is only available on Nvidia hardware.
*   - Check availability of primitive restart using SoShape::isPrimitiveRestartAvailable().
*
* The geometry and its attributes must be stored in buffer objects (see SoBufferObject).
* The buffer objects can be SoGLBufferObjects stored directly on the graphics board or 
* SoCpuBufferObjects stored in system memory.  This allows the application to control 
* what data is stored where. 
*
* If lighting is enabled (there is no SoLightModel node or the model field of the SoLightModel
* is set to PHONG) and the #normalBuffer field is not set, then normal vectors are
* automatically generated, similar to other geometry nodes.  Normal generation is 
* affected by the creaseAngle field of the SoShapeHints node (if any).  It is possible to 
* disable normal generation (if for example the normals are generated by a geometry shader) 
* by setting the #useNormalsGenerator field to FALSE. Note that normal generation is
* disabled in some cases.  See the limitations section.  If no normal vectors are specified
* or generated, and lighting is enabled, the primitive may not be rendered correctly.
*
* SoBufferedShape provides fields to describe the content of each buffer, e.g. the data 
* type and number of components in each buffer, as well as how to access the buffers, 
* e.g. the offset into the buffer and "stride" separating data values in the buffer. 
* The default values for offset and stride assume that the vertices, normals, etc are
* each in a separate buffer.  However setting appropriate offset and stride allows, for
* example, vertices and normals to be interleaved in a single buffer.  In this case the 
* same buffer would be set into both the vertexBuffer and normalBuffer fields.
* 
* To disable computing the bounding box, which can take a long time with very large geometry,
* use the SoBBox node to specify a pre-computed bounding box.
*
* @B Limitations @b
*
* - Transparency: 
*   If there is no color buffer, making the entire shape transparent using an SoMaterial
*   node works as usual.  However if there is a color buffer with RGBA values, note that
*   Open Inventor does not currently check the color buffer for transparency (alpha values
*   < 1). So in this case the SoBufferedShape will not be considered transparent geometry
*   (even if there are alpha values < 1) and may not be rendered correctly. You can force Open 
*   Inventor to handle the shape as transparent geometry by putting an SoMaterial node with
*   non-zero transparency before it in the scene graph.
*
* - Normal generation:
*   Automatic generation of normal vectors is ONLY enabled when:
*   - The #vertexComponentsCount field is set to 3 (default),
*   - The #vertexComponentsType field is set to SbDataType::FLOAT (default),
*   - The #primitiveRestartEnabled field is set to FALSE (default), and
*   - The primitives are faces (i.e. neither points nor lines).
*
* - Picking:
*   SoBufferedShape does not currently create SoFaceDetail, SoLineDetail, etc objects
*   during picking.  Therefore it is not possible to query the specific face, vertex, etc
*   that was picked.
*
* - SoGetPrimitiveCountAction:
*   When using the primitive restart feature, the triangle/line count returned by the
*   SoGetPrimitiveCountAction will not be accurate.
*
* - Concave polygons:
*   Unlike (for example) SoFaceSet, SoBufferedShape does not automatically tesselate
*   concave polygons.  Such primitives may not be rendered correctly.
*
* - SoWriteAction:
*   SoBufferedShape can be saved to and restored from a .iv file just like any other
*   Open Inventor node. However, during the read operation any OpenGL buffer objects
*   (SoGLBufferObject) in the file will be created as CPU buffers (SoCpuBufferObject) if 
*   there is no OpenGL context bound during the read operation.
* 
* Example:
* \oivnetdoc
* \code
*   // Result should be similar to SoLineSet example in PG-GettingStarted.pdf.
*   // This example does not show any of the advantages of using SoBufferedShape,
*   // just the simplest possible setup and usage.
*   // Coordinate data
*   float[] vertices = new float[9 * 3] {
*           1.0f, 0.5f,0.0f, 0.0f, 1.0f,0.0f, -1.0f,0.5f,0.0f,
*          -1.0f,-1.0f,0.0f, 1.0f,-1.0f,0.0f,  1.0f,0.0f,0.0f, -1.0f,0.0f,0.0f,
*          -1.0f,-1.5f,0.0f, 1.0f,-1.5f,0.0f
*   };
*   Int32[] numVerts = new Int32[3] { 3, 4, 2 };
*
*   // Wrap coordinate array in a CPU buffer object
*   SbNativeArray<float> vertArray = new SbNativeArray<float>(vertices);
*   SoCpuBufferObject   vertBuffer = new SoCpuBufferObject((SbNativeArray<byte>)vertArray);
*
*   // Create a buffered shape to render the geometry
*   SoBufferedShape shape = new SoBufferedShape();
*   shape.shapeType.SetValue("LINE_STRIP");
*   shape.numVertices.SetValues(0, numVerts);
*   shape.vertexBuffer.SetValue(vertBuffer);
* \endcode
* \else
* \code
*   // Result should be similar to SoLineSet example in PG-GettingStarted.pdf.
*   // This example does not show any of the advantages of using SoBufferedShape,
*   // just the simplest possible setup and usage.
*   // Coordinate data
*   const float coords[][3] = { 1,0.5,0, 0,1,0, -1,0.5,0,
*                              -1,-1,0, 1,-1,0, 1,0,0, -1,0,0,
*                              -1,-1.5,0, 1,-1.5,0 };
*   const int numVerts[] = {3, 4, 2};
*   const int NUM_COORDS = sizeof(coords) / sizeof(SbVec3f);
*   const int NUM_COUNTS = sizeof(numVerts) / sizeof(int);
*
*   // Wrap coordinate array in a CPU buffer object
*   SoCpuBufferObject vertBuf( (void*)coords, NUM_COORDS * sizeof(SbVec3f) );
*
*   // Create a buffered shape to render the geometry
*   SoBufferedShape *pShape = new SoBufferedShape;
*   pShape->shapeType = SoBufferedShape::LINE_STRIP;
*   pShape->numVertices.setValues( 0, NUM_COUNTS, numVerts );
*   pShape->vertexBuffer.setValue( &vertBuf );
* \endcode
* \endoivnetdoc
*
*  @FILE_FORMAT_DEFAULT
*    BufferedShape {
*    @TABLE_FILE_FORMAT
*       @TR useNormalsGenerator      @TD TRUE
*       @TR shapeType                @TD TRIANGLES
*       @TR numVertices              @TD 0
*       @TR vertexBuffer             @TD NULL
*       @TR vertexComponentsCount    @TD 3
*       @TR vertexComponentsType     @TD SbDataType::FLOAT
*       @TR vertexStride             @TD 0
*       @TR vertexOffset             @TD 0
*       @TR normalBuffer             @TD NULL
*       @TR normalComponentsType     @TD SbDataType::FLOAT
*       @TR normalStride             @TD 3 * sizeof(float)
*       @TR normalOffset             @TD 0
*       @TR indexBuffer              @TD NULL
*       @TR indexType                @TD SbDataType::UNSIGNED_INT32
*       @TR indexOffset              @TD 0
*       @TR colorBuffer              @TD NULL
*       @TR colorComponentsType      @TD SbDataType::FLOAT
*       @TR colorStride              @TD 0
*       @TR colorOffset              @TD 0
*       @TR colorComponentsCount     @TD 3
*       @TR texCoordsBuffer          @TD NULL
*       @TR texCoordsComponentsType  @TD SbDataType::FLOAT
*       @TR texCoordsStride          @TD 0
*       @TR texCoordsOffset          @TD 0
*       @TR texCoordsComponentsCount @TD 2
*       @TR primitiveRestartEnabled  @TD FALSE
*       @TR primitiveRestartValue    @TD -1
*    @TABLE_END
*    }
*
* @ACTION_BEHAVIOR
*    SoGLRenderAction,  SoCallbackAction, SoBoundingBoxAction @BR
*        Do the actual rendering / bounding box computation.
* 
* @SEE_ALSO
*    SoBufferObject, SoBBox
* 
* 
*/ 

class INVENTOR_API SoBufferedShape : public SoShape 
{
  SO_NODE_HEADER( SoBufferedShape );

  // ----------------------- Public usage --------------------------------------

public:

  /** 
  * Type of shape that will be rendered.
  */
  enum Type
  {
    /** Draws each vertex as a single point. */
    POINTS,

    /** Connects all the vertices to form a polyline.
     *  Given vertices A B C D, it draws the line segments AB, BC and CD. */
    LINE_STRIP,

    /** Like LINE_STRIP, but an extra line segment is drawn connecting
     *  the last vertex to the first vertex. */
    LINE_LOOP,

    /** Connects every other pair of vertices with a line.
     *  Given vertices A B C D, it draws the line segments AB and CD. */
    LINES,

    /** Draws a strip of connected triangles.
     *  Given vertices A B C D E F, it draws the triangles ABC, CBD, CDE and EDF. */
    TRIANGLE_STRIP,

    /** Draws a fan of triangles.
     *  Given vertices A B C D E F, it draws the triangles ABC, ACD, ADE and AEF. */
    TRIANGLE_FAN,

    /** Draws unconnected triangles.
     *  Given vertices A B C D E F, it draws the triangles ABC and DEF. */
    TRIANGLES,

    /** Draws a strip of connected quadrilaterals.
     *  Given vertices A B C D E F, it draws the quadrilaterals ABDC and DCEF. */
    QUAD_STRIP,

    /** Draws unconnected quadrilaterals.
     *  Given vertices A B C D E F G H, it draws the quadrilaterals ABCD and EFGH. */
    QUADS,

    /** Draws a single polygon using all the vertices (in each primitive). */
    POLYGON
  };

  /**
  * Default constructor.
  */
  SoBufferedShape();


  /**
   * Enable/disable the primitive restart feature.
   * Default is FALSE.
   * Primitive restart allows you to define multiple indexed strip shapes using
   * only one index buffer. Each time the primitive restart index is reached
   * a new strip or loop of primitives is emited.
   * This feature is similar to the "-1" that can be used in the OIV indexed shapes
   * This also means that the availability must be checked before being used
   *
   * @B Limitations: @b 
   *   Enabling primitive restart disables the normal generator.
   *
   * @FIELD_SINCE_OIV 8.5
   */
  SoSFBool primitiveRestartEnabled;

  /**
   * Index value for the primitive restart feature.
   * Default is -1.  
   *
   * @FIELD_SINCE_OIV 8.5
   */
  SoSFInt32 primitiveRestartValue;

  /**
   * Indicates if the node should use the internal normal vector generator
   * if no normals are defined. Default is TRUE.
   *
   * This mode is only supported for shapes with float coordinates 
   * and 3 components per vertex. It is not supported for the points and the lines.
   *
   * Disabling the normal generator can be useful if the normals are computed in 
   * a shader or if the shaders don't need any normal at all.
   *
   * Normal generation is affected by the creaseAngle field of SoShapeHints.
   */
  SoSFBool useNormalsGenerator;

  /**
  * Shape type to render. Use enum #ShapeType. Default is TRIANGLES.
  */
  SoSFEnum shapeType;

  /** 
   * Number of vertices/indices to be used for each primitive. @BR
   * Specifically:
   * - For the shape types POINTS, LINES, TRIANGLES and QUADS only
   *   the first value is meaningful and it specifies the number of
   *   vertices to be used for rendering.
   * - For all other types the number of values in this field specifies
   *   the number of primitives that will be drawn and each value in
   *   the field specifies the number of vertices (or indices if given)
   *   to be used for each primitive.
   */
  SoMFInt32 numVertices;

  /**
   * Buffer object that contains the vertex data. @BR
   * Default is no buffer.
   * Note: This buffer must be an SoCpuBufferObject or an 
   *       SoGLBufferObject with target = ARRAY_BUFFER.
   */
  SoSFBufferObject vertexBuffer;

  /** 
   * Number of components in each vertex. 
   * Default is 3 (i.e. X, Y and Z).
   */
  SoSFShort vertexComponentsCount;

  /** 
   * SbDataType::DataType for vertices. 
   * Use enum SbDataType::DataType. Default is SbDataType::FLOAT.
   */ 
  SoSFEnum vertexComponentsType;

  /**
   * Stride in bytes between the first component of two consecutive vertices. @BR
   * Default is 0.
   * e.g: If the vertices are composed of 3 float components the stride should be
   * 3 * sizeof(float). If RGB colors are packed in the same buffer the stride should be
   * 3 * sizeof(float) + 3 * sizeof(float), the second part stands for the extra data padding.
   *
   * Note: When the values are packed (only vertices in the buffer) the value
   * 0 can be used and OpenGL will compute the stride value.
   */
  SoSFShort vertexStride;

  /** 
   * Offset in bytes to the first vertex within the buffer. 
   * Default is 0.
   */
  SoSFInt32 vertexOffset;

  /** 
   * Buffer object that contains the (optional) normal vectors. @BR
   * Default is no buffer.
   * Note: This buffer must be an SoCpuBufferObject or an 
   *       SoGLBufferObject with target = ARRAY_BUFFER.
   */
  SoSFBufferObject normalBuffer;

  /** 
   * SbDataType::DataType type for the normal vectors. 
   * Use enum SbDataType::DataType. Default is SbDataType::FLOAT.
   */
  SoSFEnum normalComponentsType;

  /** 
   * Stride in bytes between the first component of two consecutive normals.
   * Default is 0.
   * e.g: If the normals are composed of 3 float components the stride should be
   * 3 * sizeof(float). If RGB colors are packed in the same buffer the stride should be
   * 3 * sizeof(float) + 3 * sizeof(float), the second part stands for the extra data padding.
   *
   * Note: When the values are packed (only normals in the buffer) the value
   * 0 can be used and OpenGL will compute the stride value.
   */
  SoSFShort normalStride;

  /** 
   * Offset in bytes to the first normal vector in the buffer.
   * Default is 0.
   */
  SoSFInt32 normalOffset;

  /** 
   * Buffer object that contains the (optional) indices.
   * Default is no buffer.
   * Note: This buffer must be an SoCpuBufferObject or an 
   *       SoGLBufferObject with target = ELEMENT_ARRAY_BUFFER.
   */
  SoSFBufferObject indexBuffer;

  /** 
   * SbDataType::DataType type for the indices. 
   * Use enum SbDataType::DataType. Default is SbDataType::UNSIGNED_INT32.
   */
  SoSFEnum indexType;

  /** 
   * Offset in bytes to the first index in the buffer. 
   * Default is 0.
   */
  SoSFInt32 indexOffset;

  /** 
   * Buffer object that contains the (optional) color values.
   * Default is no buffer.
   * Note: This buffer must be an SoCpuBufferObject or an 
   *       SoGLBufferObject with target = ARRAY_BUFFER.
   */
  SoSFBufferObject colorBuffer;

  /** 
   * SbDataType::DataType type for the color values. 
   * Default is SbDataType::FLOAT.
   */
  SoSFEnum colorComponentsType;

  /** 
   * Stride in bytes between the first component of two consecutive colors. @BR
   * Default is 0.
   * e.g: If the colors are composed of 3 float components the stride should be
   * 3 * sizeof(float). If vertices are packed in the same buffer the stride should be
   * 3 * sizeof(float) + 3 * sizeof(float), the second part stands for the extra data padding.
   *
   * Note: When the values are packed (only color values in the buffer) the value
   * 0 can be used and OpenGL will compute the stride value.
   */
  SoSFInt32 colorStride;

  /** 
   * Offset in bytes to the first color value in the buffer. 
   * Default is 0.
   */
  SoSFInt32 colorOffset;

  /** 
   * Number of components in each color value. 
   * Default is 3 (i.e. red, green and blue)
   */
  SoSFInt32 colorComponentsCount;

  /** 
   * Buffer object that contains the (optional) texture coordinates. @BR
   * Default is no buffer.
   * Note: This buffer must be an SoCpuBufferObject or an 
   *       SoGLBufferObject with target = ARRAY_BUFFER.
   */
  SoSFBufferObject texCoordsBuffer;

  /** 
   * SbDataType::DataType type for the texture coordinates. 
   * Use enum SbDataType::DataType. Default is SbDataType::FLOAT.
   */
  SoSFEnum texCoordsComponentsType;

  /** 
   * Stride in bytes between the first component of two consecutive texture coordinates. @BR
   * Default is 0.
   * e.g: If each element is composed of 2 float components the stride should be
   * 2 * sizeof(float). If vertices are packed in the same buffer the stride should be
   * 2 * sizeof(float) + 3 * sizeof(float), the second part stands for the extra data padding.
   *
   * Note: When the values are packed (only texture coordinates in the buffer) the value
   * 0 can be used and OpenGL will compute the stride value.
   */
  SoSFInt32 texCoordsStride;

  /** 
   * Offset in bytes to the first texture coordinate in the buffer. 
   * Default is 0.
   */
  SoSFInt32 texCoordsOffset;

  /** 
   * Number of components in each texture coordinate. 
   * Default is 2 (i.e. S and T)
   */
  SoSFInt32 texCoordsComponentsCount;
 
SoEXTENDER public:
  /** 
  * Manages GLRender action. 
  *
  * @param action stores the information about the action to apply.
  */
  virtual void GLRender(SoGLRenderAction *action );

  /** 
  * Manages getBoundingBoxAction action. 
  *
  * @param action stores the information about the action to apply.
  */  
  virtual void getBoundingBox( SoGetBoundingBoxAction *action );

  /**
   * Computes the AABB bounding box if it must be updated.
   */
  virtual void computeBBox( SoAction *action, SbBox3f &box, SbVec3f &center );

  /**
   * Computes the OOB bounding box if it must be updated.
   */
  virtual void computeBBox(SoAction *action, SbXfBox3d &box, SbVec3d &center);

  /**
   * Manages ray pick action
   *
   * @param action The ray pick action.
   */
  virtual void rayPick(SoRayPickAction *action );

  /**
   * Manages getPrimitiveCount action
   *
   * @param action The SoGetPrimitiveCount action.
   */
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction *action );

// ----------------------- Private usage -------------------------------------
// INTERNAL 
SoINTERNAL public:
  virtual SbMatrix3* computeVtxTangentSpaceMat( const float *bumpTexCoords, int &numMat ) const;

  /** Static init function called during the OpenInventor init. */
  static void initClass();

  /** Static init function called by OpenInventor during the finish function. */
  static void exitClass();

  /** Redefines the read function in order to modify the indices buffer type at the end */
  virtual SbBool readInstance(SoInput *in, unsigned short flags );

  void notify( SoNotList* list );

  inline SoVertexPropertyCache* getVpCache();

  inline void lockVpCacheMutex() const;

  inline void unlockVpCacheMutex() const;

  // ----------------------- Protected usage -------------------------------------

protected:

  /** Protected desctructor */
  virtual ~SoBufferedShape();

  virtual SbBool shouldCheckShapeHints();

  virtual SbBool shouldGLRender( SoGLRenderAction *action, SbBool isPointsOrLines = FALSE );

  /**
   * Returns TRUE if the shapes colorBuffer has transparent values.
   */
  virtual SbBool isTransparent(SoState* state) const;

  virtual void generatePrimitives( SoAction *action );
  
  /** 
   * The GLRenderBoundingBox function. 
   *
   * @param action stores the information about the action to apply.
   */  
  virtual void GLRenderBoundingBox( SoGLRenderAction *action );

  virtual int getNumPrim();

  virtual SbBool numPrimInvalid();

  // Overrides standard method to create an SoFaceDetail instance
  virtual SoDetail* createTriangleDetail( SoRayPickAction *action,
                                            const SoPrimitiveVertex *v1,
                                            const SoPrimitiveVertex *v2,
                                            const SoPrimitiveVertex *v3,
                                            SoPickedPoint *pp );

  virtual SoDetail* createLineSegmentDetail( SoRayPickAction *action,
                                             const SoPrimitiveVertex *v1,
                                             const SoPrimitiveVertex *v2,
                                             SoPickedPoint *pp );

  virtual SoDetail* createPointDetail( SoRayPickAction *action,
                                       const SoPrimitiveVertex *v,
                                       SoPickedPoint *pp );

  // ----------------------- Private usage -------------------------------------

private:

  /**
   * Returns TRUE if the shapeType indicates points or lines primitives.
   */
  SbBool isPointsOrLines() const;

  /**
  * This function returns TRUE if the specified buffer object is a CPU buffer or if its target is 
  * the target specified by the argument expectedTarget!
  * If the context of the specified buffer is not the binded one it
  *
  * @param bufferObject The SoBufferObject to test.
  * @param expectedTarget The supposed target of the specified buffer object.
  *
  * @retrun True if the BufferObject target is correct.
  */
  bool isTargetValid( SoBufferObject* bufferObject, int expectedTarget ) const;

  /** 
  * This function returns the OpenGL type associated to the shape type stored in the field. 
  *
  * @return Returns the OpenGL shape type associated to the shape type from the field.
  */
  int getOpenGLShapeType() const;

  /**
   * This function setups the OpenGL buffers pointers according to the specified vertices buffer.
   */
  void setupVertices( SoState* state, SoBufferObject* vertexBufferPtr );

  /**
   * This function setups the OpenGL buffers pointers according to the specified normals buffer.
   */
  void setupNormals( SoState* state, SoBufferObject* normalBufferPtr );

  /**
   * This function setups the OpenGL buffers pointers according to the specified colors buffer.
   */
  void setupColors( SoState* state,  SoBufferObject* colorBufferPtr  );

  /**
   * This function setups the OpenGL buffers pointers according to the specified texCoords buffer.
   */
  void setupTexCoords( SoState* state,  SoBufferObject* texCoordsBufferPtr  );

  /**
   * Setup the vertex attribs from the state.
   */
  void setupVertexAttribs( SoState* state );

  /**
   * Disable the vertex attribs enabled by the setupVertexAttribs function.
   */
  void disableVertexAttribs( SoState* state );

  /**
   * This function generates default normals from the defined vertices, using the SoNormalBundle class.
   */
  void generateDefaultNormals( SoAction* action );

  template< class T > void generateDefaultNormalsTemplate(  SoState* state );
  template< class T > void generateDefaultNormalsTemplate_BASE( SoState* state, const int vertPerPrim );
  template< class T > void generateDefaultNormalsTemplate_STRIP( SoState* state, const int vertPerPrim );

  unsigned int getIndex( const void* indicesBuffer, const unsigned int index ) const;
  template< class T > unsigned int getIndexTemplate( const void* indicesBuffer, const unsigned int index ) const;

  template< class T > void getVertex( const void* verticesBuffer, const short componentsCount, const unsigned int stride, const unsigned int index, T& x, T& y, T& z ) const;

  template< class T > void computeBBoxTemplate( SoAction *action, SbBox3f &box, SbVec3f &center );

  template< class T > void rayPickQuad( void* indicesPtr, void* verticesPtr, int verticesStride, int numFaces, SoRayPickAction *action, bool isStrip );

  template< class T > void rayPickTriangle( void* indicesPtr, void* verticesPtr, int verticesStride, int numFaces, SoRayPickAction *action, bool isStrip, bool isFan );

  template< class T > void rayPickLine( void* indicesPtr, void* verticesPtr, int verticesStride, int numFaces, SoRayPickAction *action, bool isStrip, bool isLoop );

  template< class T > void rayPickPoint( void* indicesPtr, void* verticesPtr, int verticesStride, int numFaces, SoRayPickAction *action );

  // ----------------------- Private usage -------------------------------------

private:

  /** This varaiable stores the computed bounding box. */ 
  SbBox3f m_computedBoundingBox;

  /** This buffer accumulates the primitives count for the OpenGL rendering functions */
  void** m_primitivesOffset;
  int* m_primitivesOffsetInt;

  /** Cache the numVertices used to create 
   *  the arrays to avoid useless reallocations.
   */
  int m_primitivesOffsetArraySize;

  /** num of vertices used */
  int m_vertexCount;

  float m_usedCreaseAngle;

  // Vp cache data

  SoVertexPropertyCache m_vpCache;

  // Per-instance mutex to protect access to the vpCache
  SbThreadRWMutex* m_vpCacheMutex;

  // Buffer cache
  SoBufferedShapeCacheList *m_cacheList;
};


//------------------------------------------------------------------------------
inline SoVertexPropertyCache*
SoBufferedShape::getVpCache()
{
  return &m_vpCache;
}

//------------------------------------------------------------------------------
inline void
SoBufferedShape::lockVpCacheMutex() const
{
  m_vpCacheMutex->writelock();
}

//------------------------------------------------------------------------------
inline void
SoBufferedShape::unlockVpCacheMutex() const
{
  m_vpCacheMutex->writeunlock();
}

//------------------------------------------------------------------------------
inline int 
SoBufferedShape::getNumPrim()
{
  return m_vertexCount;
}

//------------------------------------------------------------------------------
inline SbBool 
SoBufferedShape::numPrimInvalid()
{
  return (m_vertexCount<0)?TRUE:FALSE;
}


//------------------------------------------------------------------------------
inline SbBool 
SoBufferedShape::shouldCheckShapeHints()
{
  return TRUE;
}


//------------------------------------------------------------------------------

#endif // SOBUFFEREDSHAPE_H

