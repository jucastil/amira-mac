/*====================  CONTAINERS ============================= */

#ifdef OIV_STL_VECTOR
using std::vector;
#endif

#ifdef OIV_STL_SET
using std::set;
using std::multiset;
#endif

#ifdef OIV_STL_DEQUE
using std::deque;
#endif
 
#ifdef OIV_STL_LIST
using std::list;
#endif
 
#ifdef OIV_STL_MAP
using std::map;
#endif

#ifdef OIV_STL_PAIR
using std::pair;
#endif

#ifdef OIV_STL_QUEUE
using std::queue;
#endif
 
#ifdef OIV_STL_STACK
using std::stack;
#endif
 
#ifdef OIV_STL_BITSET
using std::bitset;
#endif
 
#ifdef OIV_STL_STRING
using std::string;
#endif
 
#ifdef OIV_STL_VALARRAY
using std::valarray;
#endif
 
#ifdef OIV_STL_ITERATOR
using std::iterator;
#endif
 
/*====================  MISC ================================= */
#ifdef OIV_STL_ALGORITHM

using std::adjacent_find;
using std::binary_search;
using std::copy;
using std::copy_backward;
using std::count;
using std::count_if;
using std::equal;
using std::equal_range;
using std::fill;
using std::fill_n;
using std::find;
using std::find_end;
using std::find_first_of;
using std::find_if;
using std::for_each;
using std::generate;
using std::generate_n;
using std::includes;
using std::inplace_merge;
using std::iter_swap;
using std::lexicographical_compare;
using std::lower_bound;
using std::make_heap;
using std::max_element;
using std::merge;
using std::min_element;
using std::mismatch;
using std::next_permutation;
using std::nth_element;
using std::partial_sort;
using std::partial_sort_copy;
using std::partition;
using std::pop_heap;
using std::prev_permutation;
using std::push_heap;
using std::random_shuffle;
using std::remove;
using std::remove_copy;
using std::remove_copy_if;
using std::remove_if;
using std::replace;
using std::replace_copy;
using std::replace_copy_if;
using std::replace_if;
using std::reverse;
using std::reverse_copy;
using std::rotate;
using std::rotate_copy;
using std::search;
using std::search_n;
using std::set_difference;
using std::set_intersection;
using std::set_symmetric_difference;
using std::set_union;
using std::sort;
using std::sort_heap;
using std::stable_partition;
using std::stable_sort;
using std::swap;
using std::swap_ranges;
using std::transform;
using std::unique;
using std::unique_copy;
using std::upper_bound ;

#endif
 
#ifdef OIV_STL_LIMITS
using std::numeric_limits;
#endif
 
#ifdef OIV_STL_NUMERIC
using std::accumulate;
using std::product;
using std::partial_sum;
using std::adjacent_difference;
#endif
 
#ifdef OIV_STL_FUNCTIONAL
using std::unary_function;
using std::binary_function;
using std::plus;
using std::minus;
using std::multiplies;
using std::divides;
using std::modulus;
using std::negate;
using std::equal_to;
using std::not_equal_to;
using std::greater;
using std::less;
using std::greater_equal;
using std::less_equal;
using std::logical_and;
using std::logical_or;
using std::logical_not;
#endif
 
#ifdef OIV_STL_LOCALE
// to be completed
#endif
 
#ifdef OIV_STL_MEMORY
// to be completed
#endif
 
#ifdef OIV_STL_UTILITY
using std::pair;
using std::make_pair;
#endif
 
#ifdef OIV_STL_COMPLEX
// to be completed
#endif
 
/*====================  EXCEPTIONS =========================== */
#ifdef OIV_STL_STDEXCEPT
using std::logic_error;
using std::domain_error;
using std::invalid_argument;
using std::length_error;
using std::out_of_range;
using std::runtime_error;
using std::range_error;
using std::overflow_error;
using std::underflow_error;
#endif
 
#ifdef OIV_STL_EXCEPTION
using std::exception;
using std::bad_exception;
#endif
 
/*====================  IO =================================== */
#ifdef OIV_STL_FSTREAM
// to be completed
#endif
 
#ifdef OIV_STL_IOMANIP
// to be completed
#endif
 
#ifdef OIV_STL_IOS
// to be completed
#endif
 
#ifdef OIV_STL_IOSFWD
// to be completed
#endif
 
#ifdef OIV_STL_IOSTREAM
// to be completed
#endif
 
#ifdef OIV_STL_ISTREAM
// to be completed
#endif
 
#ifdef OIV_STL_OSTREAM
// to be completed
#endif
 
#ifdef OIV_STL_SSTREAM
// to be completed
#endif
 
#ifdef OIV_STL_STRSTREAM
// to be completed
#endif
 
#ifdef OIV_STL_STREAMBUF
// to be completed
#endif



