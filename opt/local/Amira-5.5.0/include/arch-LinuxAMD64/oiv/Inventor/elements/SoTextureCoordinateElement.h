/*=======================================================================
** SGI_COPYRIGHT_TAG
**=======================================================================*/
/*=======================================================================
** Author      : Gavin Bell (MMM yyyy)
**=======================================================================*/
/*=======================================================================
** VSG_COPYRIGHT_TAG
**=======================================================================*/
/*=======================================================================
** Modified by : VSG (MMM YYYY)
**=======================================================================*/


#ifndef  _SO_TEXTURE_COORDINATE_ELEMENT
#define  _SO_TEXTURE_COORDINATE_ELEMENT

#include <Inventor/SbLinear.h>
#include <Inventor/elements/SoReplacedTextureElement.h>

#include <Inventor/STL/vector>

/** Function that TextureCoordinateFunction nodes register to compute
 * texture coordinates. Given the point and normal, compute a texture
 * coordinate and return it:
 * [OIV-WRAPPER NAME{FunctionCB}]
 */
typedef const SbVec4f &
SoTextureCoordinateFunctionCB(void *userdata, const SbVec3f &point,
                              const SbVec3f &normal);

/**
*   Stores the current texture coordinates.
* 
*   @ingroup elements
* 
*   @DESCRIPTION
*   This element stores the current texture coordinates.
* 
*   @SEE_ALSO
*   SoTextureCoordinate2
*/
SoEXTENDER_Documented class INVENTOR_API SoTextureCoordinateElement : public SoReplacedTextureElement {
  
  SO_ELEMENT_HEADER(SoTextureCoordinateElement);
  
 public:
  /**
  *  The choice of values is for compatibility
  *  with Open Inventor 2.0 binary format files.
  */
  enum CoordType {
    EXPLICIT = 1,     // Coordinates stored in state
    FUNCTION = 2      // Coordinates generated by software function
  };
    
  /**
  *  Sets the current texture coordinates, in any of several ways:
  *  EXPLICIT, no coordinates (shapes will generate).
  */
  static void         setDefault(SoState *state, SoNode *node);
    
  // FUNCTION:
  static void         setFunction(SoState *state, SoNode *node,
                                  SoTextureCoordinateFunctionCB *func,
                                  void *userData, 
                                  SbBool frcSend = FALSE);
  // EXPLICIT:
  /**
   * [OIV-WRAPPER-ARG IN,IN,NO_WRAP{(coords != NULL? coords->Length: 0)},ARRAY,IN]
   */
  static void         set2(SoState *state, SoNode *node,
                           int32_t numCoords, const SbVec2f *coords,
                           SbBool frcSend = FALSE);

  /**
   * [OIV-WRAPPER-ARG IN,IN,NO_WRAP{(coords != NULL? coords->Length: 0)},ARRAY,IN]
   */
  static void         set4(SoState *state, SoNode *node,
                           int32_t numCoords, const SbVec4f *coords,
                           SbBool frcSend = FALSE);
    
  /**
  *  Returns code indicating what has been set in state/element.
  */
  static CoordType    getType(SoState *state, int unit=0);
  virtual CoordType   getType(int unit=0) const;
    
  /**
  *  Returns the top (current) instance of the element in the state.
  *  The get routines are called on an instance because it is more
  *  efficient than calling a static method that looks up the
  *  element in the state for every coordinate.
  */
  static const SoTextureCoordinateElement * getInstance(SoState *state);
    
  // Get routine for FUNCTION case:
    
  /**
  *  Given point and normal, returns texture coordinate. (The r
  *  coordinate will be 0.0 and the q will be 1.0 until we get 3D
  *  texture coordinate functions.)
  */
  const SbVec4f &     get(const SbVec3f &point, const SbVec3f &normal, 
                          int unit=0) const;
    
  // Get routines for EXPLICIT case:
    
  /**
  *  Returns the number of coordinate points in an instance.
  */
  int32_t             getNum(int unit=0) const ;
    
  SbBool              is2D(int unit=0) const ;

  SbBool              isForceSending(int unit=0) const ;
    
  /**
  *  Returns the indexed coordinate from an element as a 2- or
  *  4-vector, converting if necessary.
  */
  const SbVec2f &     get2(int index, int unit=0) const;
  const SbVec4f &     get4(int index, int unit=0) const;
    
  /**
   *  Prints element (for debugging).
   */
  virtual void        print(FILE *fp) const;

  /**
  *  Overrides push() method to copy values from next instance in the stack.
  */
  virtual void push(SoState *) ;

    
 SoINTERNAL public:
  // Initializes the SoTextureCoordinateElement class
  static void         initClass();
  static void         exitClass();
    
  // Initializes element.
  virtual void        init(SoState *state);

  // Common Initialization. Directly called by the constructor.
  virtual void commonInit() ;
  
 protected:

   virtual ~SoTextureCoordinateElement();

   struct SoTexCoordData 
   {
     // What kind of coordinates will be done:
     CoordType         whatKind;

     // Storage for FUNCTION:
     SoTextureCoordinateFunctionCB     *funcCB;
     void                              *funcCBData;

     // Storage for EXPLICIT:
     int32_t           numCoords;
     const SbVec2f     *coords2;
     const SbVec4f     *coords4;
     SbBool            coordsAre2D;
     SbBool            forceSend;

     SoTexCoordData& operator=(const SoTexCoordData& data)
     {
       whatKind = data.whatKind ;
       funcCB = data.funcCB ;
       funcCBData = data.funcCBData ;
       numCoords = data.numCoords ;
       coords2 = data.coords2 ;
       coords4 = data.coords4 ;
       coordsAre2D = data.coordsAre2D ;
       forceSend = data.forceSend;
       return *this ;
     }
   } ;

   SoTexCoordData& getTexCoordData( const int unit ) const;

 private:
  SbVec2f             m_convert2;       // To convert from 4-D to 2-D
  SbVec4f             m_convert4;       // To convert from 2-D to 4-D

  typedef std::vector<SoTexCoordData> SoTexCoordDataList;

  mutable SoTexCoordDataList m_texCoordData ;
};

#endif /* _SO_TEXTURE_COORDINATE_ELEMENT */
