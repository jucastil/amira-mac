####
#### After opening a file, use this function to write a GNUmakefile.
####
#### Remark: if you change this file and start to use new config variables
#### you have to explicitely declare them in createGNUmakefile_uses in helpers.tcl.
####
#### WARNING: You must not expand tabs to spaces in blocks insides curly braces
####          that are output to the makefile.  Make is tab-sensitive.
####
#### The following approaches are used for output (see below for examples).
####  - curly braces: Place the opening brace on the first line of output.
####  - quotes: This allows expansion ot TCL variables.
####  - 'string map': This allows handling complex strings including $s.

####
#### Print a makefile rule to compile x
####
proc makefile_OutputSRCRule {dir x deps} {
        set extension [file extension $x]

        if { $extension == ".cpp" || $extension == ".cxx" } {
            set rule {$(CXX) $(CXXFLAGS) -c $< -o $@}
        } elseif { $extension == ".c" } {
            set rule {$(CC) $(CFLAGS) -c $< -o $@}
        } else {
            message "Error: Unsupported suffix '$extension'."
            error "unsupported suffix."
        }
        if { $dir != "" } {
            append dir "/"
        }
        if { $deps != "" } {
            set deps " $deps"
        }

        output [string map [list \
                                @@ROOTNAME@@ [file rootname $x] \
                                @@DIR@@ $dir \
                                @@FILE@@ $x \
                                @@DEPS@@ $deps \
                                @@RULE@@ $rule \
                           ] \
{$(INTERMEDIATEDIR)/@@ROOTNAME@@.o: @@DIR@@@@FILE@@@@DEPS@@ $(filter %.h, $(COPY))
	@echo "    [$(MAKE_CFG)] Compiling $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)@@RULE@@

OBJS += $(INTERMEDIATEDIR)/@@ROOTNAME@@.o

ifdef MAKEDEP
$(INTERMEDIATEDIR)/@@ROOTNAME@@.d: @@DIR@@@@FILE@@@@DEPS@@ $(filter %.h, $(COPY))
	@echo "    [$(MAKE_CFG)] Generating dependencies for $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(MAKEDEP)
	@cp $@ $@.orig
	@sed -e 's/\.o:/.d:/' <$@.orig >>$@
	@sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\$$//' -e '/^$$/ d' \
		-e 's/^ *//' -e 's/$$/ :/' <$@.orig >>$@
	@rm $@.orig

DEPS += $(INTERMEDIATEDIR)/@@ROOTNAME@@.d
endif

} ]
}

proc createGNUmakefile {} {
   global configs;
   global aliasedTo;
   global aliases;
   global autoIncludeList;
   global MAINROOT;
   global gMainConfig
   global gccpostfix

   storeBuildConfig $::Config::PACKAGE $Config::PREPACKED

   addPackageDependency $::Config::PACKAGE GNUmakefile

   foreach x [concat $::Config::INCSRC $::Config::INCSRCINTERN] {
       addPackageDependency $::Config::PACKAGE $x
   }

   output \
{#
# DO NOT EDIT
#
# This makefile was automatically generated by createBuildSystem.scro.
#
# Edit the file 'Package' located in the same directory to change settings.
#

ifdef PARALLELFLAGS
    $(warning PARALLELFLAGS is no longer supported.  Use 'make -j N' instead.)
endif

# Define V if you want verbose output, e.g. run 'V=1 make'.
ifdef V
    TAR_VERBOSE=v
else
    QUIET=@
endif

.DELETE_ON_ERROR:

.PHONY: gotoTarget checkArch clean dep depclean copy bin lib
}

    outputCancelingImplicitMakeRules

#### If ONLY is defined verify architecture (see checkArch below).
   if {${::Config::ONLY} != ""} {
	   output \
{# Verify that the current architecture is supported.
gotoTarget: checkArch

};
   }

    output "# The default target.\n"
#### Supported types:
####    - bin: create binary.
####    - copy: copy share/data only.
####    - default: build shared lib.
####
    if {$::Config::TYPE == "bin"} {
        output \
{default all: copy dep bin

TYPE=bin
}
    } elseif {$::Config::TYPE == "copy"} {
        output \
{default all: copy

TYPE=copy
}
    } elseif {$::Config::TYPE == "python"} {
        output \
{default all: copy dep python

}
    } else {
        if {$::Config::TYPE == "staticlib" } {
            message "Error: Support for TYPE 'staticlib' was dropped."
            error "staticlib was dropped"
        }
        output \
{default all: copy dep lib

}
    }

    output "# The name of this package.\n"
####
#### Output package name.
####
    output \
"PACKAGE = $::Config::PACKAGE
"

####
#### Output non default naming of target.
####
    if { [info exists ::Config::TARGET] } {
    output \
"TARGET = $::Config::TARGET
"

        if {$::Config::TYPE != "bin"} {
            message "Error: use of TARGET is no longer supported.  Instead, you should rename PACKAGE.";
            error "TARGET not allowed"
        }
    } else {
        output \
"TARGET = $::Config::PACKAGE
"
    }
    output "\n"

    output "# The main directories.\n"
    output "BUILDROOT = $::Run::pathToRoot\n"
    output "PRODUCTROOT = $::Run::pathToProduct\n"
    output "INTERMEDIATEROOT = $::Run::pathToIntermediate\n"
    if {[info exists MAINROOT]} {
        output "MAINROOT = $MAINROOT\n"
        output "DEVTOOLSDIR = $MAINROOT/share/devtools\n"
    } else {
        output "DEVTOOLSDIR = $::Run::pathToRoot/src/amira/devtools\n"
    }
    output "\n"

    output \
{# Some helper commands.
COPY_CMD = cp
BISON = bison
FLEX = flex
RANLIB = ranlib
MOC = $(PRODUCTROOT)/bin/arch-$(MAKE_UNAME)-Optimize/moc
UIC = $(PRODUCTROOT)/bin/arch-$(MAKE_UNAME)-Optimize/uic
RCC = $(PRODUCTROOT)/bin/arch-$(MAKE_UNAME)-Optimize/rcc
ROC = $(PRODUCTROOT)/bin/roc
TAGLIB = $(PRODUCTROOT)/bin/taglib
SOAPCPP2 = $(PRODUCTROOT)/bin/soapcpp2
NVCC = $(PRODUCTROOT)/bin/arch-$(MAKE_UNAME)/cuda/bin/nvcc
COPY_SECURE = $(PRODUCTROOT)/bin/arch-$(MAKE_UNAME)-$(MAKE_CFG)/bin2c

DIRNAME=$(shell basename "$(CURDIR)")
}

    outputUnameDetection

    output \
{
# The architecture specific setup.
}
    foreach a [getRequestedArchs] {
        output "ifeq (\$(MAKE_UNAME),$a)\n"
        if { [info exists ::Config::EXCLUDEISA-$a] } {
            foreach i [subst $\{::Config::EXCLUDEISA-$a\}] {
                if { ![isValidISA $i] } {
                    message "Error: invalid isa '$i' in EXCLUDEISA-$a."
                    error "invalid ISA"
                }
                output "    HX_EXCLUDEISA_$i = 1\n"
            }
        }
        if { [getCompiler $a] != "" } {
            output "    HX_COMPILER_[getCompiler $a] = 1\n"
        }
        if { [info exists gccpostfix] } {
            output "    CC = gcc$gccpostfix\n"
            output "    CXX = g++$gccpostfix\n"
        }
        if { [info exists ::Config::BASE_MAKE-$a] } {
            output [subst $\{::Config::BASE_MAKE-$a\}]
        }
        foreach c $configs {
            if { [info exists ::Config::BASE_MAKE-$a-$c] } {
                output "  ifeq (\$(MAKE_CFG),$c)\n"
                output [subst $\{::Config::BASE_MAKE-$a-$c\}]
                output "  endif\n"
            }
        }
        output "endif\n"
    }

    output \
{
ifeq ($(MAKE_CFG),Debug)
    BISONFLAGS = --debug
    FLEXFLAGS = -d
endif
}

    output \
{
# The include paths for each configuration.
}
    foreach a [getRequestedArchs] {
        output "ifeq (\$(MAKE_UNAME),$a)\n"
        foreach c $configs {
            output "  ifeq (\$(MAKE_CFG),$c)\n"
            foreach i [expandIncludes $a $c] {
                output "    INCLUDES += -I$i\n"
            }
            output "  endif\n"
        }
        output "endif\n"
    }

    if {[info exists MAINROOT]} {
        if { [info exists gMainConfig] } {
            output [string map [list @@CONFIG@@ $gMainConfig] \
{
# Link against libs as specified in "--mainconfig @@CONFIG@@".
LDFLAGS += -L$(MAINROOT)/lib/arch-$(MAKE_UNAME)-@@CONFIG@@
HXRPATH += -Wl,-rpath,$(MAINROOT)/lib/arch-$(MAKE_UNAME)-@@CONFIG@@
} ]
        } else {
                output \
{
# Link against mainroot.
LDFLAGS += -L$(MAINROOT)/lib/$(ARCH)
HXRPATH += -Wl,-rpath,$(MAINROOT)/lib/$(ARCH)
}
        }
    }

    output \
{
# Add the intermediate directory to the include paths.
INCLUDES += -I$(INTERMEDIATEROOT)/$(ARCH)

# Add includes to the C*FLAGS.
CXXFLAGS += $(INCLUDES)
CFLAGS += $(INCLUDES)

# The link command for shared libs.
LINK_SHARED = $(LD) $(LDFLAGS) $(LD_SHARED)

# The package specific paths.
BINDIR = $(PRODUCTROOT)/bin/$(ARCH)
LIBDIR = $(PRODUCTROOT)/lib/$(ARCH)
INTERMEDIATEDIR = $(INTERMEDIATEROOT)/$(ARCH)/$(PACKAGE)

# Dependency handling: Depenencies are only included for default target.
ifeq (,$(MAKECMDGOALS))
-include $(INTERMEDIATEDIR)/*.d
-include $(INTERMEDIATEDIR)/*/*.d
endif
}

####
#### Output all LIBS, check if they are aliased.
####
    output "# The libraries.\n"
    foreach a [getRequestedArchs] {
        output "ifeq (\$(MAKE_UNAME),$a)\n"
        foreach c $configs {
            output "  ifeq (\$(MAKE_CFG),$c)\n"
            set la [list]
            if { [info exists ::Config::LIBS-$a] } {
                set la [subst $\{::Config::LIBS-$a\}]
            }
            set lac [list]
            if { [info exists ::Config::LIBS-$a-$c] } {
                set lac [subst $\{::Config::LIBS-$a-$c\}]
            }
            set noprefix 0
            foreach l [expandLIBS [concat $::Config::LIBS $la $lac] LIBS $a $c] {
                if { $noprefix == 0 } {
                    if { [string range $l 0 0] == "-" || [string range $l 0 0] == "/" } {
                        set noprefix 1
                    }
                    if { $l == "-framework" || $l == "-weak_framework" } {
                        set noprefix 2
                    }
                }
                if { $noprefix > 0 } {
                    output "    LIBS += $l\n"
                    incr noprefix -1
                } else {
                    output "    LIBS += -l$l\n"
                }
            }
            output "  endif\n"
        }
        output "endif\n"
    }
    output "\n\n";

    output \
{
# The defines for each configuration.
}
    foreach a [getRequestedArchs] {
        output "ifeq (\$(MAKE_UNAME),$a)\n"
        foreach c $configs {
            output "  ifeq (\$(MAKE_CFG),$c)\n"

            set defs [list]
            foreach var [list \
                            ::Config::DEFINES \
                            ::Config::DEFINES-$a \
                            ::Config::DEFINES-$a-$c \
                            ::Config::BASE_DEFINES \
                            ::Config::BASE_DEFINES-$a \
                            ::Config::BASE_DEFINES-$a-$c \
                        ] {
                if { [info exists $var] } {
                    set defs [concat $defs [subst $\{$var\}]]
                }
            }

            foreach d $defs {
                output "    DEFINES += -D$d\n"
            }

            output "  endif\n"
        }
        output "endif\n"
    }
    output \
{
CXXFLAGS += $(DEFINES)
CFLAGS   += $(DEFINES)

}

    output "# The package tag.\n"
    output "CXXFLAGS += -DPACKAGEID=amirapackage_$::Config::PACKAGE\n";

####
#### Output rules for SHARE*.
####
    output "# Copy files in SHARE*.\n"

    foreach x [concat $::Config::SHARE $::Config::SHAREDEV $::Config::SHAREINTERN] {
        addPackageDependency $::Config::PACKAGE $x
        output [string map [list @@PATH@@ $x] \
{$(PRODUCTROOT)/@@PATH@@: @@PATH@@
	@echo "    Copying $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(COPY_CMD) $< $@
	$(QUIET)chmod u+w $@

COPY += $(PRODUCTROOT)/@@PATH@@


} ]
    }

    output \
####
#### Output rules for SHARESECURE*.
####
    output "# Encrypting files in SHARESECURE*.\n"

    foreach x $::Config::SHARESECURE  {
        addPackageDependency $::Config::PACKAGE $x
        output [string map [list @@PATHSRC@@ $x @@PATHDEST@@ [file join [file dirname $x ] $::Config::PACKAGE [file tail $x]]] \
{$(PRODUCTROOT)/@@PATHDEST@@: @@PATHSRC@@
	@echo "    Encrypting $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(COPY_SECURE) $< $@
	$(QUIET)chmod u+w $@

COPY += $(PRODUCTROOT)/@@PATHDEST@@


} ]
    }

    output \
{
#
# Architectur specific copying and prepacked expansion might follow.
#
}
    foreach b [concat [list ""] [getRequestedArchs]] {
      foreach c {"" Debug Optimize} {
        if {$b == ""} {
            if {$c != ""} {
                continue;
            }
            set a "";
        } else {
            if {$c == ""} {
                set a $b;
            } else {
                set a $b-$c;
            }
        }
        if {$a != ""} {
            set val0 [list]
            set var0 ::Config::COPY-$a;
            if { [info exists $var0] } {
                set val0 [subst $\{$var0\}]
            }
            set val1 [list]
            set var1 ::Config::COPYINTERN-$a;
            if { [info exists $var1] } {
                set val1 [subst $\{$var1\}]
            }
            set val2 [list]
            set var2 ::Config::COPYDEV-$a;
            if { [info exists $var2] } {
                set val2 [subst $\{$var2\}]
            }
            set val [concat $val0 $val1 $val2]

            set symlink [list]
            set var3 ::Config::SYMLINK-$a;
            if { [info exists $var3] } {
                set symlink [subst $\{$var3\}];
            }
        } else {
            set val [concat $::Config::COPY $::Config::COPYINTERN $::Config::COPYDEV];

            set symlink $Config::SYMLINK;
        }
        set prepacked [getFilteredPrepacked ${::Config::PACKAGE} $::Config::PREPACKED $b $c]
        set rules "";
        foreach {src dest} $val {
           set exp [expandCopy $src $dest];
           set src [lindex $exp 0];
           set dest [lindex $exp 1];
           set syms [lindex $exp 2];

           addPackageDependency $::Config::PACKAGE $src
           append rules [string map [list \
                                        @@SRC@@ $src \
                                        @@DEST@@ $dest \
                                    ] \
{$(PRODUCTROOT)/@@DEST@@: @@SRC@@
	@echo "    Copying $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(COPY_CMD) $< $@
} ]

#### Ugly hack: we have to run ranlib on MacX if we copied an archive...;
#### and if the target is bin/start or bin/arch, set execute bit.
           if { [file extension $src] == ".a" } {
               append rules \
{ifeq ($(MAKE_UNAME),MacX)
	$(QUIET)ranlib $@
endif
}
           } elseif { [string match "*bin/start" $src] || [string match "*bin/arch" $src] } {
               append rules \
{	$(QUIET)chmod a+x $@
}
           }

           append rules [string map [list \
                                        @@DEST@@ $dest \
                                    ] \
{	$(QUIET)chmod u+w $@

COPY += $(PRODUCTROOT)/@@DEST@@
} ]

####
#### Create symlinks.
####
           foreach expx $syms {
               append rules [string map [list \
                                            @@EXPX@@ $expx \
                                            @@EXPXTAIL@@ [file tail $expx] \
                                            @@DEST@@ $dest \
                                            @@DESTTAIL@@ [file tail $dest] \
                                        ] \
{
$(PRODUCTROOT)/@@EXPX@@: $(PRODUCTROOT)/@@DEST@@
	@echo "    Creating symlink $@"
	$(QUIET)cd $(@D) ; rm -f @@EXPXTAIL@@ ; ln -s @@DESTTAIL@@ @@EXPXTAIL@@;

COPY += $(PRODUCTROOT)/@@EXPX@@

} ]
           }
        }

        foreach {src dest} $symlink {
           append rules [string map [list \
                                        @@SRC@@ $src \
                                        @@DEST@@ $dest \
                                    ] \
{
$(PRODUCTROOT)/@@DEST@@:
	@echo "    Creating symlink $@"
	@mkdir -p $(@D)
	$(QUIET)ln -s @@SRC@@ $@

COPY += $(PRODUCTROOT)/@@DEST@@

} ]
        }

####
#### Unpack prepacked.
####
        foreach url $prepacked {
            append rules ".NOTPARALLEL:\n\n"
            foreach l [getPrepackedList $url] {
                append rules \
"\$(PRODUCTROOT)/$l \\
"
            }
            set archive [getPrepackedLocalArchiveRelToRoot $url]
            if { [file extension $archive] == ".bz2" } {
                set tar_comp "j"
            } else {
                set tar_comp "z"
            }
            append rules \
" : [file join $::Run::pathToRoot $archive] \\
    [getBuildConfigDependencyFile $::Config::PACKAGE]
\t@echo \"    Unpacking prepacked \$(DIRNAME)/\$<\"
\t@mkdir -p \$(PRODUCTROOT)
\t\$(QUIET)tar -C \$(PRODUCTROOT) -x$tar_comp\$(TAR_VERBOSE)mf \$<
"

            if { [isRequestedArch MacX] } {
                # HACK: MacX requires to run ranlib after the modification date of a static library
                # has changed. We like to change the date to handle dependencies. Therefore,
                # we need to run ranlib, otherwise MacX would refuse to link against the unpacked library.
                set ranlibrules ""
                foreach l [getPrepackedList $url] {
                    if { [regexp {^lib/arch-[^/]*/.*\.a$} $l] } {
                        append ranlibrules "\t-\$(RANLIB) \$(PRODUCTROOT)/$l\n"
                    }
                }
                if { [string length $ranlibrules] > 0 } {
                    append rules "ifeq (\$(MAKE_UNAME), MacX)\n"
                    append rules $ranlibrules
                    append rules "endif\n"
                }
            }
            append rules "\n"

            append rules "COPY += "
            foreach l [getPrepackedList $url] {
                append rules \
" \\\n    \$(PRODUCTROOT)/$l"
            }
            append rules "\n\n";
        }

#### output rules
        if {$rules != ""} {
           if {$a == ""} {
                output \
"
${rules}
";
           } else {
               if {$c != ""} {
                  output \
"ifeq (\$(MAKE_UNAME)-\$(MAKE_CFG), $a)

${rules}endif

";
               } else {
              output \
"ifeq (\$(MAKE_UNAME), $a)

${rules}endif

";
                }
            }
        }
      }
    }

   foreach exec $::Config::EXECWRAPPER {

       output [string map [list \
                              @@EXEC@@ $exec \
                          ] \
{
$(PRODUCTROOT)/bin/@@EXEC@@: $(DEVTOOLSDIR)/unix/start-exec-arch
	@echo "    Creating $@"
	@mkdir -p $(@D)
	$(QUIET)$(COPY_CMD) $< $@
	$(QUIET)chmod a+x $@

COPY += $(PRODUCTROOT)/bin/@@EXEC@@

} ]

   }

####
#### UICSRC
    output "# Qt's uic targets.\n"
    set uicout [list]
    foreach x $::Config::UICSRC {
        addPackageDependency $::Config::PACKAGE $x

        lappend uicout ui_[file rootname $x].h

        output [string map [list \
                                @@ROOTNAME@@ [file rootname $x] \
                                @@SRC@@ $x \
                           ] \
{.PRECIOUS: $(INTERMEDIATEDIR)/ui_@@ROOTNAME@@.h

$(INTERMEDIATEDIR)/ui_@@ROOTNAME@@.h: @@SRC@@ $(UIC)
	@echo "    [$(MAKE_CFG)] Running Qt's uic on $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(UIC) $< -o $@

} ]
    }

    output \
{
# Make the OBJS dependent on the results of UIC to ensure that
# the headers resulting from UIC are available during compilation.
# The headers are stored in UICOUTPUT, which is used in the cpp rules below.
}
        output [string map [list \
                                @@UICOUT@@ [join $uicout] \
                           ] \
{UICOUTPUT = $(addprefix $(INTERMEDIATEDIR)/, @@UICOUT@@)

} ]

    output "\n\n";
#### END of UICSRC
####

####
#### MOCSRC
    output "# Qt's moc targets.\n"
    foreach x $::Config::MOCSRC {
        addPackageDependency $::Config::PACKAGE $x
        set rootname [file rootname $x]
        output [string map [list \
                                @@ROOTNAME@@ $rootname \
                                @@SRC@@ $x \
                           ] \
{.PRECIOUS: $(INTERMEDIATEDIR)/moc_@@ROOTNAME@@.cpp

$(INTERMEDIATEDIR)/moc_@@ROOTNAME@@.cpp: @@SRC@@ $(MOC)
	@echo "    [$(MAKE_CFG)] Running Qt's moc on $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(MOC) $< -o $@ $$($(MOC) -v 2>&1 | grep -q "Qt 3" || echo $(DEFINES))

} ]

        makefile_OutputSRCRule {$(INTERMEDIATEDIR)} moc_${rootname}.cpp {$(UICOUTPUT)}
    }
    output "\n\n";

####
#### QRCSRC
    output "# Qt's qrc targets.\n"
    foreach x $::Config::QRCSRC {
        addPackageDependency $::Config::PACKAGE $x
        set rootname [file rootname $x]
        output [string map [list \
                                @@ROOTNAME@@ $rootname \
                                @@SRC@@ $x \
                           ] \
{.PRECIOUS: $(INTERMEDIATEDIR)/qrc_@@ROOTNAME@@.cpp

$(INTERMEDIATEDIR)/qrc_@@ROOTNAME@@.cpp: @@SRC@@ $(RCC)
	@echo "    [$(MAKE_CFG)] Running Qt's rcc on $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(RCC) -name $* $< -o $@

} ]

        makefile_OutputSRCRule {$(INTERMEDIATEDIR)} qrc_${rootname}.cpp {}
    }
    output "\n\n";

####
#### ROCSRC
    output "# Visage's resource compiler targets.\n"
    foreach x $::Config::ROCSRC {
        set rootname [file rootname $x]
        output [string map [list \
                                @@ROOTNAME@@ $rootname \
                           ] \
{ROCOUTPUT += $(INTERMEDIATEDIR)/@@ROOTNAME@@Relay.cpp
} ]
    }
    output "\n"

    foreach x $::Config::ROCSRC {
        addPackageDependency $::Config::PACKAGE $x
        set rootname [file rootname $x]
        output [string map [list \
                                @@ROOTNAME@@ $rootname \
                                @@SRC@@ $x \
                           ] \
{.PRECIOUS: $(INTERMEDIATEDIR)/@@ROOTNAME@@Relay.cpp

$(INTERMEDIATEDIR)/@@ROOTNAME@@Relay.cpp: @@SRC@@ $(ROC)
	@echo "    [$(MAKE_CFG)] Running Visages' roc on $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(ROC) $< -o $(INTERMEDIATEDIR)/@@ROOTNAME@@Relay

} ]

        makefile_OutputSRCRule {$(INTERMEDIATEDIR)} ${rootname}Relay.cpp {$(ROCOUTPUT)}
    }
    output "\n\n";
#### End of ROCSRC
####

####
#### GSOAPSRC
    output "# Gsoap targets.\n"
    set gsoapout [list]
    foreach src $::Config::GSOAPSRC {
        addPackageDependency $::Config::PACKAGE $src
        set rootname [file rootname $src];
        lappend gsoapout ${rootname}ClientLib.c

        output [string map [list \
                                @@ROOTNAME@@ [file rootname $src] \
                                @@SRC@@ $src \
                           ] \
{$(INTERMEDIATEDIR)/@@ROOTNAME@@ClientLib.c: @@SRC@@
	@echo "    [$(MAKE_CFG)] Running gSOAP's soap2cpp on $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)( wd=$$(pwd) ; cd $(@D) ; $(SOAPCPP2) -I$(BUILDROOT)/src/distributed -c -n -p@@ROOTNAME@@ $$wd/$< )

$(INTERMEDIATEDIR)/@@ROOTNAME@@ServerLib.c \
$(INTERMEDIATEDIR)/@@ROOTNAME@@Server.c \
$(INTERMEDIATEDIR)/@@ROOTNAME@@Client.c \
$(INTERMEDIATEDIR)/@@ROOTNAME@@C.c \
$(INTERMEDIATEDIR)/@@ROOTNAME@@.nsmap: $(INTERMEDIATEDIR)/@@ROOTNAME@@ClientLib.c

} ]
    }

    output \
{
# Make the OBJS dependent on the results of GSOAP.
# This ensures that the outputs of the gsoap compiler are available
# during compilation.
}
        output [string map [list \
                                @@GSOAPOUT@@ [join $gsoapout] \
                           ] \
{GSOAPOUTPUT = $(addprefix $(INTERMEDIATEDIR)/, @@GSOAPOUT@@)

} ]
    output "\n\n";
####
#### End of GSOAPSRC

####
#### CUDASRC
    output "# CUDA targets.\n"
    if { [llength $::Config::CUDASRC] } {
        symlinkGCCForCUDA
    }
    foreach x $::Config::CUDASRC {
        addPackageDependency $::Config::PACKAGE $x
        set rootname [file rootname $x]
        output [string map [list \
                                @@ROOTNAME@@ $rootname \
                                @@SRC@@ $x \
                                @@BINDIR@@ [getCUDACompilerBindir] \
                           ] \
{
$(INTERMEDIATEDIR)/@@ROOTNAME@@.o: @@SRC@@
	@echo "    [$(MAKE_CFG)] Compiling CUDA $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(NVCC) $(NVCCFLAGS) --compiler-options '$(CFLAGS)' --compiler-bindir '@@BINDIR@@' -c $< -o $@

OBJS += $(INTERMEDIATEDIR)/@@ROOTNAME@@.o

} ]
    }
    output "\n\n";
####
#### End of CUDASRC

####
#### SRC
    output "# The C and CPP targets.\n"
    foreach x $::Config::SRC {
        addPackageDependency $::Config::PACKAGE $x
        makefile_OutputSRCRule {} $x {$(UICOUTPUT) $(GSOAPOUTPUT) $(ROCOUTPUT)}
    }
    output "\n\n";
#### End of SRC
####

    output \
{
#
# Architecture specific source files.
#
}
    foreach a [getRequestedArchs] {
        output "ifeq (\$(MAKE_UNAME),$a)\n"

        set src [list]
        if { [info exists ::Config::SRC-$a] } {
            set src [subst $\{::Config::SRC-$a\}]
        }
        foreach x $src {
            addPackageDependency $::Config::PACKAGE $x
            makefile_OutputSRCRule {} $x {$(UICOUTPUT) $(GSOAPOUTPUT) $(ROCOUTPUT)}
        }

        foreach c $configs {
            output "  ifeq (\$(MAKE_CFG),$c)\n"

            set src [list]
            if { [info exists ::Config::SRC-$a-$c] } {
                set src [subst $\{::Config::SRC-$a-$c\}]
            }
            foreach x $src {
                addPackageDependency $::Config::PACKAGE $x
                makefile_OutputSRCRule {} $x {$(UICOUTPUT) $(GSOAPOUTPUT) $(ROCOUTPUT)}
            }

            output "  endif\n"
        }
        output "endif\n\n"
    }
####
#### End of arch specific configurations.
####

    output \
{
# The bison targets:
#  - BISONSRC must match xxx.y and xxx.l for flex.
#
}
    foreach src $::Config::BISONSRC {
        set rootname [file rootname $src]

        addPackageDependency $::Config::PACKAGE $src
        addPackageDependency $::Config::PACKAGE ${rootname}.l

        output [string map [list \
                                @@ROOTNAME@@ ${rootname} \
                                @@BISONSRC@@ $src \
                                @@FLEXSRC@@ ${rootname}.l \
                           ] \
{$(INTERMEDIATEDIR)/@@ROOTNAME@@_tab.cpp: @@BISONSRC@@
	@echo "    [$(MAKE_CFG)] Running bison on $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(BISON) $(BISONFLAGS) $< -d -o $@
	@( cd $(INTERMEDIATEDIR) ; if [ -f @@ROOTNAME@@_tab.hpp ] ; then cp @@ROOTNAME@@_tab.hpp @@ROOTNAME@@_tab.h ; fi )
	@( cd $(INTERMEDIATEDIR) ; if [ -f @@ROOTNAME@@_tab.cpp.h ] ; then cp @@ROOTNAME@@_tab.cpp.h @@ROOTNAME@@_tab.h ; fi )

$(INTERMEDIATEDIR)/@@ROOTNAME@@_lex.cpp: @@FLEXSRC@@ $(INTERMEDIATEDIR)/@@ROOTNAME@@_tab.cpp
	@echo "    [$(MAKE_CFG)] Running flex on $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(FLEX) $(FLEXFLAGS) -o$@ $<


} ]

        makefile_OutputSRCRule {$(INTERMEDIATEDIR)} ${rootname}_tab.cpp {}
        makefile_OutputSRCRule {$(INTERMEDIATEDIR)} ${rootname}_lex.cpp {}
    }

    output \
{
#
# Flex only targets (w/o bison).
#
}
    foreach x $::Config::FLEXSRC {
        addPackageDependency $::Config::PACKAGE $x
        set rootname [file rootname $x]
        output [string map [list \
                                @@ROOTNAME@@ $rootname \
                                @@SRC@@ $x \
                           ] \
{$(INTERMEDIATEDIR)/@@ROOTNAME@@_lex.cpp: @@SRC@@
	@echo "    [$(MAKE_CFG)] Running flex on $(DIRNAME)/$<"
	@mkdir -p $(@D)
	$(QUIET)$(FLEX) $(FLEXFLAGS) -o$@ $<


} ]

        makefile_OutputSRCRule {$(INTERMEDIATEDIR)} ${rootname}_lex.cpp {}
    }

    if {[info exists ::Config::LINKTYPE] && $::Config::LINKTYPE == "symbolic"} {
        output \
{
#
# This is special handling needed to solve problems with C libs
# embeded in more than one library (e.g. libtiff is included in Inventor
# and in hximio).
# The flag below forces to link "symbolic", that means all symbols are
# resolved internally if possible.  This is only possible with C symbols,
# but not with C++ symbols.  The C++ draft requires one flat symbol (link)
# namespace. Every C++ symbol must be global.
#
# Windows avoids this problem. On Windows you need to explicitly
# state for every symbol whether it is exported or not.
#
}
         output \
{LD_SHARED += $(LD_SYMBOLIC)

};
    }

    output \
{
#
# The main targets.
#
}
    if {$::Config::TYPE == "bin"} {
        output \
{bin: $(BINDIR)/$(TARGET)

$(BINDIR)/$(TARGET): $(OBJS)
	@echo "    [$(MAKE_CFG)] Linking binary $@"
	@mkdir -p $(@D)
	@-$(RM) $@
	$(QUIET)$(LINK_BIN) $(OBJS) -o $@ -L$(LIBDIR) $(LIBS)
	@if [ -x "$(TAGLIB)" ] ; then "$(TAGLIB)" -update $@ ; \
	   else echo "WARNING: missing taglib, can't patch target" ; fi

}
        if {$::Config::PACKAGE == "doc2html"} {
            output \
{ifeq ($(MAKE_CFG),Debug)
	@if [ -x /usr/sbin/selinuxenabled ] && /usr/sbin/selinuxenabled ; then chcon -v -t texrel_shlib_t $(LIBDIR)/libtbb_debug.so ; fi
else
	@if [ -x /usr/sbin/selinuxenabled ] && /usr/sbin/selinuxenabled ; then chcon -v -t texrel_shlib_t $(LIBDIR)/libtbb.so ; fi
endif

}
        }
    }

    if {$::Config::TYPE == ""} {
    output \
{lib: $(LIBDIR)/lib$(TARGET).$(SHARED_EXT)

$(LIBDIR)/lib$(TARGET).$(SHARED_EXT): $(OBJS)
	@echo "    [$(MAKE_CFG)] Linking shared library $@"
	@mkdir -p $(@D)
	@-$(RM) $@
	$(QUIET)$(LINK_SHARED) $(OBJS) -o $@ -L$(LIBDIR) $(LIBS)
	@if [ -x "$(TAGLIB)" ] ; then "$(TAGLIB)" -update $@ ; \
	   else echo "WARNING: missing taglib, cannot patch target" ; fi
	@touch $(LIBDIR)


}
    }

    if {$::Config::TYPE == "python"} {
    output \
{python: $(LIBDIR)/_$(TARGET).$(PYTHON_EXT)

$(LIBDIR)/_$(TARGET).$(PYTHON_EXT): $(OBJS)
	@echo "    [$(MAKE_CFG)] Linking python module $@"
	@mkdir -p $(@D)
	@-$(RM) $@
	$(QUIET)$(LINK_SHARED) $(OBJS) -o $@ -L$(LIBDIR) $(LIBS)
	@if [ -x "$(TAGLIB)" ] ; then "$(TAGLIB)" -update $@ ; \
	   else echo "WARNING: missing taglib, cannot patch target" ; fi

}
    }

   if {${::Config::ONLY} != ""} {
        output \
{
# Check if the current architecture matches.
}

    output [string map [list @@ONLY@@ [join [expandAliases ${::Config::ONLY}]]] \
{
ifeq (,$(filter $(MAKE_UNAME),@@ONLY@@))
checkArch:
	@echo "   $(PACKAGE) is ignored on $(MAKE_UNAME)"
else
checkArch: default
endif

} ];
   }

    output \
{copy: $(COPY)

}
    output [string map [list @@BUILDSTAMPFILE@@ [getBuildStampFile $::Config::PACKAGE] ] \
{# 'make clean' removes intermediate directory and files copied.
clean:
	@echo "    [$(MAKE_CFG)] Removing intermediate directory"
	$(QUIET)rm -rf $(INTERMEDIATEDIR)
	$(QUIET)rm -f $(BUILDROOT)/@@BUILDSTAMPFILE@@
	@echo "    [$(MAKE_CFG)] Removing results"
	$(QUIET)rm -f $(BINDIR)/$(TARGET)
	$(QUIET)rm -f $(LIBDIR)/lib$(TARGET).$(SHARED_EXT)
	$(QUIET)rm -f $(LIBDIR)/_$(TARGET).$(PYTHON_EXT)
} ]
    set maxCopy 100000
    output "\t@if \[ \$(words \$(COPY)) -gt $maxCopy \] ; then echo \"Warning: COPY lists \$(words \$(COPY)) files, but 'make clean' will delete only $maxCopy files.\"; fi\n"
    for {set x 1} {$x < $maxCopy} {incr x 500} {
        output "\t@rm -f \$(wordlist $x, [expr $x + 499], \$(COPY))\n"
    }

    output \
{

# 'make dep' generates dependencies from scratch
dep: $(DEPS)

# 'make depclean' removes all automatic dependencies
depclean:
	@echo "    [$(MAKE_CFG)] Removing all automatic dependencies"
	@rm -f $(INTERMEDIATEDIR)/*.d

}


    output \
{
#
# Check if current architecture is supported.
#
}
   output [string map [list \
                          @@MYARCHS@@ [getRequestedArchs] \
                      ] \
{ifneq ($(filter @@MYARCHS@@, $(MAKE_UNAME)), $(MAKE_UNAME))
	$(error this makefile is not generated to be used on $(MAKE_UNAME), use --archs during createBuildSystem run)
endif
} ]

}

proc outputUnameDetection {} {
    output \
{
# The configuration and architecture.
MAKE_CFG ?= Debug

uname_s := $(shell sh -c 'uname -s 2>/dev/null || echo unknown')
uname_m := $(shell sh -c 'uname -m 2>/dev/null || echo unknown')

ifeq ($(uname_s),Linux)
    ifeq ($(uname_m),x86_64)
        MAKE_UNAME = LinuxAMD64
    else
    ifeq ($(uname_m),i686)
        MAKE_UNAME = Linux
    else
        ifeq ($(uname_m),ia64)
            MAKE_UNAME = Linux64
        else
            $(error Unknown Linux machine type '$(uname_m)'.)
        endif
    endif
    endif
else
    ifeq ($(uname_s),Darwin)
        MAKE_UNAME = MacX
    else
        ifeq ($(uname_s),SunOS)
            MAKE_UNAME = SunOS64
        else
            $(error Unknown operating system '$(uname_s)'.)
        endif
    endif
endif

ARCH=arch-$(MAKE_UNAME)-$(MAKE_CFG)

}
}

proc outputCancelingImplicitMakeRules {} {
    output \
{
# Canceling implicit rules
%.o : %.c
%.o : %.cpp
%.o : %.cc
%.o : %.C
%.o : %.p
%.o : %.r
%.o : %.f
%.o : %.F
%.sym : %.def
%.o : %.mod
%.o : %.s
%.s : %.S
% : %.o
%.c : %.y
%.c : %.l
%.r : %.l
%.nl : %c
%.dvi : %.tex
%.tex : %.web
%.tex : %.w
%.p : %.web
%.c : %.w
%.dvi : %.texinfo
%.dvi : %.texi
%.dvi : %.txinfo
%.info : %.texinfo
%.info : %.texi
%.info : %.txinfo

}
}

proc symlinkGCCForCUDA {} {
    if { [llength [getRequestedArchs]] != 1 } {
        error "INTERNAL: symlinkGCCForCUDA supports only a single arch."
    }

    global gGCCSymlinksCreated
    if { [info exists gGCCSymlinksCreated] } {
        return
    }
    findAndLinkGCCForCUDA
    set gGCCSymlinksCreated 1
}

proc findAndLinkGCCForCUDA {} {
    global gccpostfix
    if { [catch {set gcc [exec which gcc$gccpostfix]} ] } {
        message "Error: cannot determine full path to gcc$gccpostfix."
        error "failed to run which"
    }
    if { [catch {set gxx [exec which g++$gccpostfix]} ] } {
        message "Error: cannot determine full path to g++$gccpostfix."
        error "failed to run which"
    }
    file mkdir [getCUDACompilerBindir]
    file delete [file join [getCUDACompilerBindir] gcc]
    file link -symbolic [file join [getCUDACompilerBindir] gcc] $gcc
    file delete [file join [getCUDACompilerBindir] g++]
    file link -symbolic [file join [getCUDACompilerBindir] g++] $gxx
}

proc getCUDACompilerBindir {} {
    set arch [getRequestedArchs]
    return [file join [getCacheDir] cuda arch-$arch bin]
}


proc storeBuildConfig {package config} {
    set f [getBuildConfigDependencyFile $package]
    set oldconfig [readFile $f]
    if { $config != $oldconfig } {
        writeFile $f $config
    }
}

proc readFile {f} {
    set fp [open $f r]
    set content [read $fp]
    close $fp
    return $content
}

proc writeFile {f content} {
    set fp [open $f w+]
    puts -nonewline $fp $content
    close $fp
}

proc getBuildConfigDependencyFile {package} {
    set f [file join [getBuildConfigDir] ${package}.cfg]
    if { ![file exists $f] } {
        createFile $f
    }
    return $f
}

proc createFile {f} {
    set fp [open $f w]
    close $fp
}

proc getBuildConfigDir {} {
    set configstore [file join [getCacheDir] configstore]
    file mkdir $configstore
    return $configstore
}


proc createToplevelGNUmakefile {} {
    global allPackages;
    global MAINROOT

    outputUnameDetection

    outputCancelingImplicitMakeRules

    if { [withIgnorePrepacked] } {
        set defaulttarget "pedantic"
    } else {
        set defaulttarget "fast"
    }
    output [string map [list \
                            @@DEFAULT@@ $defaulttarget \
                            @@WORK@@ [lindex [lindex $allPackages end] 0] \
                       ] \
{

.PHONY: default
default: @@DEFAULT@@

.PHONY: all fast
all fast: @@WORK@@
	@echo '    OK all'

.PHONY: pedantic
pedantic:
	@rm -f $(filter-out $(wildcard intermediate/$(ARCH)/*-docrun.lastbuild), $(wildcard intermediate/$(ARCH)/*.lastbuild))
	$(MAKE) all

} ]

    set packageDirs [getAllPackageDirs]

#### We want to output only dependencies that we are able to build.
    foreach x $allPackages {
        set package [lindex $x 0];
        set have($package) 1
    }

    foreach x $allPackages {
        set package [lindex $x 0];
        set dir [lindex $x 1];
        output ".PHONY: $package\n"
        output "$package:"
        output "\n\t\$(MAKE) [getBuildStampFile $package]"
        output "\n\n[getBuildStampFile $package]:"
        foreach dep [lindex $x 2] {
            if { [info exists have($dep)] } {
                output " [getBuildStampFile $dep]"
            }
        }
        if { $dir != "." } {
            output " [getPackageDependencies $package $dir]"
            output "\n\t\$(MAKE) -C $dir"
        } elseif { [string match doc* $package] } {
            outputDocDependsOnPackages $packageDirs
            output "\n\t@\$(MAKE) [getBuildStampFile ${package}-docrun]"
        }
        output "\n\t@mkdir -p [getBuildStampDirectory]"
        output "\n\t@touch [getBuildStampFile $package]"
        output "\n\t@echo '    OK $package'"
        output "\n\n"
        if { $dir == "." && [string match doc* $package] } {
            output "[getBuildStampFile ${package}-docrun]:"
            if { ![info exists MAINROOT] } {
                output { product/bin/$(ARCH)/doc2html}
            }
            outputDocDependsOnPackages $packageDirs
            foreach {docdir skin} [getDocSkins] {
                output "\n\tmkdir -p product/share/doc/$docdir"
                if { [info exists MAINROOT] } {
                    output "\n\t$MAINROOT/bin/doc2html -a -skin $skin -P $packageDirs"
                } else {
                    output "\n\tproduct/bin/doc2html -a -skin $skin -P $packageDirs"
                }
            }
            output "\n\t@mkdir -p [getBuildStampDirectory]"
            output "\n\t@touch [getBuildStampFile ${package}-docrun]"
            output "\n\n"

            output ".PHONY: doc\n"
            output "doc: $package"
            output "\n\t@echo '    OK doc'"
            output "\n\n"
        }
    }

    if { [info exists have(setup)] } {
        set setup setup
    } else {
        set setup ""
    }

    output [string map [list \
                            @@CLEAN@@ $packageDirs \
                            @@SETUP@@ $setup \
                       ] \
{
.PHONY: clean
clean:
	for dir in @@CLEAN@@; do $(MAKE) -C $$dir clean ; done
	rm -rf product/share/doc

.PHONY: dep
dep: @@SETUP@@
	for dir in @@CLEAN@@; do $(MAKE) -C $$dir dep ; done

.PHONY: depclean
depclean:
	for dir in @@CLEAN@@; do $(MAKE) -C $$dir depclean ; done

} ]

# build filtered package list to be used by makeDoc script
    set lstfile [file join [getCacheDir] packagedirs]
    if {[catch {set lstfp [open $lstfile "w"]}]} {
        message "Error opening $lstfile for writing."
        error "I/O error"
    }
    foreach p [getAllPackageDirs] {
        puts $lstfp $p
    }
    close $lstfp
}

proc outputDocDependsOnPackages {packageDirs} {
    output " \$(wildcard "
    foreach d $packageDirs {
        output " $d/doc"
    }
    output ")"
}

proc getBuildStampDirectory {} {
    file join [getIntermediateDir] {$(ARCH)}
}

proc getBuildStampFile {dep} {
    file join [getBuildStampDirectory] $dep.lastbuild
}

proc addPackageDependency {package dep} {
    global g_depsOfPackage
    if { ![info exists g_depsOfPackage($package)] } {
        set g_depsOfPackage($package) [list]
    }
    set g_depsOfPackage($package) [concat $g_depsOfPackage($package) $dep]
}

proc getPackageDependencies {package dir} {
    global g_depsOfPackage
    if { ![info exists g_depsOfPackage($package)] } {
        return [list]
    }
    set result [list]
    foreach d $g_depsOfPackage($package) {
        lappend result [file join $dir $d]
    }
    return $result
}
