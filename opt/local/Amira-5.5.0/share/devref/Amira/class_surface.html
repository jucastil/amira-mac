<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: Surface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>Surface Class Reference<br>
<small>
[<a class="el" href="group__hxsurface.html">hxsurface</a>]</small>
</h1><!-- doxytag: class="Surface" -->This class implements structured, triangulated surfaces.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;hxsurface/Surface.h&gt;</code>
<p>
<p>Inheritance diagram for Surface:
<p><center><img src="class_surface.png" usemap="#Surface_map" border="0" alt=""></center>
<map name="Surface_map">
<area href="class_hx_surface.html" alt="HxSurface" shape="rect" coords="0,56,105,80">
<area href="class_rm_surface_atlas.html" alt="RmSurfaceAtlas" shape="rect" coords="115,56,220,80">
<area href="class_rm_surface_chart.html" alt="RmSurfaceChart" shape="rect" coords="230,56,335,80">
<area href="class_rm_atlas_surface.html" alt="RmAtlasSurface" shape="rect" coords="0,112,105,136">
</map>
<a href="class_surface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Member variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531e">NormalBinding</a> { <a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531edfd989600d7414599213bd0356f946c1">PER_TRIANGLE</a> = 0, 
<a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531e9bc0712e410241193c2e3bdbf8eaf0d6">PER_VERTEX</a>, 
<a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531ea4853c18f14f6fe924375d32999e19ba">PER_VERTEX_INDEXED</a>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#9750fccc7a29f548233d65380cd8e0e9">nBranchingPoints</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Branching points have indices [0...nBranchingPoints-1].  <a href="#9750fccc7a29f548233d65380cd8e0e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#bf920fa856b1a4dcda4bae15a61d6c98">nContourPoints</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_surface_1_1_contour.html">Contour</a> points start with index <code>nBranchingPoints</code>.  <a href="#bf920fa856b1a4dcda4bae15a61d6c98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_vec3f.html">McVec3f</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#177557af73f7a8dcbed7a3a553ee3b1f">points</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of all surface points (required).  <a href="#177557af73f7a8dcbed7a3a553ee3b1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; unsigned char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#830f372ae6cb1e8b5d4194c46f3e0c8e">pointType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of point types (full surface only).  <a href="#830f372ae6cb1e8b5d4194c46f3e0c8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_surface_1_1_contour.html">Contour</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#45d9e4539ab013c31e4a2e6dbfc2cdf4">contours</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of all surface contours (full surface only).  <a href="#45d9e4539ab013c31e4a2e6dbfc2cdf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_surface_1_1_patch.html">Patch</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#434fa639568ba777148f9b86371c1392">patches</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of all surface patches (at least 1 patch is required).  <a href="#434fa639568ba777148f9b86371c1392"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_surface_1_1_triangle.html">Triangle</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#b03717d5b8e2aef2e376e9dfcfbe637d">triangles</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of all surface triangles (required).  <a href="#b03717d5b8e2aef2e376e9dfcfbe637d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_surface_1_1_edge.html">Edge</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#f93e6d26052712a83e7509210268c2c8">edges</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All edges of the surface (temporary data).  <a href="#f93e6d26052712a83e7509210268c2c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 6 &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#e127e6f419621318cb77ca0292adaa9b">edgesPerPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores for each point all edges incident at that point (temporary).  <a href="#e127e6f419621318cb77ca0292adaa9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_s_array.html">McSArray</a>&lt; int, 3 &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#032aa969557bb20b854d3b08549a0381">edgesPerTriangle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores the edge ids for each triangle (optional and temporary).  <a href="#032aa969557bb20b854d3b08549a0381"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 6 &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#5026feae6988155b75ae53bda9f3d536">trianglesPerPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores for each point all incident triangles.  <a href="#5026feae6988155b75ae53bda9f3d536"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 6 &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#51e8e0068a6fcfe8470ea923106e23a5">neighsPerPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stores for each point all neighboured points.  <a href="#51e8e0068a6fcfe8470ea923106e23a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_hx_param_bundle.html">HxParamBundle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#f3628d950a0bdb94338149be6730f13d">params</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains info about the regions.  <a href="#f3628d950a0bdb94338149be6730f13d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_vec3f.html">McVec3f</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a1807c2a912f6d292503821205b089aa">normals</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531e">NormalBinding</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#119e5da77e8cc0c46a9487ce368e0750">normalBinding</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface_l_o_d.html">SurfaceLOD</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#4e35934832f379095e87f703b326dfdf">lod</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to surface level-of-detail.  <a href="#4e35934832f379095e87f703b326dfdf"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Internal methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#7361411368323c74790874c7afc23b51">isClosedSegment</a> (int patch, int segment)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#775f83d307d2f7b38218014fca3ea31a">computeTrianglesPerPoint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the array <code>trianglePerPoint</code>.  <a href="#775f83d307d2f7b38218014fca3ea31a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#7580f3ef1cf376029ec707c1561fc53e">createAllEdges</a> (int createEdgeIds=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the <code>edges</code>, the <code>edgesPerPoint</code> and optionally the <code>edgesPerTriangle</code> arrays.  <a href="#7580f3ef1cf376029ec707c1561fc53e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#c026a37c7377d4791c5346e439630b65">createConnectivity</a> (int patch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the neighbour array for each triangle in patch.  <a href="#c026a37c7377d4791c5346e439630b65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#1b747a697673778f9c037439b29c5702">createConnectivity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the neighbour array for all triangles.  <a href="#1b747a697673778f9c037439b29c5702"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3238ccad51ab06689b86f99a72677912">createNeighbours</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the neighbour array for all triangles without decomposing patches.  <a href="#3238ccad51ab06689b86f99a72677912"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a193fc3a33c9a6903970cf99d9c05561">findBranchingPoints</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This methods initializes the <code>type</code> field in all point-structures with the correct value.  <a href="#a193fc3a33c9a6903970cf99d9c05561"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#9c9672bd0d4f2a1b0a51e988a942e221">clearInnerEdges</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes edges, that are not part of a contour.  <a href="#9c9672bd0d4f2a1b0a51e988a942e221"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3a0cbf17e4fe269adc04a69362cb7333">clearInnerEdges</a> (int renumber)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes edges, that are not part of a contour.  <a href="#3a0cbf17e4fe269adc04a69362cb7333"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a168d01760ea839f45c587645c71ff9b">findContours</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find contours, by tracing edges.  <a href="#a168d01760ea839f45c587645c71ff9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a4c5868ebdc4dbade7aee2f067de6b2e">renumberPoints</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method shuffels the points in such a way, that they are sorted according to their type in the following way: BRANCHING-points, CONTOUR-Points, INNER-Points.  <a href="#a4c5868ebdc4dbade7aee2f067de6b2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#f6be792b29f5ee7eb66d63caafed60b2">deleteDeadEnds</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#234d32b7cd8199e6345fbf9cfff9d6ce">sortContoursOfPatch</a> (int p, int fixDeadEnds=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort the contours so that they form one (or more) closed path.  <a href="#234d32b7cd8199e6345fbf9cfff9d6ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#5c84a4e9a520764ebc6f0c7048cdf07f">sortContoursOfPatches</a> (int fixDeadEnds=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls sortContoursOfPatch for all patches.  <a href="#5c84a4e9a520764ebc6f0c7048cdf07f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#52d540a614912f8680f76e50c5052dca">sortTriangles</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sort triangle list according to patch order  <a href="#52d540a614912f8680f76e50c5052dca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#c40c1cfa21ac4374464b47410ae22cc5">findBranchingPointsOfPatches</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3d7954c8a813d7b8aa6d445b48a3ec6c">computeOrientationOfContours</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#c39ec1019c98a0ca4443978331bea864">tile</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pidx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a triangulation for the polygon, consisting of the vertices v[].  <a href="#c39ec1019c98a0ca4443978331bea864"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#06bdbbbf169843943ec8c290ff78d166">tileCenter</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pidx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#c92ab7d4071ecf0d76a923672e3143f0">tileFan</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pidx, int anchor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#20456278ade3aa0fe468ec64b62f6a6b">fitPlane</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pidx, float plane[4])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute best fitting plane for a polygon usign Newells method.  <a href="#20456278ade3aa0fe468ec64b62f6a6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#f77835c316a801e0d8c1461b9310024b">getMaterialID</a> (const char *mat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns -1 if material is not found.  <a href="#f77835c316a801e0d8c1461b9310024b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#2d29f8c01489442d7dd4961bf0b98f58">addMaterial</a> (const char *name, int id=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#84c35d1cf6a79ccaf30ab25586bddec0">setBoundaryIDInfo</a> (int id, const char *typeStr=0, const char *info=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets boundary information for the given id into the object's parameter bundle.  <a href="#84c35d1cf6a79ccaf30ab25586bddec0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#0b14dfa2f9e6a2614a229834b2eb9602">removePoint</a> (int patch, int point)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#bba65568a94b23f662df3ceeb0463d06">removeDuplicateTriangles</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove triangles containing the same three points.  <a href="#bba65568a94b23f662df3ceeb0463d06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#1c2333005a48d6a5ea82258f8acd0ee8">removeDegenerateTriangles</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove triangles with two or three identical points.  <a href="#1c2333005a48d6a5ea82258f8acd0ee8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#cfe84d177e90528a8a5650775353cabe">isInnerPoint</a> (int idx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#58f22f84cbd097de7028e2dae38f5b04">contourFromPoint</a> (<a class="el" href="structoint.html">oint</a> contourIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get first point of contour indexed by <code>contourIdx</code>.  <a href="#58f22f84cbd097de7028e2dae38f5b04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#c508b72577c3d5dbb28d7a69a81f7c93">contourToPoint</a> (<a class="el" href="structoint.html">oint</a> contourIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last point of contour indexed by <code>contourIdx</code>.  <a href="#c508b72577c3d5dbb28d7a69a81f7c93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#177f444ba6ae5fb8b87e591dc225127a">getEdgeOfTriangle</a> (int triangleIdx, int which)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#135ff481c37f92a47be9de61dbc2daea">getNeighbourTriangle</a> (int triangleIdx, int which, int global=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#12195a8ad4886982e8087c34893eb860">getNextNeighbourTriangle</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a231f185c05f30338cdc70ef94134d1d">operator==</a> (const <a class="el" href="class_surface.html">Surface</a> &amp;other) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#88e654aab5d39c824fd1bfd693bb394e">print</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#9de6529690133fd8b4036686a9f57e3e">copyData</a> (const <a class="el" href="class_surface.html">Surface</a> &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the whole data set.  <a href="#9de6529690133fd8b4036686a9f57e3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#146b3a3a45a45c3582b0a264d0ba3da0">appendTriangle</a> (int patchIdx, <a class="el" href="class_surface_1_1_triangle.html">Triangle</a> &amp;triangle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a triangle and inserts it in given patch.  <a href="#146b3a3a45a45c3582b0a264d0ba3da0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3ef357a7fe4ef6aa71271006a4e31088">checkClosedness</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;patchOrientations, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;triangleList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check surface closedness.  <a href="#3ef357a7fe4ef6aa71271006a4e31088"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#b2f8f7dfcf4dfa757bcbaa53df94c356">intersectionTest</a> (int t, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;neighbours, float eps, int selectNeighbours=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check intersection of triangle t with its neighbours.  <a href="#b2f8f7dfcf4dfa757bcbaa53df94c356"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#32103d1c97b9ae267dc945f4c57ce617">classifyEdges</a> (int iRegion, int &amp;nOdd, int &amp;nEdge0, int &amp;nEdge2, int &amp;nEdge4, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;markEdges, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;triangleList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine number of triangles of region adjacent to each edge.  <a href="#32103d1c97b9ae267dc945f4c57ce617"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#b5b7a7412be8d7233a7d09589897b086">createTriangleGroups</a> (const int iRegion, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;markEdges, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;markTriangles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create groups of connected triangles.  <a href="#b5b7a7412be8d7233a7d09589897b086"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#c7d8e4a1d113fdcfa6b3f1a88bd08934">findInconsistentEdges</a> (const int iRegion, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;markEdges, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;markTriangles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find inconsistent edges.  <a href="#c7d8e4a1d113fdcfa6b3f1a88bd08934"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#fd5ea65c56da121da49d5b49b881944d">createClosedSurfaces</a> (const int iRegion, int nGroups, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;markEdges, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;markTriangles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create closed surfaces.  <a href="#fd5ea65c56da121da49d5b49b881944d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#dc4c38170a370424db1d4c50cf3e91b2">calcEnclosedVolumes</a> (const int iRegion, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;markTriangles, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; float &gt; &amp;enclosedVolumes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate volumes enclosed by surfaces.  <a href="#dc4c38170a370424db1d4c50cf3e91b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ba932462c35cb4a28ac80827f559e47e">checkEnclosedVolumes</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; float &gt; &amp;enclosedVolumes, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;inclusionInfo, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;markTriangles, int insideOut, int &amp;groupsOf4, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;triangleList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check enclosed volumes.  <a href="#ba932462c35cb4a28ac80827f559e47e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#c06ab1b90a88a9de37a350f62e724dc0">calcMinMaxMeanEdgeLen</a> (float *min, float *max, float *mean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate minimal, maximal and mean edge length.  <a href="#c06ab1b90a88a9de37a350f62e724dc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#d60b1762e248775cd352f39526bc3ffc">calcEdgeLengths</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; float &gt; &amp;lengths)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute edge lengths.  <a href="#d60b1762e248775cd352f39526bc3ffc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#60e4ffaedca452c6e5ec0cf3c3ef8aea">getEdgeCurvature</a> (int edge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns value for (signed) curvature at edge: 0=planar, +1=maximally convex, -1=maximally concave.  <a href="#60e4ffaedca452c6e5ec0cf3c3ef8aea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#368ce06bcf54deb49b9d5ff28ae3ed03">getTriangleArea</a> (int triangle) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns area of triangle.  <a href="#368ce06bcf54deb49b9d5ff28ae3ed03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_vec3f.html">McVec3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#2274fa62f1bff35eb1981aeaca8f72a3">getTriangleNormal</a> (int triangle) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns normal at triangle.  <a href="#2274fa62f1bff35eb1981aeaca8f72a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_vec3f.html">McVec3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#f6ae65f823363690f1705759ae562e16">getVertexNormal</a> (int vertex) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns normal at triangle.  <a href="#f6ae65f823363690f1705759ae562e16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#bd629d6dfd32a9757948ad128f634bb6">getPatchArea</a> (int patch) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get surface area of given patch.  <a href="#bd629d6dfd32a9757948ad128f634bb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#d656c52f6516f3a0adc17c8fc36f32d5">makeOnePatch</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make one patch.  <a href="#d656c52f6516f3a0adc17c8fc36f32d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#2ff3ce636d1a2b522b54000c276f68f2">getEdgeIdx</a> (int v1, int v2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute index of edge between given vertices.  <a href="#2ff3ce636d1a2b522b54000c276f68f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#65ba9765313704b76f4d4fa81cdff98d">getTriangleIdx</a> (int v1, int v2, int v3) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute index of triangle with given vertices.  <a href="#65ba9765313704b76f4d4fa81cdff98d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#6890c114fea0c9e1c0e462174cdb2ca3">get3rdPoint</a> (int v1, int v2, int triIdx, int &amp;orient) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a triangle index and two nodes, compute 3rd node number.  <a href="#6890c114fea0c9e1c0e462174cdb2ca3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#da5a6dec569ab548b2d3c42d6a550fb6">getTrianglesAlongPath</a> (const <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;isPathEdge, const <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;considerTriangle, int orient, int v1, int v2, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;nodes, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;tris)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute triangles along border around node v1 inside given patch.  <a href="#da5a6dec569ab548b2d3c42d6a550fb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#bf93b28dd475980af21eb590bc5e8794">getNeighsPerPoint</a> (int node, <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 6 &gt; &amp;neighs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute neighboured points around given points (sorted anti-clockwise if possible).  <a href="#bf93b28dd475980af21eb590bc5e8794"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#9e28b2ded806bd1514831364dc718b4c">getNeighsPerPointWithMaterial</a> (int node, <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 6 &gt; &amp;neighs, int materialId)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute neighboured points around given points (sorted anti-clockwise if possible).  <a href="#9e28b2ded806bd1514831364dc718b4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#2f1e9cd3f16275d92f976e025721587a">getNeighsPerPoint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute neighboured nodes at all vertices (only needs trianglePerPoint data).  <a href="#2f1e9cd3f16275d92f976e025721587a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#8301ef62c57a31c78dd3ae45095fb2c5">setPathEdges</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;nodes, <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;isPathEdge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine indices of edges that connect given nodes.  <a href="#8301ef62c57a31c78dd3ae45095fb2c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#66f76ecb40e2a190fb5d9ade6fb5b809">unsetPathEdges</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;nodes, <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;isPathEdge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset edges that connect given nodes.  <a href="#66f76ecb40e2a190fb5d9ade6fb5b809"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3879dc0182a58f0e2322d9a78d1a2222">getEnclosedTriangles</a> (int first, const <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;isPathEdge, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;enclosed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get triangles enclosed by given edges.  <a href="#3879dc0182a58f0e2322d9a78d1a2222"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#b34442f875881c5ed869f3344bcacc0d">isClosedLoop</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &gt; &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if array of vertices form a closed loop on the surface.  <a href="#b34442f875881c5ed869f3344bcacc0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#0cc35d77dc775787d34aaea36ca07811">getPathLength</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute length of edge path on surface.  <a href="#0cc35d77dc775787d34aaea36ca07811"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#8efd9c3414a9d4f2a393c910c3633753">getPathLength</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;path, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; float &gt; &amp;lengths)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute length of edge path (and for each edge) on surface.  <a href="#8efd9c3414a9d4f2a393c910c3633753"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#316e1ea68a5e30b43bbbb08f68e2fa49">bfs</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;nodes, int depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get vertices around given points.  <a href="#316e1ea68a5e30b43bbbb08f68e2fa49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#4eb428301e39f323a56812dbed520ad3">debug</a></td></tr>

<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a67305491c40d658d29685506db81162aeef9ed">INNER</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a673054b9f629111394a6bd056a61f7189d02b3">CONTOUR</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a673054ecce9d00e54fe058d0090748b4fc8651">BRANCHING</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a6730547397e66abacc1627a8af0bd83185938f">DEADEND</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a6730548d526e7d0bf10f99c548ba4a347e3726">UNUSED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531edfd989600d7414599213bd0356f946c1">PER_TRIANGLE</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531e9bc0712e410241193c2e3bdbf8eaf0d6">PER_VERTEX</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531ea4853c18f14f6fe924375d32999e19ba">PER_VERTEX_INDEXED</a></td></tr>

<tr><td colspan="2"><div class="groupHeader">Subclass declaration</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a67305491c40d658d29685506db81162aeef9ed">INNER</a> = 0, 
<a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a673054b9f629111394a6bd056a61f7189d02b3">CONTOUR</a>, 
<a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a673054ecce9d00e54fe058d0090748b4fc8651">BRANCHING</a>, 
<a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a6730547397e66abacc1627a8af0bd83185938f">DEADEND</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_surface.html#3d5643adcc5179dd8fa0b0d63a6730548d526e7d0bf10f99c548ba4a347e3726">UNUSED</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Point type. Stored in separate array.  <a href="class_surface.html#3d5643adcc5179dd8fa0b0d63a673054">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#af0a4f7f167d68db58328e0c1d3b1498">Surface</a> (<a class="el" href="class_hx_param_bundle.html">HxParamBundle</a> *<a class="el" href="class_surface.html#f3628d950a0bdb94338149be6730f13d">params</a>=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. If params is null an own parameter bundle is created.  <a href="#af0a4f7f167d68db58328e0c1d3b1498"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#d58aadc59c6c7d59543f0b5611fb835d">~Surface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#d58aadc59c6c7d59543f0b5611fb835d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#5c29ec33fd7c734dff4beb10d257d9a4">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes all points, triangles, patches, materials, etc.  <a href="#5c29ec33fd7c734dff4beb10d257d9a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#9e973d1e207f6dda12886893193f22a7">hasContours</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns 1 if the contours of the surface have been computed.  <a href="#9e973d1e207f6dda12886893193f22a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#8c7c16cfdfbb7538570900f2c8e70278">recompute</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method recomputes the connectivity information of a surface.  <a href="#8c7c16cfdfbb7538570900f2c8e70278"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a7620f7b0d41483ae50687807a87b170">recomputeNoRenumberPoints</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#1ce90b3d6340fe4e89b76b3a03f7f435">removeEmptyPatches</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes patches containing no triangles.  <a href="#1ce90b3d6340fe4e89b76b3a03f7f435"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ee1f3f756953baa477eb48703ab593f4">removeObsoleteTriangles</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all triangles with patchid&lt;0, returns number of removed tris.  <a href="#ee1f3f756953baa477eb48703ab593f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#be83089309c4dc79b556642c10715a0b">removeCoplanarTriangles</a> (int nMaxIter=4, int checkQuads=0, bool cleanup=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove coplanar triangles.  <a href="#be83089309c4dc79b556642c10715a0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#bc94205b6e143a06fc600ffc68801b97">findUsedPoints</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;used)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the list with the state of Isolation for all points.  <a href="#bc94205b6e143a06fc600ffc68801b97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#9fe5d198911a7c91cf2ab97be19633f3">removeUnusedPoints</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all points not referenced by any triangle.  <a href="#9fe5d198911a7c91cf2ab97be19633f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#d36d795f802895d2c75b27da1154b4b5">removeUnusedPoints</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;newIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all points not referenced by any triangle.  <a href="#d36d795f802895d2c75b27da1154b4b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#2e67742e4600f675b6a1b531113051ad">mergeFields</a> (<a class="el" href="class_surface.html">Surface</a> *other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">merges all Fields from the other surface to the fields of this surface.  <a href="#2e67742e4600f675b6a1b531113051ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#161f480505f127341d25ad8deda7f433">simplify34</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplify almost planar 3-star and 4-star configurations.  <a href="#161f480505f127341d25ad8deda7f433"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#01b8c79b4aa368599bb1ab8271c4a4fb">cleanup</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discards the contour information.  <a href="#01b8c79b4aa368599bb1ab8271c4a4fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#5422d2b1efb8c6e567e33dd80512178c">getBoundingBox</a> (float box[6]) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns bounding box of point coordinates.  <a href="#5422d2b1efb8c6e567e33dd80512178c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#7f27512e036679a2f39e79d3b395394f">getCenter</a> (float center[3])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns center of the surface (= average of all point coordinates).  <a href="#7f27512e036679a2f39e79d3b395394f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#7c3d69fb71ccfb50aa79cb02c819107c">setCenter</a> (const float center[3])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modifies the coordinates of the surface points.  <a href="#7c3d69fb71ccfb50aa79cb02c819107c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#23855cbd11e932b3ceea95ddf2b40956">add</a> (const <a class="el" href="class_surface.html">Surface</a> *other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies points, triangles, and patches from other surface into this.  <a href="#23855cbd11e932b3ceea95ddf2b40956"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#b62d0106ff903d92056cc66cddd9406c">read</a> (const char *, <a class="el" href="class_progress_sender_iface.html">ProgressSenderIface</a> *progress=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the surface from a file.  <a href="#b62d0106ff903d92056cc66cddd9406c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#b43c41d514de122e148eb8ecfb61755b">readSurfaceData</a> (const char *file, FILE *in, int ascii, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="struct_surface_data.html">SurfaceData</a> * &gt; &amp;additionalData, <a class="el" href="class_progress_sender_iface.html">ProgressSenderIface</a> *progress=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read surface information except header.  <a href="#b43c41d514de122e148eb8ecfb61755b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#fa987233e11ede208695ddc953c5dd49">readPLY</a> (const char *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the surface from a file.  <a href="#fa987233e11ede208695ddc953c5dd49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#54c537fb18b4de58062bbd756f318d1d">read</a> (const char *, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="struct_surface_data.html">SurfaceData</a> * &gt; &amp;additionalData, <a class="el" href="class_progress_sender_iface.html">ProgressSenderIface</a> *progress=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alternative read method which also return optional surface data.  <a href="#54c537fb18b4de58062bbd756f318d1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#d13cc22625686a8dbff26636674561ce">write</a> (const char *file, int ascii=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write surface + header to a file.  <a href="#d13cc22625686a8dbff26636674561ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#e9c3c41c823ad92b91e6732c5567466e">writeSurfaceData</a> (FILE *out, int ascii=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the surface without header to file.  <a href="#e9c3c41c823ad92b91e6732c5567466e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#4b9adc35933e35ab31d4ba5a47a8c2d5">checkConsistency</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a consistency check (not very sophisticated up to now).  <a href="#4b9adc35933e35ab31d4ba5a47a8c2d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#96d2b173186aa8ae2fe71da6537daa58">checkIndices</a> (bool fixInvalidIndices)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if indices are valid or if they are out-of-range.  <a href="#96d2b173186aa8ae2fe71da6537daa58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#505c60413854138e87441d7fbdb8b7a6">computeNormalsPerTriangle</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#26dc6d78941fa812670dfe435c023bbc">computeNormalsPerVertexIndexed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#f580a9c7bd77ea8fc722f8c44c7930be">computeNormalsPerVertex</a> (float creaseAngle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#0d065b980ca740fffd6c30c9b813a8c0">refine</a> (int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine surface.  <a href="#0d065b980ca740fffd6c30c9b813a8c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a8ca829da523a5b0d71f2f6691685032">refineSubdivideEdges</a> (const float maxEdgeLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function subdivides the surface edges until all edges are shorter than <code>maxEdgeLength</code>.  <a href="#a8ca829da523a5b0d71f2f6691685032"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#29f9279729f26047bbac5d8a69686836">fixOrientation</a> (int patch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes orientation of triangles in patch consistent, by inverting some if necessary.  <a href="#29f9279729f26047bbac5d8a69686836"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#73cfb57927eb6f33f65af9ddeff3fd18">invertTriangles</a> (int patch=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invert the triangles of patch <code>patch</code> or all triangles, if patch==-1.  <a href="#73cfb57927eb6f33f65af9ddeff3fd18"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_1_1_contour.html">Contour</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represents a contour where different patches join.  <a href="class_surface_1_1_contour.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_1_1_edge.html">Edge</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represents a surface edge.  <a href="class_surface_1_1_edge.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_1_1_patch.html">Patch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represents a patch of connected triangles.  <a href="class_surface_1_1_patch.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_1_1_triangle.html">Triangle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represents a surface triangle.  <a href="class_surface_1_1_triangle.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class implements structured, triangulated surfaces. 
<p>
A surface consists of a number of sub-surfaces, called <code>patches</code>. Each patch can have different regions on its two sides: <code>innerRegion</code> and <code>outerRegion</code>. Patches are bounded by <code>contours</code>.<p>
Points can have different <code>pointTypes</code>. Points not lying on a contour are <code>INNER</code> points. Points lying on more than one contour, or being the first or last point of a contour are <code>BRANCHING</code> points. All other points are <code>CONTOUR</code> points.<p>
This implementation works with indices instead of pointers, this allows easy realloc. The surface contains one big array of <code>points</code>, of <code>triangles</code>, of <code>patches</code>, of <code>contours</code> and for temporary use of <code>edges</code> and lists of <code>edgesPerPoint</code> for each point. 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="3d5643adcc5179dd8fa0b0d63a673054"></a><!-- doxytag: member="Surface::@21" ref="3d5643adcc5179dd8fa0b0d63a673054" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Point type. Stored in separate array. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="3d5643adcc5179dd8fa0b0d63a67305491c40d658d29685506db81162aeef9ed"></a><!-- doxytag: member="INNER" ref="3d5643adcc5179dd8fa0b0d63a67305491c40d658d29685506db81162aeef9ed" args="" -->INNER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="3d5643adcc5179dd8fa0b0d63a673054b9f629111394a6bd056a61f7189d02b3"></a><!-- doxytag: member="CONTOUR" ref="3d5643adcc5179dd8fa0b0d63a673054b9f629111394a6bd056a61f7189d02b3" args="" -->CONTOUR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="3d5643adcc5179dd8fa0b0d63a673054ecce9d00e54fe058d0090748b4fc8651"></a><!-- doxytag: member="BRANCHING" ref="3d5643adcc5179dd8fa0b0d63a673054ecce9d00e54fe058d0090748b4fc8651" args="" -->BRANCHING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="3d5643adcc5179dd8fa0b0d63a6730547397e66abacc1627a8af0bd83185938f"></a><!-- doxytag: member="DEADEND" ref="3d5643adcc5179dd8fa0b0d63a6730547397e66abacc1627a8af0bd83185938f" args="" -->DEADEND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="3d5643adcc5179dd8fa0b0d63a6730548d526e7d0bf10f99c548ba4a347e3726"></a><!-- doxytag: member="UNUSED" ref="3d5643adcc5179dd8fa0b0d63a6730548d526e7d0bf10f99c548ba4a347e3726" args="" -->UNUSED</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="44deeaf75187a279d6e5ab261cbc531e"></a><!-- doxytag: member="Surface::NormalBinding" ref="44deeaf75187a279d6e5ab261cbc531e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531e">Surface::NormalBinding</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="44deeaf75187a279d6e5ab261cbc531edfd989600d7414599213bd0356f946c1"></a><!-- doxytag: member="PER_TRIANGLE" ref="44deeaf75187a279d6e5ab261cbc531edfd989600d7414599213bd0356f946c1" args="" -->PER_TRIANGLE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="44deeaf75187a279d6e5ab261cbc531e9bc0712e410241193c2e3bdbf8eaf0d6"></a><!-- doxytag: member="PER_VERTEX" ref="44deeaf75187a279d6e5ab261cbc531e9bc0712e410241193c2e3bdbf8eaf0d6" args="" -->PER_VERTEX</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="44deeaf75187a279d6e5ab261cbc531ea4853c18f14f6fe924375d32999e19ba"></a><!-- doxytag: member="PER_VERTEX_INDEXED" ref="44deeaf75187a279d6e5ab261cbc531ea4853c18f14f6fe924375d32999e19ba" args="" -->PER_VERTEX_INDEXED</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="af0a4f7f167d68db58328e0c1d3b1498"></a><!-- doxytag: member="Surface::Surface" ref="af0a4f7f167d68db58328e0c1d3b1498" args="(HxParamBundle *params=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Surface::Surface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hx_param_bundle.html">HxParamBundle</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. If params is null an own parameter bundle is created. 
<p>

</div>
</div><p>
<a class="anchor" name="d58aadc59c6c7d59543f0b5611fb835d"></a><!-- doxytag: member="Surface::~Surface" ref="d58aadc59c6c7d59543f0b5611fb835d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Surface::~Surface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5c29ec33fd7c734dff4beb10d257d9a4"></a><!-- doxytag: member="Surface::clear" ref="5c29ec33fd7c734dff4beb10d257d9a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Surface::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes all points, triangles, patches, materials, etc. 
<p>

<p>
Reimplemented in <a class="el" href="class_rm_surface_chart.html#2704879a805f97a1dbecb61968e8de92">RmSurfaceChart</a>.
</div>
</div><p>
<a class="anchor" name="9e973d1e207f6dda12886893193f22a7"></a><!-- doxytag: member="Surface::hasContours" ref="9e973d1e207f6dda12886893193f22a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::hasContours           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns 1 if the contours of the surface have been computed. 
<p>

</div>
</div><p>
<a class="anchor" name="8c7c16cfdfbb7538570900f2c8e70278"></a><!-- doxytag: member="Surface::recompute" ref="8c7c16cfdfbb7538570900f2c8e70278" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::recompute           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method recomputes the connectivity information of a surface. 
<p>
<a class="el" href="class_surface.html">Surface</a> contours and point types are inewly determined. Patches containing disconnected triangles are separated into new patches. 
</div>
</div><p>
<a class="anchor" name="a7620f7b0d41483ae50687807a87b170"></a><!-- doxytag: member="Surface::recomputeNoRenumberPoints" ref="a7620f7b0d41483ae50687807a87b170" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::recomputeNoRenumberPoints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1ce90b3d6340fe4e89b76b3a03f7f435"></a><!-- doxytag: member="Surface::removeEmptyPatches" ref="1ce90b3d6340fe4e89b76b3a03f7f435" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::removeEmptyPatches           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes patches containing no triangles. 
<p>

</div>
</div><p>
<a class="anchor" name="ee1f3f756953baa477eb48703ab593f4"></a><!-- doxytag: member="Surface::removeObsoleteTriangles" ref="ee1f3f756953baa477eb48703ab593f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::removeObsoleteTriangles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all triangles with patchid&lt;0, returns number of removed tris. 
<p>

</div>
</div><p>
<a class="anchor" name="be83089309c4dc79b556642c10715a0b"></a><!-- doxytag: member="Surface::removeCoplanarTriangles" ref="be83089309c4dc79b556642c10715a0b" args="(int nMaxIter=4, int checkQuads=0, bool cleanup=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::removeCoplanarTriangles           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxIter</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>checkQuads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>cleanup</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove coplanar triangles. 
<p>
The methods uses an iterative reduction scheme. It stops when no more coplanar triangles are found after an iteration or if the maximum number of iterations is reached (<code>maxIter</code>). If checkQuads is set also coplanar intersecting quad configurations are removed. If <code>cleanup</code> is set, and triangles have been removed,<ul>
<li>obsolete triangles will be removed at the end,</li><li>if the surface had an edge list before, a new up-to-date edge list will be generated.</li></ul>
<p>
The method returns the number of removed triangles. 
</div>
</div><p>
<a class="anchor" name="bc94205b6e143a06fc600ffc68801b97"></a><!-- doxytag: member="Surface::findUsedPoints" ref="bc94205b6e143a06fc600ffc68801b97" args="(McDArray&lt; int &gt; &amp;used)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::findUsedPoints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>used</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the list with the state of Isolation for all points. 
<p>
1 for non-isolated(used) and 0 for non-isolated(used). 
</div>
</div><p>
<a class="anchor" name="9fe5d198911a7c91cf2ab97be19633f3"></a><!-- doxytag: member="Surface::removeUnusedPoints" ref="9fe5d198911a7c91cf2ab97be19633f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::removeUnusedPoints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all points not referenced by any triangle. 
<p>
Returns the number of removed points 
<p>
Reimplemented in <a class="el" href="class_rm_atlas_surface.html#1e1d9c2f1814dd9a060c75cb024af806">RmAtlasSurface</a>.
</div>
</div><p>
<a class="anchor" name="d36d795f802895d2c75b27da1154b4b5"></a><!-- doxytag: member="Surface::removeUnusedPoints" ref="d36d795f802895d2c75b27da1154b4b5" args="(McDArray&lt; int &gt; &amp;newIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::removeUnusedPoints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>newIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all points not referenced by any triangle. 
<p>
Returns the number of removed points 
<p>
Reimplemented in <a class="el" href="class_rm_atlas_surface.html#5cde8e328ad57efc9c16ce319f51aea9">RmAtlasSurface</a>.
</div>
</div><p>
<a class="anchor" name="2e67742e4600f675b6a1b531113051ad"></a><!-- doxytag: member="Surface::mergeFields" ref="2e67742e4600f675b6a1b531113051ad" args="(Surface *other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::mergeFields           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_surface.html">Surface</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
merges all Fields from the other surface to the fields of this surface. 
<p>
returns true if all the fields could be merged. 
</div>
</div><p>
<a class="anchor" name="161f480505f127341d25ad8deda7f433"></a><!-- doxytag: member="Surface::simplify34" ref="161f480505f127341d25ad8deda7f433" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::simplify34           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simplify almost planar 3-star and 4-star configurations. 
<p>
The number of removed triangles is returned. Removed triangles are not actually deleted but only marked as obsolete. 
</div>
</div><p>
<a class="anchor" name="01b8c79b4aa368599bb1ab8271c4a4fb"></a><!-- doxytag: member="Surface::cleanup" ref="01b8c79b4aa368599bb1ab8271c4a4fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::cleanup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discards the contour information. 
<p>
This method should be called after the surface topology has been changed. 
</div>
</div><p>
<a class="anchor" name="5422d2b1efb8c6e567e33dd80512178c"></a><!-- doxytag: member="Surface::getBoundingBox" ref="5422d2b1efb8c6e567e33dd80512178c" args="(float box[6]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::getBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>box</em>[6]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns bounding box of point coordinates. 
<p>

<p>
Reimplemented in <a class="el" href="class_hx_surface.html#d10f58c9946494f92b98e9a549665fd4">HxSurface</a>.
</div>
</div><p>
<a class="anchor" name="7f27512e036679a2f39e79d3b395394f"></a><!-- doxytag: member="Surface::getCenter" ref="7f27512e036679a2f39e79d3b395394f" args="(float center[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::getCenter           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>center</em>[3]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns center of the surface (= average of all point coordinates). 
<p>

</div>
</div><p>
<a class="anchor" name="7c3d69fb71ccfb50aa79cb02c819107c"></a><!-- doxytag: member="Surface::setCenter" ref="7c3d69fb71ccfb50aa79cb02c819107c" args="(const float center[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::setCenter           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>center</em>[3]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modifies the coordinates of the surface points. 
<p>

</div>
</div><p>
<a class="anchor" name="23855cbd11e932b3ceea95ddf2b40956"></a><!-- doxytag: member="Surface::add" ref="23855cbd11e932b3ceea95ddf2b40956" args="(const Surface *other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::add           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_surface.html">Surface</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies points, triangles, and patches from other surface into this. 
<p>

</div>
</div><p>
<a class="anchor" name="b62d0106ff903d92056cc66cddd9406c"></a><!-- doxytag: member="Surface::read" ref="b62d0106ff903d92056cc66cddd9406c" args="(const char *, ProgressSenderIface *progress=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::read           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_progress_sender_iface.html">ProgressSenderIface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the surface from a file. 
<p>

</div>
</div><p>
<a class="anchor" name="b43c41d514de122e148eb8ecfb61755b"></a><!-- doxytag: member="Surface::readSurfaceData" ref="b43c41d514de122e148eb8ecfb61755b" args="(const char *file, FILE *in, int ascii, McDArray&lt; SurfaceData * &gt; &amp;additionalData, ProgressSenderIface *progress=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::readSurfaceData           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="struct_surface_data.html">SurfaceData</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>additionalData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_progress_sender_iface.html">ProgressSenderIface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read surface information except header. 
<p>

</div>
</div><p>
<a class="anchor" name="fa987233e11ede208695ddc953c5dd49"></a><!-- doxytag: member="Surface::readPLY" ref="fa987233e11ede208695ddc953c5dd49" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::readPLY           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the surface from a file. 
<p>

</div>
</div><p>
<a class="anchor" name="54c537fb18b4de58062bbd756f318d1d"></a><!-- doxytag: member="Surface::read" ref="54c537fb18b4de58062bbd756f318d1d" args="(const char *, McDArray&lt; SurfaceData * &gt; &amp;additionalData, ProgressSenderIface *progress=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::read           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="struct_surface_data.html">SurfaceData</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>additionalData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_progress_sender_iface.html">ProgressSenderIface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alternative read method which also return optional surface data. 
<p>

</div>
</div><p>
<a class="anchor" name="d13cc22625686a8dbff26636674561ce"></a><!-- doxytag: member="Surface::write" ref="d13cc22625686a8dbff26636674561ce" args="(const char *file, int ascii=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::write           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ascii</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write surface + header to a file. 
<p>

</div>
</div><p>
<a class="anchor" name="e9c3c41c823ad92b91e6732c5567466e"></a><!-- doxytag: member="Surface::writeSurfaceData" ref="e9c3c41c823ad92b91e6732c5567466e" args="(FILE *out, int ascii=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::writeSurfaceData           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ascii</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the surface without header to file. 
<p>

</div>
</div><p>
<a class="anchor" name="4b9adc35933e35ab31d4ba5a47a8c2d5"></a><!-- doxytag: member="Surface::checkConsistency" ref="4b9adc35933e35ab31d4ba5a47a8c2d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::checkConsistency           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a consistency check (not very sophisticated up to now). 
<p>

</div>
</div><p>
<a class="anchor" name="96d2b173186aa8ae2fe71da6537daa58"></a><!-- doxytag: member="Surface::checkIndices" ref="96d2b173186aa8ae2fe71da6537daa58" args="(bool fixInvalidIndices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::checkIndices           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fixInvalidIndices</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if indices are valid or if they are out-of-range. 
<p>

</div>
</div><p>
<a class="anchor" name="505c60413854138e87441d7fbdb8b7a6"></a><!-- doxytag: member="Surface::computeNormalsPerTriangle" ref="505c60413854138e87441d7fbdb8b7a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::computeNormalsPerTriangle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="26dc6d78941fa812670dfe435c023bbc"></a><!-- doxytag: member="Surface::computeNormalsPerVertexIndexed" ref="26dc6d78941fa812670dfe435c023bbc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::computeNormalsPerVertexIndexed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f580a9c7bd77ea8fc722f8c44c7930be"></a><!-- doxytag: member="Surface::computeNormalsPerVertex" ref="f580a9c7bd77ea8fc722f8c44c7930be" args="(float creaseAngle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::computeNormalsPerVertex           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>creaseAngle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0d065b980ca740fffd6c30c9b813a8c0"></a><!-- doxytag: member="Surface::refine" ref="0d065b980ca740fffd6c30c9b813a8c0" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::refine           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Refine surface. 
<p>
If mode==0, every edge is divided in two and each triangle into 4. If mode==1 an inner point is inserted into each triangle, dividing it into 3 triangles. 
</div>
</div><p>
<a class="anchor" name="a8ca829da523a5b0d71f2f6691685032"></a><!-- doxytag: member="Surface::refineSubdivideEdges" ref="a8ca829da523a5b0d71f2f6691685032" args="(const float maxEdgeLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::refineSubdivideEdges           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>maxEdgeLength</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function subdivides the surface edges until all edges are shorter than <code>maxEdgeLength</code>. 
<p>
The edges are taken in the order defined by the edge lengths, that is, the algorithm will always take the longest currently existing edge. 
</div>
</div><p>
<a class="anchor" name="29f9279729f26047bbac5d8a69686836"></a><!-- doxytag: member="Surface::fixOrientation" ref="29f9279729f26047bbac5d8a69686836" args="(int patch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::fixOrientation           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>patch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes orientation of triangles in patch consistent, by inverting some if necessary. 
<p>
You have to call <code>createConnectivity</code> before. <dl compact><dt><b>Returns:</b></dt><dd>Number of inverted triangles </dd></dl>

</div>
</div><p>
<a class="anchor" name="73cfb57927eb6f33f65af9ddeff3fd18"></a><!-- doxytag: member="Surface::invertTriangles" ref="73cfb57927eb6f33f65af9ddeff3fd18" args="(int patch=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::invertTriangles           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>patch</em> = <code>-1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invert the triangles of patch <code>patch</code> or all triangles, if patch==-1. 
<p>

</div>
</div><p>
<a class="anchor" name="7361411368323c74790874c7afc23b51"></a><!-- doxytag: member="Surface::isClosedSegment" ref="7361411368323c74790874c7afc23b51" args="(int patch, int segment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::isClosedSegment           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>segment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="775f83d307d2f7b38218014fca3ea31a"></a><!-- doxytag: member="Surface::computeTrianglesPerPoint" ref="775f83d307d2f7b38218014fca3ea31a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::computeTrianglesPerPoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the array <code>trianglePerPoint</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="7580f3ef1cf376029ec707c1561fc53e"></a><!-- doxytag: member="Surface::createAllEdges" ref="7580f3ef1cf376029ec707c1561fc53e" args="(int createEdgeIds=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::createAllEdges           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>createEdgeIds</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the <code>edges</code>, the <code>edgesPerPoint</code> and optionally the <code>edgesPerTriangle</code> arrays. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>createEdgeIds</em>&nbsp;</td><td>if set, the <code>edgesPerTriangle</code> array is filled, otherwise the <code>edgesPerTriangle</code> array is resized to zero </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c026a37c7377d4791c5346e439630b65"></a><!-- doxytag: member="Surface::createConnectivity" ref="c026a37c7377d4791c5346e439630b65" args="(int patch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::createConnectivity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>patch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the neighbour array for each triangle in patch. 
<p>
This method needs the arrays <code>edges</code> and <code>edgesPerPoint</code>, which can be generated by calling <code><a class="el" href="class_surface.html#7580f3ef1cf376029ec707c1561fc53e">createAllEdges()</a></code>. If not all triangles in this patch are connected, the unconnected ones are put into a new patch. <code><a class="el" href="class_surface.html#1b747a697673778f9c037439b29c5702">createConnectivity()</a></code> for this new patch is called automatically. 
</div>
</div><p>
<a class="anchor" name="1b747a697673778f9c037439b29c5702"></a><!-- doxytag: member="Surface::createConnectivity" ref="1b747a697673778f9c037439b29c5702" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::createConnectivity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the neighbour array for all triangles. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="class_surface.html#c026a37c7377d4791c5346e439630b65">createConnectivity</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3238ccad51ab06689b86f99a72677912"></a><!-- doxytag: member="Surface::createNeighbours" ref="3238ccad51ab06689b86f99a72677912" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::createNeighbours           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the neighbour array for all triangles without decomposing patches. 
<p>

</div>
</div><p>
<a class="anchor" name="a193fc3a33c9a6903970cf99d9c05561"></a><!-- doxytag: member="Surface::findBranchingPoints" ref="a193fc3a33c9a6903970cf99d9c05561" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::findBranchingPoints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This methods initializes the <code>type</code> field in all point-structures with the correct value. 
<p>
This method relies on the arrays <code>edges</code> and <code>edgesPerPoint</code>, which can be generated by calling <code><a class="el" href="class_surface.html#7580f3ef1cf376029ec707c1561fc53e">createAllEdges()</a></code>. 
</div>
</div><p>
<a class="anchor" name="9c9672bd0d4f2a1b0a51e988a942e221"></a><!-- doxytag: member="Surface::clearInnerEdges" ref="9c9672bd0d4f2a1b0a51e988a942e221" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::clearInnerEdges           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes edges, that are not part of a contour. 
<p>
After doing this, this method calls <code>renumberPoints</code>. This method was kept for backward compatibility. 
</div>
</div><p>
<a class="anchor" name="3a0cbf17e4fe269adc04a69362cb7333"></a><!-- doxytag: member="Surface::clearInnerEdges" ref="3a0cbf17e4fe269adc04a69362cb7333" args="(int renumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::clearInnerEdges           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>renumber</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes edges, that are not part of a contour. 
<p>
After doing this, this method calls <code>renumberPoints</code>, only if <code>renumber</code> is set to one. 
</div>
</div><p>
<a class="anchor" name="a168d01760ea839f45c587645c71ff9b"></a><!-- doxytag: member="Surface::findContours" ref="a168d01760ea839f45c587645c71ff9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::findContours           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find contours, by tracing edges. 
<p>
This method relies on the arrays <code>edges</code> and <code>edgesPerPoint</code>, which can be generated by calling <code><a class="el" href="class_surface.html#7580f3ef1cf376029ec707c1561fc53e">createAllEdges()</a></code>. Also the <code>PointType</code> array must be initialized properly, which can be done by <code><a class="el" href="class_surface.html#a193fc3a33c9a6903970cf99d9c05561">findBranchingPoints()</a></code>. 
</div>
</div><p>
<a class="anchor" name="a4c5868ebdc4dbade7aee2f067de6b2e"></a><!-- doxytag: member="Surface::renumberPoints" ref="a4c5868ebdc4dbade7aee2f067de6b2e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::renumberPoints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method shuffels the points in such a way, that they are sorted according to their type in the following way: BRANCHING-points, CONTOUR-Points, INNER-Points. 
<p>
Points marked as UNUSED are deleted. The indices in the triangles edges and contours are modified accordingly. If the <code>edgesPerPoint</code> array is present, the <code>edgesPerPoint</code> lists are interchanged in a consistent way. As a side effect, the variables <code>nBranchingPoints</code> and <code>nContourPoints</code> are set. 
</div>
</div><p>
<a class="anchor" name="f6be792b29f5ee7eb66d63caafed60b2"></a><!-- doxytag: member="Surface::deleteDeadEnds" ref="f6be792b29f5ee7eb66d63caafed60b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::deleteDeadEnds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="234d32b7cd8199e6345fbf9cfff9d6ce"></a><!-- doxytag: member="Surface::sortContoursOfPatch" ref="234d32b7cd8199e6345fbf9cfff9d6ce" args="(int p, int fixDeadEnds=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::sortContoursOfPatch           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fixDeadEnds</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sort the contours so that they form one (or more) closed path. 
<p>
The indices pointing to the contours may become negative... <dl compact><dt><b>Returns:</b></dt><dd>The number of closed paths. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c84a4e9a520764ebc6f0c7048cdf07f"></a><!-- doxytag: member="Surface::sortContoursOfPatches" ref="5c84a4e9a520764ebc6f0c7048cdf07f" args="(int fixDeadEnds=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::sortContoursOfPatches           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fixDeadEnds</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls sortContoursOfPatch for all patches. 
<p>

</div>
</div><p>
<a class="anchor" name="52d540a614912f8680f76e50c5052dca"></a><!-- doxytag: member="Surface::sortTriangles" ref="52d540a614912f8680f76e50c5052dca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::sortTriangles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sort triangle list according to patch order 
<p>

</div>
</div><p>
<a class="anchor" name="c40c1cfa21ac4374464b47410ae22cc5"></a><!-- doxytag: member="Surface::findBranchingPointsOfPatches" ref="c40c1cfa21ac4374464b47410ae22cc5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::findBranchingPointsOfPatches           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3d7954c8a813d7b8aa6d445b48a3ec6c"></a><!-- doxytag: member="Surface::computeOrientationOfContours" ref="3d7954c8a813d7b8aa6d445b48a3ec6c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::computeOrientationOfContours           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c39ec1019c98a0ca4443978331bea864"></a><!-- doxytag: member="Surface::tile" ref="c39ec1019c98a0ca4443978331bea864" args="(const McDArray&lt; int &gt; &amp;pidx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::tile           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pidx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute a triangulation for the polygon, consisting of the vertices v[]. 
<p>
Insert triangles into surfaces' triangle list. <dl compact><dt><b>Returns:</b></dt><dd>number of new triangles. This should be <code>v.size()-2</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="06bdbbbf169843943ec8c290ff78d166"></a><!-- doxytag: member="Surface::tileCenter" ref="06bdbbbf169843943ec8c290ff78d166" args="(const McDArray&lt; int &gt; &amp;pidx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::tileCenter           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pidx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c92ab7d4071ecf0d76a923672e3143f0"></a><!-- doxytag: member="Surface::tileFan" ref="c92ab7d4071ecf0d76a923672e3143f0" args="(const McDArray&lt; int &gt; &amp;pidx, int anchor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::tileFan           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>anchor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="20456278ade3aa0fe468ec64b62f6a6b"></a><!-- doxytag: member="Surface::fitPlane" ref="20456278ade3aa0fe468ec64b62f6a6b" args="(const McDArray&lt; int &gt; &amp;pidx, float plane[4])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::fitPlane           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>plane</em>[4]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute best fitting plane for a polygon usign Newells method. 
<p>

</div>
</div><p>
<a class="anchor" name="f77835c316a801e0d8c1461b9310024b"></a><!-- doxytag: member="Surface::getMaterialID" ref="f77835c316a801e0d8c1461b9310024b" args="(const char *mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getMaterialID           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mat</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns -1 if material is not found. 
<p>

</div>
</div><p>
<a class="anchor" name="2d29f8c01489442d7dd4961bf0b98f58"></a><!-- doxytag: member="Surface::addMaterial" ref="2d29f8c01489442d7dd4961bf0b98f58" args="(const char *name, int id=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::addMaterial           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="84c35d1cf6a79ccaf30ab25586bddec0"></a><!-- doxytag: member="Surface::setBoundaryIDInfo" ref="84c35d1cf6a79ccaf30ab25586bddec0" args="(int id, const char *typeStr=0, const char *info=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::setBoundaryIDInfo           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>typeStr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>info</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets boundary information for the given id into the object's parameter bundle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>typeStr</em>&nbsp;</td><td>type of boundary, optional. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Additional info string, optional. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0b14dfa2f9e6a2614a229834b2eb9602"></a><!-- doxytag: member="Surface::removePoint" ref="0b14dfa2f9e6a2614a229834b2eb9602" args="(int patch, int point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::removePoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bba65568a94b23f662df3ceeb0463d06"></a><!-- doxytag: member="Surface::removeDuplicateTriangles" ref="bba65568a94b23f662df3ceeb0463d06" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::removeDuplicateTriangles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove triangles containing the same three points. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Number of removed triangles. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c2333005a48d6a5ea82258f8acd0ee8"></a><!-- doxytag: member="Surface::removeDegenerateTriangles" ref="1c2333005a48d6a5ea82258f8acd0ee8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::removeDegenerateTriangles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove triangles with two or three identical points. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Number of removed triangles. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cfe84d177e90528a8a5650775353cabe"></a><!-- doxytag: member="Surface::isInnerPoint" ref="cfe84d177e90528a8a5650775353cabe" args="(int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::isInnerPoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="58f22f84cbd097de7028e2dae38f5b04"></a><!-- doxytag: member="Surface::contourFromPoint" ref="58f22f84cbd097de7028e2dae38f5b04" args="(oint contourIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::contourFromPoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoint.html">oint</a>&nbsp;</td>
          <td class="paramname"> <em>contourIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get first point of contour indexed by <code>contourIdx</code>. 
<p>
<code>contourIdx</code> is an oint. If it is negatively oriented, the last point of the contour is returned instead. 
</div>
</div><p>
<a class="anchor" name="c508b72577c3d5dbb28d7a69a81f7c93"></a><!-- doxytag: member="Surface::contourToPoint" ref="c508b72577c3d5dbb28d7a69a81f7c93" args="(oint contourIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::contourToPoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoint.html">oint</a>&nbsp;</td>
          <td class="paramname"> <em>contourIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get last point of contour indexed by <code>contourIdx</code>. 
<p>
<code>contourIdx</code> is an oint. If it is negatively oriented, the first point of the contour is returned instead. 
</div>
</div><p>
<a class="anchor" name="177f444ba6ae5fb8b87e591dc225127a"></a><!-- doxytag: member="Surface::getEdgeOfTriangle" ref="177f444ba6ae5fb8b87e591dc225127a" args="(int triangleIdx, int which)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getEdgeOfTriangle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>triangleIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="135ff481c37f92a47be9de61dbc2daea"></a><!-- doxytag: member="Surface::getNeighbourTriangle" ref="135ff481c37f92a47be9de61dbc2daea" args="(int triangleIdx, int which, int global=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getNeighbourTriangle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>triangleIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>global</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="12195a8ad4886982e8087c34893eb860"></a><!-- doxytag: member="Surface::getNextNeighbourTriangle" ref="12195a8ad4886982e8087c34893eb860" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getNextNeighbourTriangle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a231f185c05f30338cdc70ef94134d1d"></a><!-- doxytag: member="Surface::operator==" ref="a231f185c05f30338cdc70ef94134d1d" args="(const Surface &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_surface.html">Surface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="88e654aab5d39c824fd1bfd693bb394e"></a><!-- doxytag: member="Surface::print" ref="88e654aab5d39c824fd1bfd693bb394e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Surface::print           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9de6529690133fd8b4036686a9f57e3e"></a><!-- doxytag: member="Surface::copyData" ref="9de6529690133fd8b4036686a9f57e3e" args="(const Surface &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::copyData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_surface.html">Surface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the whole data set. 
<p>

</div>
</div><p>
<a class="anchor" name="146b3a3a45a45c3582b0a264d0ba3da0"></a><!-- doxytag: member="Surface::appendTriangle" ref="146b3a3a45a45c3582b0a264d0ba3da0" args="(int patchIdx, Triangle &amp;triangle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::appendTriangle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>patchIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_surface_1_1_triangle.html">Triangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>triangle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends a triangle and inserts it in given patch. 
<p>

</div>
</div><p>
<a class="anchor" name="3ef357a7fe4ef6aa71271006a4e31088"></a><!-- doxytag: member="Surface::checkClosedness" ref="3ef357a7fe4ef6aa71271006a4e31088" args="(McDArray&lt; int &gt; &amp;patchOrientations, McDArray&lt; int &gt; &amp;triangleList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::checkClosedness           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>patchOrientations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>triangleList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check surface closedness. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 for closed surface, 1 for non-closed surface, 2 for inconsistent triangle orientation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2f8f7dfcf4dfa757bcbaa53df94c356"></a><!-- doxytag: member="Surface::intersectionTest" ref="b2f8f7dfcf4dfa757bcbaa53df94c356" args="(int t, McDArray&lt; int &gt; &amp;neighbours, float eps, int selectNeighbours=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::intersectionTest           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>selectNeighbours</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check intersection of triangle t with its neighbours. 
<p>

</div>
</div><p>
<a class="anchor" name="32103d1c97b9ae267dc945f4c57ce617"></a><!-- doxytag: member="Surface::classifyEdges" ref="32103d1c97b9ae267dc945f4c57ce617" args="(int iRegion, int &amp;nOdd, int &amp;nEdge0, int &amp;nEdge2, int &amp;nEdge4, McDArray&lt; signed char &gt; &amp;markEdges, McDArray&lt; int &gt; &amp;triangleList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::classifyEdges           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>nOdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>nEdge0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>nEdge2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>nEdge4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>triangleList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine number of triangles of region adjacent to each edge. 
<p>

</div>
</div><p>
<a class="anchor" name="b5b7a7412be8d7233a7d09589897b086"></a><!-- doxytag: member="Surface::createTriangleGroups" ref="b5b7a7412be8d7233a7d09589897b086" args="(const int iRegion, McDArray&lt; signed char &gt; &amp;markEdges, McDArray&lt; short &gt; &amp;markTriangles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::createTriangleGroups           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>iRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markTriangles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create groups of connected triangles. 
<p>

</div>
</div><p>
<a class="anchor" name="c7d8e4a1d113fdcfa6b3f1a88bd08934"></a><!-- doxytag: member="Surface::findInconsistentEdges" ref="c7d8e4a1d113fdcfa6b3f1a88bd08934" args="(const int iRegion, McDArray&lt; signed char &gt; &amp;markEdges, McDArray&lt; short &gt; &amp;markTriangles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::findInconsistentEdges           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>iRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markTriangles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find inconsistent edges. 
<p>

</div>
</div><p>
<a class="anchor" name="fd5ea65c56da121da49d5b49b881944d"></a><!-- doxytag: member="Surface::createClosedSurfaces" ref="fd5ea65c56da121da49d5b49b881944d" args="(const int iRegion, int nGroups, McDArray&lt; signed char &gt; &amp;markEdges, McDArray&lt; short &gt; &amp;markTriangles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::createClosedSurfaces           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>iRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markTriangles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create closed surfaces. 
<p>

</div>
</div><p>
<a class="anchor" name="dc4c38170a370424db1d4c50cf3e91b2"></a><!-- doxytag: member="Surface::calcEnclosedVolumes" ref="dc4c38170a370424db1d4c50cf3e91b2" args="(const int iRegion, McDArray&lt; short &gt; &amp;markTriangles, McDArray&lt; float &gt; &amp;enclosedVolumes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::calcEnclosedVolumes           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>iRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markTriangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>enclosedVolumes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate volumes enclosed by surfaces. 
<p>

</div>
</div><p>
<a class="anchor" name="ba932462c35cb4a28ac80827f559e47e"></a><!-- doxytag: member="Surface::checkEnclosedVolumes" ref="ba932462c35cb4a28ac80827f559e47e" args="(McDArray&lt; float &gt; &amp;enclosedVolumes, McDArray&lt; signed char &gt; &amp;inclusionInfo, McDArray&lt; short &gt; &amp;markTriangles, int insideOut, int &amp;groupsOf4, McDArray&lt; int &gt; &amp;triangleList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::checkEnclosedVolumes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>enclosedVolumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; signed char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>inclusionInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>markTriangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>insideOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>groupsOf4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>triangleList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check enclosed volumes. 
<p>

</div>
</div><p>
<a class="anchor" name="c06ab1b90a88a9de37a350f62e724dc0"></a><!-- doxytag: member="Surface::calcMinMaxMeanEdgeLen" ref="c06ab1b90a88a9de37a350f62e724dc0" args="(float *min, float *max, float *mean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::calcMinMaxMeanEdgeLen           </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>mean</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate minimal, maximal and mean edge length. 
<p>

</div>
</div><p>
<a class="anchor" name="d60b1762e248775cd352f39526bc3ffc"></a><!-- doxytag: member="Surface::calcEdgeLengths" ref="d60b1762e248775cd352f39526bc3ffc" args="(McDArray&lt; float &gt; &amp;lengths)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::calcEdgeLengths           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lengths</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute edge lengths. 
<p>

</div>
</div><p>
<a class="anchor" name="60e4ffaedca452c6e5ec0cf3c3ef8aea"></a><!-- doxytag: member="Surface::getEdgeCurvature" ref="60e4ffaedca452c6e5ec0cf3c3ef8aea" args="(int edge)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Surface::getEdgeCurvature           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>edge</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns value for (signed) curvature at edge: 0=planar, +1=maximally convex, -1=maximally concave. 
<p>

</div>
</div><p>
<a class="anchor" name="368ce06bcf54deb49b9d5ff28ae3ed03"></a><!-- doxytag: member="Surface::getTriangleArea" ref="368ce06bcf54deb49b9d5ff28ae3ed03" args="(int triangle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Surface::getTriangleArea           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>triangle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns area of triangle. 
<p>

</div>
</div><p>
<a class="anchor" name="2274fa62f1bff35eb1981aeaca8f72a3"></a><!-- doxytag: member="Surface::getTriangleNormal" ref="2274fa62f1bff35eb1981aeaca8f72a3" args="(int triangle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_vec3f.html">McVec3f</a> Surface::getTriangleNormal           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>triangle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns normal at triangle. 
<p>

</div>
</div><p>
<a class="anchor" name="f6ae65f823363690f1705759ae562e16"></a><!-- doxytag: member="Surface::getVertexNormal" ref="f6ae65f823363690f1705759ae562e16" args="(int vertex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_vec3f.html">McVec3f</a> Surface::getVertexNormal           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns normal at triangle. 
<p>

</div>
</div><p>
<a class="anchor" name="bd629d6dfd32a9757948ad128f634bb6"></a><!-- doxytag: member="Surface::getPatchArea" ref="bd629d6dfd32a9757948ad128f634bb6" args="(int patch) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Surface::getPatchArea           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>patch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get surface area of given patch. 
<p>

</div>
</div><p>
<a class="anchor" name="d656c52f6516f3a0adc17c8fc36f32d5"></a><!-- doxytag: member="Surface::makeOnePatch" ref="d656c52f6516f3a0adc17c8fc36f32d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::makeOnePatch           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make one patch. 
<p>

</div>
</div><p>
<a class="anchor" name="2ff3ce636d1a2b522b54000c276f68f2"></a><!-- doxytag: member="Surface::getEdgeIdx" ref="2ff3ce636d1a2b522b54000c276f68f2" args="(int v1, int v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getEdgeIdx           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute index of edge between given vertices. 
<p>

</div>
</div><p>
<a class="anchor" name="65ba9765313704b76f4d4fa81cdff98d"></a><!-- doxytag: member="Surface::getTriangleIdx" ref="65ba9765313704b76f4d4fa81cdff98d" args="(int v1, int v2, int v3) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getTriangleIdx           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute index of triangle with given vertices. 
<p>

</div>
</div><p>
<a class="anchor" name="6890c114fea0c9e1c0e462174cdb2ca3"></a><!-- doxytag: member="Surface::get3rdPoint" ref="6890c114fea0c9e1c0e462174cdb2ca3" args="(int v1, int v2, int triIdx, int &amp;orient) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::get3rdPoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>triIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>orient</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a triangle index and two nodes, compute 3rd node number. 
<p>

</div>
</div><p>
<a class="anchor" name="da5a6dec569ab548b2d3c42d6a550fb6"></a><!-- doxytag: member="Surface::getTrianglesAlongPath" ref="da5a6dec569ab548b2d3c42d6a550fb6" args="(const McBitfield &amp;isPathEdge, const McBitfield &amp;considerTriangle, int orient, int v1, int v2, McDArray&lt; int &gt; &amp;nodes, McDArray&lt; int &gt; &amp;tris)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getTrianglesAlongPath           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>isPathEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>considerTriangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>orient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tris</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute triangles along border around node v1 inside given patch. 
<p>
Start from edge (v1,v2). Return neighboured nodes and triangles. (orient==1 is clockwise, -1 is anticlockwise) 
</div>
</div><p>
<a class="anchor" name="bf93b28dd475980af21eb590bc5e8794"></a><!-- doxytag: member="Surface::getNeighsPerPoint" ref="bf93b28dd475980af21eb590bc5e8794" args="(int node, McSmallArray&lt; int, 6 &gt; &amp;neighs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::getNeighsPerPoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 6 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>neighs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute neighboured points around given points (sorted anti-clockwise if possible). 
<p>

</div>
</div><p>
<a class="anchor" name="9e28b2ded806bd1514831364dc718b4c"></a><!-- doxytag: member="Surface::getNeighsPerPointWithMaterial" ref="9e28b2ded806bd1514831364dc718b4c" args="(int node, McSmallArray&lt; int, 6 &gt; &amp;neighs, int materialId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::getNeighsPerPointWithMaterial           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 6 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>neighs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>materialId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute neighboured points around given points (sorted anti-clockwise if possible). 
<p>
Only consider neighs which triangles have the materialId as innerRegion 
</div>
</div><p>
<a class="anchor" name="2f1e9cd3f16275d92f976e025721587a"></a><!-- doxytag: member="Surface::getNeighsPerPoint" ref="2f1e9cd3f16275d92f976e025721587a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::getNeighsPerPoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute neighboured nodes at all vertices (only needs trianglePerPoint data). 
<p>

</div>
</div><p>
<a class="anchor" name="8301ef62c57a31c78dd3ae45095fb2c5"></a><!-- doxytag: member="Surface::setPathEdges" ref="8301ef62c57a31c78dd3ae45095fb2c5" args="(const McDArray&lt; int &gt; &amp;nodes, McBitfield &amp;isPathEdge)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::setPathEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>isPathEdge</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine indices of edges that connect given nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="66f76ecb40e2a190fb5d9ade6fb5b809"></a><!-- doxytag: member="Surface::unsetPathEdges" ref="66f76ecb40e2a190fb5d9ade6fb5b809" args="(const McDArray&lt; int &gt; &amp;nodes, McBitfield &amp;isPathEdge)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::unsetPathEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>isPathEdge</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset edges that connect given nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="3879dc0182a58f0e2322d9a78d1a2222"></a><!-- doxytag: member="Surface::getEnclosedTriangles" ref="3879dc0182a58f0e2322d9a78d1a2222" args="(int first, const McBitfield &amp;isPathEdge, McDArray&lt; int &gt; &amp;enclosed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::getEnclosedTriangles           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>isPathEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>enclosed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get triangles enclosed by given edges. 
<p>

</div>
</div><p>
<a class="anchor" name="b34442f875881c5ed869f3344bcacc0d"></a><!-- doxytag: member="Surface::isClosedLoop" ref="b34442f875881c5ed869f3344bcacc0d" args="(const McDArray&lt; McDArray&lt; int &gt; &gt; &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::isClosedLoop           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if array of vertices form a closed loop on the surface. 
<p>

</div>
</div><p>
<a class="anchor" name="0cc35d77dc775787d34aaea36ca07811"></a><!-- doxytag: member="Surface::getPathLength" ref="0cc35d77dc775787d34aaea36ca07811" args="(const McDArray&lt; int &gt; &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Surface::getPathLength           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute length of edge path on surface. 
<p>

</div>
</div><p>
<a class="anchor" name="8efd9c3414a9d4f2a393c910c3633753"></a><!-- doxytag: member="Surface::getPathLength" ref="8efd9c3414a9d4f2a393c910c3633753" args="(const McDArray&lt; int &gt; &amp;path, McDArray&lt; float &gt; &amp;lengths)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Surface::getPathLength           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lengths</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute length of edge path (and for each edge) on surface. 
<p>

</div>
</div><p>
<a class="anchor" name="316e1ea68a5e30b43bbbb08f68e2fa49"></a><!-- doxytag: member="Surface::bfs" ref="316e1ea68a5e30b43bbbb08f68e2fa49" args="(const McDArray&lt; int &gt; &amp;nodes, int depth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;int&gt; Surface::bfs           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get vertices around given points. 
<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="9750fccc7a29f548233d65380cd8e0e9"></a><!-- doxytag: member="Surface::nBranchingPoints" ref="9750fccc7a29f548233d65380cd8e0e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_surface.html#9750fccc7a29f548233d65380cd8e0e9">Surface::nBranchingPoints</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Branching points have indices [0...nBranchingPoints-1]. 
<p>

</div>
</div><p>
<a class="anchor" name="bf920fa856b1a4dcda4bae15a61d6c98"></a><!-- doxytag: member="Surface::nContourPoints" ref="bf920fa856b1a4dcda4bae15a61d6c98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_surface.html#bf920fa856b1a4dcda4bae15a61d6c98">Surface::nContourPoints</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="class_surface_1_1_contour.html">Contour</a> points start with index <code>nBranchingPoints</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="177557af73f7a8dcbed7a3a553ee3b1f"></a><!-- doxytag: member="Surface::points" ref="177557af73f7a8dcbed7a3a553ee3b1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_mc_vec3f.html">McVec3f</a>&gt; <a class="el" href="class_surface.html#177557af73f7a8dcbed7a3a553ee3b1f">Surface::points</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of all surface points (required). 
<p>

</div>
</div><p>
<a class="anchor" name="830f372ae6cb1e8b5d4194c46f3e0c8e"></a><!-- doxytag: member="Surface::pointType" ref="830f372ae6cb1e8b5d4194c46f3e0c8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;unsigned char&gt; <a class="el" href="class_surface.html#830f372ae6cb1e8b5d4194c46f3e0c8e">Surface::pointType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of point types (full surface only). 
<p>

</div>
</div><p>
<a class="anchor" name="45d9e4539ab013c31e4a2e6dbfc2cdf4"></a><!-- doxytag: member="Surface::contours" ref="45d9e4539ab013c31e4a2e6dbfc2cdf4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_surface_1_1_contour.html">Contour</a>*&gt; <a class="el" href="class_surface.html#45d9e4539ab013c31e4a2e6dbfc2cdf4">Surface::contours</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of all surface contours (full surface only). 
<p>

</div>
</div><p>
<a class="anchor" name="434fa639568ba777148f9b86371c1392"></a><!-- doxytag: member="Surface::patches" ref="434fa639568ba777148f9b86371c1392" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_surface_1_1_patch.html">Patch</a>*&gt; <a class="el" href="class_surface.html#434fa639568ba777148f9b86371c1392">Surface::patches</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of all surface patches (at least 1 patch is required). 
<p>

</div>
</div><p>
<a class="anchor" name="b03717d5b8e2aef2e376e9dfcfbe637d"></a><!-- doxytag: member="Surface::triangles" ref="b03717d5b8e2aef2e376e9dfcfbe637d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_surface_1_1_triangle.html">Triangle</a>&gt; <a class="el" href="class_surface.html#b03717d5b8e2aef2e376e9dfcfbe637d">Surface::triangles</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of all surface triangles (required). 
<p>

</div>
</div><p>
<a class="anchor" name="f93e6d26052712a83e7509210268c2c8"></a><!-- doxytag: member="Surface::edges" ref="f93e6d26052712a83e7509210268c2c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_surface_1_1_edge.html">Edge</a>&gt; <a class="el" href="class_surface.html#f93e6d26052712a83e7509210268c2c8">Surface::edges</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All edges of the surface (temporary data). 
<p>

</div>
</div><p>
<a class="anchor" name="e127e6f419621318cb77ca0292adaa9b"></a><!-- doxytag: member="Surface::edgesPerPoint" ref="e127e6f419621318cb77ca0292adaa9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt;int,6&gt; &gt; <a class="el" href="class_surface.html#e127e6f419621318cb77ca0292adaa9b">Surface::edgesPerPoint</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores for each point all edges incident at that point (temporary). 
<p>

</div>
</div><p>
<a class="anchor" name="032aa969557bb20b854d3b08549a0381"></a><!-- doxytag: member="Surface::edgesPerTriangle" ref="032aa969557bb20b854d3b08549a0381" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_s_array.html">McSArray</a>&lt;int,3&gt; &gt; <a class="el" href="class_surface.html#032aa969557bb20b854d3b08549a0381">Surface::edgesPerTriangle</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores the edge ids for each triangle (optional and temporary). 
<p>
Edges of each triangle are ordered. The edge number of the triangle is the number of the opposite triangle vertex. 
</div>
</div><p>
<a class="anchor" name="5026feae6988155b75ae53bda9f3d536"></a><!-- doxytag: member="Surface::trianglesPerPoint" ref="5026feae6988155b75ae53bda9f3d536" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt;int,6&gt; &gt; <a class="el" href="class_surface.html#5026feae6988155b75ae53bda9f3d536">Surface::trianglesPerPoint</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores for each point all incident triangles. 
<p>
To initialize this array the method <code><a class="el" href="class_surface.html#775f83d307d2f7b38218014fca3ea31a">computeTrianglesPerPoint()</a></code> has to be called explicitely. The class <code>HxSurfaceEditor</code> uses this information. 
</div>
</div><p>
<a class="anchor" name="51e8e0068a6fcfe8470ea923106e23a5"></a><!-- doxytag: member="Surface::neighsPerPoint" ref="51e8e0068a6fcfe8470ea923106e23a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt;int,6&gt; &gt; <a class="el" href="class_surface.html#51e8e0068a6fcfe8470ea923106e23a5">Surface::neighsPerPoint</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stores for each point all neighboured points. 
<p>
To initialize this array the method <code>getPointsPerPoint()</code> has to be called. For each (orientable!) manifold point the neighbours are sorted anti-clockwise around the point. 
</div>
</div><p>
<a class="anchor" name="f3628d950a0bdb94338149be6730f13d"></a><!-- doxytag: member="Surface::params" ref="f3628d950a0bdb94338149be6730f13d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hx_param_bundle.html">HxParamBundle</a>* <a class="el" href="class_surface.html#f3628d950a0bdb94338149be6730f13d">Surface::params</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains info about the regions. 
<p>
The indices <code>innerRegion</code> and <code>outerRegion</code> refer to this structure, e.g. <code>materials</code>[0]. 
</div>
</div><p>
<a class="anchor" name="a1807c2a912f6d292503821205b089aa"></a><!-- doxytag: member="Surface::normals" ref="a1807c2a912f6d292503821205b089aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_mc_vec3f.html">McVec3f</a>&gt; <a class="el" href="class_surface.html#a1807c2a912f6d292503821205b089aa">Surface::normals</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="119e5da77e8cc0c46a9487ce368e0750"></a><!-- doxytag: member="Surface::normalBinding" ref="119e5da77e8cc0c46a9487ce368e0750" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface.html#44deeaf75187a279d6e5ab261cbc531e">NormalBinding</a> <a class="el" href="class_surface.html#119e5da77e8cc0c46a9487ce368e0750">Surface::normalBinding</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4e35934832f379095e87f703b326dfdf"></a><!-- doxytag: member="Surface::lod" ref="4e35934832f379095e87f703b326dfdf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface_l_o_d.html">SurfaceLOD</a>* <a class="el" href="class_surface.html#4e35934832f379095e87f703b326dfdf">Surface::lod</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to surface level-of-detail. 
<p>

</div>
</div><p>
<a class="anchor" name="4eb428301e39f323a56812dbed520ad3"></a><!-- doxytag: member="Surface::debug" ref="4eb428301e39f323a56812dbed520ad3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_surface.html#4eb428301e39f323a56812dbed520ad3">Surface::debug</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>hxsurface/<a class="el" href="_surface_8h.html">Surface.h</a></ul>
<hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
