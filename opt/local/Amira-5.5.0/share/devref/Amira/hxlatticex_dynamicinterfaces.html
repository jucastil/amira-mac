<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: Object Interface Separation in amira</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1><a class="anchor" name="hxlatticex_DynamicInterfaces">Object Interface Separation in amira</a></h1><h2><a class="anchor" name="Status">
Status</a></h2>
This document is outdated. Only some parts are kept below, because they are considered still useful.<p>
The discussion is overridden by <a href="https://amira.zib.de/dev/wiki/bin/view/Amira/DraftNo001Interfaces,">https://amira.zib.de/dev/wiki/bin/view/Amira/DraftNo001Interfaces,</a> and implemented in <a class="el" href="class_mc_interface.html">McInterface</a> and <a class="el" href="class_mc_interface_owner.html">McInterfaceOwner</a>.<h2><a class="anchor" name="Introduction">
Introduction</a></h2>
The purpose of this document is describe the rationale behind the interfaces in amira. To get detailed guidelines how to desing your own interfaces you should read <a class="el" href="hxlatticex_dynamicinterfaceguidelines.html">hxlatticex_DynamicInterfaceGuidelines</a><p>
The present version of amira (3.0) lacks a clean separation of the implementation of a concept, like <a class="el" href="class_hx_field3.html">HxField3</a>, and the interface to it. I'm going to explain the problem in more detail in the next section before proposing a solution.<h2><a class="anchor" name="hxlatticex_DynamicInterfaces_sec_ThePresentSituation">
The present situation</a></h2>
As described in the developer's guide it is not obvious how to build a class hierachy for <a class="el" href="class_hx_uniform_scalar_field3.html">HxUniformScalarField3</a> and <a class="el" href="class_hx_lattice3.html">HxLattice3</a> at the same time. One way, chosen in amira, is to first split by the type of the field (scalar, vector...) and later split by the type of the coordinates.<p>
As a result, <a class="el" href="class_hx_uniform_scalar_field3.html">HxUniformScalarField3</a> and <a class="el" href="class_hx_stacked_scalar_field3.html">HxStackedScalarField3</a> are located in different branches of the class hierachy. But some modules, e.g. HxResample, can operate on them in mostly the same way. To facilitate this amira provides the <a class="el" href="class_hx_lattice3.html">HxLattice3</a> interface.<p>
Sounds good, if it is explained in this way. But how to add a Field stored on a Lattice not in main memory but in external memory (on disk). The concept of the interfaces could be mostly the same. There would be some changes, e.g. providing blocks of data instead of a pointer to the memory, but the main lines could be kept. A scalar field with uniform coordinates could provide an eval interface. But where to put it in the present hierachy. Naturally you would like to derive from <a class="el" href="class_hx_uniform_scalar_field3.html">HxUniformScalarField3</a>. But being a child of this class you not only derive the concept but also the implementation, means the internal memory implementation which you really don't want. But if you do not derive from <a class="el" href="class_hx_uniform_scalar_field3.html">HxUniformScalarField3</a>, how to tell computational modules that you are scalar with uniform coordinates - no way.<p>
So you're stuck. The present class hierachy provides no way to define a <a class="el" href="class_hx_uniform_scalar_field3.html">HxUniformScalarField3</a> not implemented in main memory. To stress it again, it's not a problem with a wrong definition of the interface. The problem is that interface and implementation are defined in the same classes.<h2><a class="anchor" name="iface2">
Ways out</a></h2>
Learn about the Adapter design pattern which I will call Interface class in the following. You might check out <a href="http://www.ddj.com/documents/s=917/ddj9808a/9808a.htm">http://www.ddj.com/documents/s=917/ddj9808a/9808a.htm</a> as a brief introduction. Details could be fount in <a href="http://hillside.net/patterns/DPBook/DPBook.html">http://hillside.net/patterns/DPBook/DPBook.html</a><p>
The key point is to declare abstract base classes defining the interfaces and putting the implementation into other classes.<p>
The most obvious choice would perhaps be to derive the implementation classes directly from multiple interface classes if your class implements more than one concept. The draw back is, besides multiple inheritance which might cause complicated cases, that the interfaces are statically, per class declared. But if you have an implementation of a external field storing a arbitrary number of data values per node you have a lot of choices. Depending on nDataVar an instance of the class could look like a <a class="el" href="class_hx_scalar_field3.html">HxScalarField3</a> or as a <a class="el" href="class_hx_vector_field3.html">HxVectorField3</a>. If you use a Adapter you can introduce the Interfaces on a per-object, not a per-class basis. You are much more flexible. You could even conceive to extend objects with interfaces during runtime. If the public methods are suitable for implementing this new concept, the class need not even know of this new interface during compiletime.<p>
This is what we want to do. In more detail, we need two hierachies, each without multiple inheritance. One hierachy is built below <a class="el" href="class_hx_interface.html">HxInterface</a> and defines the concepts of the interfaces objects could provide. The other hierachy is below <a class="el" href="class_hx_object.html">HxObject</a> (<a class="el" href="class_hx_data.html">HxData</a>, <a class="el" href="class_hx_module.html">HxModule</a>) and is used to inherit and share implementation details. E.g. you get all the object pool handling, the network save stuff by deriving from <a class="el" href="class_hx_object.html">HxObject</a>. Interfaces might also include some default implementations, but they should be reasonably stateless. Most of the time they will just pass a request to another object providing the implementation. <hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
