<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: HxSpatialData Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>HxSpatialData Class Reference<br>
<small>
[<a class="el" href="group__hxcore.html">hxcore</a>]</small>
</h1><!-- doxytag: class="HxSpatialData" --><!-- doxytag: inherits="HxData" -->Base class for all data objects that are defined in three dimensional space.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;hxcore/HxSpatialData.h&gt;</code>
<p>
<p>Inheritance diagram for HxSpatialData:
<p><center><img src="class_hx_spatial_data.png" usemap="#HxSpatialData_map" border="0" alt=""></center>
<map name="HxSpatialData_map">
<area href="class_hx_data.html" alt="HxData" shape="rect" coords="0,224,143,248">
<area href="class_hx_object.html" alt="HxObject" shape="rect" coords="0,168,143,192">
<area href="class_hx_base.html" alt="HxBase" shape="rect" coords="0,112,143,136">
<area href="class_mc_interface.html" alt="McInterface" shape="rect" coords="0,56,143,80">
<area href="class_mc_typed_object.html" alt="McTypedObject" shape="rect" coords="0,0,143,24">
<area href="class_hx_arith_l_d_m.html" alt="HxArithLDM" shape="rect" coords="153,336,296,360">
<area href="class_hx_block_structured_grid.html" alt="HxBlockStructuredGrid" shape="rect" coords="153,392,296,416">
<area href="class_hx_curve.html" alt="HxCurve" shape="rect" coords="153,448,296,472">
<area href="class_hx_field3.html" alt="HxField3" shape="rect" coords="153,504,296,528">
<area href="class_hx_iv_data.html" alt="HxIvData" shape="rect" coords="153,560,296,584">
<area href="class_hx_multi_channel_field.html" alt="HxMultiChannelField" shape="rect" coords="153,616,296,640">
<area href="class_hx_stacked_slices_lattice.html" alt="HxStackedSlicesLattice" shape="rect" coords="153,672,296,696">
<area href="class_hx_surface_field.html" alt="HxSurfaceField" shape="rect" coords="153,728,296,752">
<area href="class_hx_tetra_field_set.html" alt="HxTetraFieldSet" shape="rect" coords="153,784,296,808">
<area href="class_hx_vertex_set.html" alt="HxVertexSet" shape="rect" coords="153,840,296,864">
<area href="class_hx_voxel_field_set.html" alt="HxVoxelFieldSet" shape="rect" coords="153,896,296,920">
</map>
<a href="class_hx_spatial_data-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b013d6c4dee2e8aa4c0f6dddd99cf4cd665">RAW_DATA</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b0143c7fceb9005d99c4e641b782eb5ab71">DEFINED_RAW_DATA</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b0190c92c584b980c4e39489b7fbb2f19f9">DATA_WINDOW</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b01bbe369219f18fbd8127b78cabcf13482">HISTOGRAM_DATA</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b01">RangeType</a> { <a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b013d6c4dee2e8aa4c0f6dddd99cf4cd665">RAW_DATA</a> =  0, 
<a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b0143c7fceb9005d99c4e641b782eb5ab71">DEFINED_RAW_DATA</a>, 
<a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b0190c92c584b980c4e39489b7fbb2f19f9">DATA_WINDOW</a>, 
<a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b01bbe369219f18fbd8127b78cabcf13482">HISTOGRAM_DATA</a>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#011177a1cbab0860116c192dbc9ce23a">getBoundingBox</a> (float bbox[6]) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes bounding box of data object.  <a href="#011177a1cbab0860116c192dbc9ce23a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#5af61662290251c31085de7660a79034">setUndefinedValue</a> (double undefinedValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the undefined value.  <a href="#5af61662290251c31085de7660a79034"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#ce13531fe898946e3846ea3b9a23a357">hasUndefinedValue</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if spatial data has undefined value.  <a href="#ce13531fe898946e3846ea3b9a23a357"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#82eba53dc3c3b0b50bb38fca85d53320">getUndefinedValue</a> (double &amp;undefinedValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the undefined value.  <a href="#82eba53dc3c3b0b50bb38fca85d53320"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#d43328d48d72c08cb473f6889e67cf02">getMemSize</a> (<a class="el" href="group__mclib.html#g8d69b8479c19b5f1de35a4030c6a859b">mcuint64</a> &amp;size, const <a class="el" href="class_mc_box3f.html">McBox3f</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the approximative data size in bytes within a 3D bounding box.  <a href="#d43328d48d72c08cb473f6889e67cf02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#04b35fbf3475f77df3a724c771caec5f">hasDataWindow</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if spatial data has a DataWindow parameter.  <a href="#04b35fbf3475f77df3a724c771caec5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#2376e614b23e9648b46e5d02097b8233">setDataWindow</a> (double min, double max)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the DataWindow parameter.  <a href="#2376e614b23e9648b46e5d02097b8233"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#f10601977afb7d0e879a6f37810f6adf">removeDataWindow</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the DataWindow parameter.  <a href="#f10601977afb7d0e879a6f37810f6adf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_vec3f.html">McVec3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#c1e5406df233978b63b23b8411d34365">getBoundingBoxSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes bounding box of data object.  <a href="#c1e5406df233978b63b23b8411d34365"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_vec3f.html">McVec3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#16ae162437652228ac48c0dc68f8fcb4">getBoundingBoxCenter</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes bounding box of data object.  <a href="#16ae162437652228ac48c0dc68f8fcb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_vec3f.html">McVec3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#28ef76ba89e998a0028f3b747bf5fbfd">getBoundingBoxOrigin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the lower, left corner.  <a href="#28ef76ba89e998a0028f3b747bf5fbfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const SoTransform *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#fdf67f58d6ceec6aa95806b18e1096d3">getTransform</a> (bool create=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Each data object can have an optional pointer to an SoTransform object.  <a href="#fdf67f58d6ceec6aa95806b18e1096d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SoTransform *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#31b73c3f74942917b8e333488b61aec7">getTransform</a> (bool create=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns current transformation.  <a href="#31b73c3f74942917b8e333488b61aec7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#73448f125e59b60ee08e67be591260b6">hasTransform</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicator if data has a transformation.  <a href="#73448f125e59b60ee08e67be591260b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#94b72ee31318df2c9600c629ebcfa5fd">setTransform</a> (SoTransform *xform)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set current transformation.  <a href="#94b72ee31318df2c9600c629ebcfa5fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#3fb138b788ef36e0ba47a5cc41406c86">setTransform</a> (const SbMatrix &amp;matrix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set transformation to be this matrix.  <a href="#3fb138b788ef36e0ba47a5cc41406c86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#f985bf5f0dac0e94eb578d2e1bcb0f4d">setTransformRounded</a> (const SbMatrix &amp;matrix, unsigned short precision=6)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set current transformation via setTransform after rounding each entry to the number of digits given by <code>precision</code>.  <a href="#f985bf5f0dac0e94eb578d2e1bcb0f4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#11e3f2c8c66de8a3050d2df766fdb5ff">getTransform</a> (SbMatrix &amp;matrix) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current transformation matrix.  <a href="#11e3f2c8c66de8a3050d2df766fdb5ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#1533cc17970891bcc9f39c870d67188f">getTransformRounded</a> (SbMatrix &amp;matrix, unsigned short precision=6) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current transformation via getTransform and round each entry to the number of digits specified by <code>precision</code>.  <a href="#1533cc17970891bcc9f39c870d67188f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#103ccc12e68baed27fb7427dffa0ec80">getTransform</a> (SbMatrix &amp;matrix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current transformation matrix.  <a href="#103ccc12e68baed27fb7427dffa0ec80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#c2d3ce02dd0720d886915c727949778b">getInverseTransform</a> (SbMatrix &amp;matrix) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get inverse of current transformation matrix.  <a href="#c2d3ce02dd0720d886915c727949778b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#2ddf6c3f9dc19534c7d9e9e1cc2fecb7">getInverseTransformRounded</a> (SbMatrix &amp;matrix, unsigned short precision=6) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get rounded inverse of current transformation matrix.  <a href="#2ddf6c3f9dc19534c7d9e9e1cc2fecb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#c5246bf7b591c264fa26d69d02661498">getTransformNoTranslation</a> (SbMatrix &amp;matrix) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current transformation matrix without translational part.  <a href="#c5246bf7b591c264fa26d69d02661498"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#b5d7229a9cbf9f23134ac571d080f402">getInverseTransformNoTranslation</a> (SbMatrix &amp;matrix) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get inverse of current transformation matrix without translational part.  <a href="#b5d7229a9cbf9f23134ac571d080f402"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#ef8b2b7e82f9a4a4727aa877c5a0759b">copyTransformFrom</a> (const <a class="el" href="class_hx_spatial_data.html">HxSpatialData</a> *other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy value of transformation from other data object.  <a href="#ef8b2b7e82f9a4a4727aa877c5a0759b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#e2991f6ee5515ea60e6013a7e1cabb46">translate</a> (const <a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;displacement, int localCoords=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translates the object by modifying its transformation matrix.  <a href="#e2991f6ee5515ea60e6013a7e1cabb46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#b04d339fb2cc80c3ec76926cd76b1e32">rotate</a> (const SbRotation &amp;rotation, int localCoords=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotates the object by modifying its transformation matrix.  <a href="#b04d339fb2cc80c3ec76926cd76b1e32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#09ae94c523ccb485abfd59ba37342ef4">scale</a> (const <a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;scaleFactor, int localCoords=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the object by modifying its transformation matrix.  <a href="#09ae94c523ccb485abfd59ba37342ef4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#7a4333ccb13f2596899d24b441330eee">parse</a> (Tcl_Interp *interpreter, int argc, char **argv)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#5e2736cab8e9cb803750e7e9eddf6fa5">savePorts</a> (FILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves transformation in addition to <a class="el" href="class_hx_object.html#ee231bd26250b39fde1ebac894d25671">HxData::savePorts</a>.  <a href="#5e2736cab8e9cb803750e7e9eddf6fa5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#3c83fe844e86245111c1288c68a69804">saveTransform</a> (FILE *fp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves transformation.  <a href="#3c83fe844e86245111c1288c68a69804"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#9e2045d1c0d2dc843e61cf700f1e8769">copyData</a> (const <a class="el" href="class_hx_spatial_data.html">HxSpatialData</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This essentially copies the parameter bundle.  <a href="#9e2045d1c0d2dc843e61cf700f1e8769"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#fb2b8e0f72da0ae45f030db0c48bd635">touch</a> (unsigned int mask=0xffffffff)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Touch method.  <a href="#fb2b8e0f72da0ae45f030db0c48bd635"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#596f0151bd2d60cceca6537d4f9d6bf9">touchMinMax</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidates cached minimal and maximal values.  <a href="#596f0151bd2d60cceca6537d4f9d6bf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#ff05ad9b11534d909379758509004283">getRange</a> (float &amp;min, float &amp;max, <a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b01">RangeType</a> rangeType=RAW_DATA)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns min max data values.  <a href="#ff05ad9b11534d909379758509004283"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_mc_histogram.html">McHistogram</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#9d493403f40d2ab0304769fbed6e9b2b">getHistogram</a> (int numBins=256)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the data's histogram.  <a href="#9d493403f40d2ab0304769fbed6e9b2b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#dd4ae043b1a586b517cd22797a585ba2">HxSpatialData</a> (<a class="el" href="class_mc_interface_owner.html">McInterfaceOwner</a> *owner=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#11d0a84ad55417822b861324829793ef">~HxSpatialData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#184207bf09d70e952022de7f3a838892">computeRange</a> (float &amp;min, float &amp;max, bool discardUndefinedValues=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_mc_handle.html">McHandle</a>&lt; <a class="el" href="class_mc_histogram.html">McHistogram</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#55e7a5590516e74e6bb1ae3d9af371c6">computeHistogram</a> (unsigned int numBins, <a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *progress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#0a94f84fc455f8db5ab41d9668e89992">transformSensorCallBack</a> (SoSensor *sensor)</td></tr>

<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#faf8827312e6be3a85c19b7121fb3b0c">transformSensorCB</a> (void *userdata, SoSensor *)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#9e3f02210031dc8ee5bf51502a4deac8">m_undefinedValue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#58b1e33ee651c81df8e60154b2a2acd3">m_rawDataMin</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#6d59801f1fc5f5d4cbfce48eb1675d47">m_rawDataMax</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#aba059cadd9a0a30243641ad7597c624">m_definedRawDataMin</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#c1d332578ff0b5a8058185fd8c2a0df7">m_definedRawDataMax</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#6a9a480a633455fb6cdc4ae9babad5a0">m_dataWindowMin</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#ae354085b7abf47bfab3f32c06672c25">m_dataWindowMax</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#cf934507ef1455d18011b47e49d66406">m_histogramDataMin</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#27f848e0a35e9d4467f0b688ca74b09d">m_histogramDataMax</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SoTransform *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#37992a2de25efbd87d6377061fc7f3a5">transform</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SoNodeSensor *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#ddf6781a764b3b46a0f34cbeaae2dfc0">transformSensor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_qx_histogram_worker.html">QxHistogramWorker</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#e935a824328cfb9d31651750ed3814ec">m_histogramWorker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#b9558a5ec748d52348ee45cd6f8457c7">mHasTransform</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_spatial_data.html#5dafa0fc5cfcb9a807ac4c637195c59a">QxHistogramWorker</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for all data objects that are defined in three dimensional space. 
<p>
Every such data object defines a 3D bounding box. It also may be transformed by a 4x4 homogeneous transformation matrix. The transformation is stored in a SoTransform node and is applied automatically to all downstream visualization modules (see also discussion of geometric transformations in the documentation of class <a class="el" href="class_hx_base.html">HxBase</a>). 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="71a58eda3c67a50f78b342792e147b01"></a><!-- doxytag: member="HxSpatialData::RangeType" ref="71a58eda3c67a50f78b342792e147b01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b01">HxSpatialData::RangeType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="71a58eda3c67a50f78b342792e147b013d6c4dee2e8aa4c0f6dddd99cf4cd665"></a><!-- doxytag: member="RAW_DATA" ref="71a58eda3c67a50f78b342792e147b013d6c4dee2e8aa4c0f6dddd99cf4cd665" args="" -->RAW_DATA</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="71a58eda3c67a50f78b342792e147b0143c7fceb9005d99c4e641b782eb5ab71"></a><!-- doxytag: member="DEFINED_RAW_DATA" ref="71a58eda3c67a50f78b342792e147b0143c7fceb9005d99c4e641b782eb5ab71" args="" -->DEFINED_RAW_DATA</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="71a58eda3c67a50f78b342792e147b0190c92c584b980c4e39489b7fbb2f19f9"></a><!-- doxytag: member="DATA_WINDOW" ref="71a58eda3c67a50f78b342792e147b0190c92c584b980c4e39489b7fbb2f19f9" args="" -->DATA_WINDOW</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="71a58eda3c67a50f78b342792e147b01bbe369219f18fbd8127b78cabcf13482"></a><!-- doxytag: member="HISTOGRAM_DATA" ref="71a58eda3c67a50f78b342792e147b01bbe369219f18fbd8127b78cabcf13482" args="" -->HISTOGRAM_DATA</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="dd4ae043b1a586b517cd22797a585ba2"></a><!-- doxytag: member="HxSpatialData::HxSpatialData" ref="dd4ae043b1a586b517cd22797a585ba2" args="(McInterfaceOwner *owner=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HxSpatialData::HxSpatialData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_interface_owner.html">McInterfaceOwner</a> *&nbsp;</td>
          <td class="paramname"> <em>owner</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="11d0a84ad55417822b861324829793ef"></a><!-- doxytag: member="HxSpatialData::~HxSpatialData" ref="11d0a84ad55417822b861324829793ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual HxSpatialData::~HxSpatialData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="011177a1cbab0860116c192dbc9ce23a"></a><!-- doxytag: member="HxSpatialData::getBoundingBox" ref="011177a1cbab0860116c192dbc9ce23a" args="(float bbox[6]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::getBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>bbox</em>[6]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes bounding box of data object. 
<p>
The values are stored in the following order: minX, maxX, minY, maxY, minZ, maxZ. Note: This method does not take any transformation into account. That is, to get the global coordinates of a transformed object, one has to apply the transformation to the returned values manually. 
<p>
Reimplemented in <a class="el" href="class_hx_hexa_complex_vector_field3.html#121e6168ac3b51a744eeca9449d07bc8">HxHexaComplexVectorField3</a>, <a class="el" href="class_hx_tetra_vector_field3.html#31dffac52fdaa7ef7c15acbf4a5bc7da">HxTetraVectorField3</a>, <a class="el" href="class_hx_anna_vector_field3.html#3c509c5dcdb07cfd2a591da8dc347162">HxAnnaVectorField3</a>, <a class="el" href="class_hx_reg_scalar_field3.html#9c8931f2d23adc2e2db965dea6a48414">HxRegScalarField3</a>, <a class="el" href="class_hx_tetra_sym2_tensor_field3.html#2d7cfa1f36773adb81c63ebc399a7644">HxTetraSym2TensorField3</a>, <a class="el" href="class_hx_reg_color_field3.html#5251675e3109a2f701b9ef80547b7f4d">HxRegColorField3</a>, <a class="el" href="class_hx_hexa_complex_scalar_field3.html#f0eee3bc710aed5cd9813a831032f6db">HxHexaComplexScalarField3</a>, <a class="el" href="class_hx_edge_elem_complex_vector_field3.html#ada00b9e570dfcaf9ffb1dd49d3aa74f">HxEdgeElemComplexVectorField3</a>, <a class="el" href="class_hx_multi_channel_field3.html#c2516747a2d5477042b4151cad3a26a7">HxMultiChannelField3</a>, <a class="el" href="class_hx_voxel_field_set.html#32f2aa79ac06ca2184bb6c9602e48dfe">HxVoxelFieldSet</a>, <a class="el" href="class_hx_hexa_vector_field3.html#fa7eac638cf2ae915a0684bf1e3134b3">HxHexaVectorField3</a>, <a class="el" href="class_hx_hexa_grid.html#7396dd77b2c1f8bce24f13753b068e11">HxHexaGrid</a>, <a class="el" href="class_hx_hexa_scalar_field3.html#4359208e9660263933d54b16747df19d">HxHexaScalarField3</a>, <a class="el" href="class_hx_tetra_complex_scalar_field3.html#c285fa7c8c7e9bf285af442b37753d11">HxTetraComplexScalarField3</a>, <a class="el" href="class_hx_reg_field3.html#6e88cf0c7f6bc632b183bb1a97a93c94">HxRegField3</a>, <a class="el" href="class_hx_tetra_field3.html#a1d50d8f5bead38945118e95575f47d7">HxTetraField3</a>, <a class="el" href="class_hx_edge_elem_vector_field3.html#5d678f974d39d153e313daa888e92835">HxEdgeElemVectorField3</a>, <a class="el" href="class_hx_reg_complex_vector_field3.html#62b11de7dfa1bbead2a2ea6492f1eb7c">HxRegComplexVectorField3</a>, <a class="el" href="class_hx_tetra_complex_vector_field3.html#da81a17c76a4e6774715bab1a21ae3fc">HxTetraComplexVectorField3</a>, <a class="el" href="class_hx_reg_vector_field3.html#730148461c295481e1327b2fae4633f6">HxRegVectorField3</a>, <a class="el" href="class_hx_block_structured_grid.html#ed047bd1eff037f7ad930cb560a4475a">HxBlockStructuredGrid</a>, <a class="el" href="class_hx_reg_complex_scalar_field3.html#aafd3c037c183c7541d44619b32239bc">HxRegComplexScalarField3</a>, <a class="el" href="class_hx_reg_sym2_tensor_field3.html#9739f49513ceb79497dd61d1ccc119d2">HxRegSym2TensorField3</a>, <a class="el" href="class_hx_tetra_scalar_field3.html#813c7f7b586cb1694cc0d79dae9a5d62">HxTetraScalarField3</a>, <a class="el" href="class_hx_tetra_field_set.html#3ccb4052adf0f2112356c914d6447d8c">HxTetraFieldSet</a>, <a class="el" href="class_hx_anna_scalar_field3.html#a625cca90c69dfff0e05659dcd147219">HxAnnaScalarField3</a>, <a class="el" href="class_hx_tetra_grid.html#754cde7603c42a4901f0373e7535b2bb">HxTetraGrid</a>, <a class="el" href="class_hx_hexa_field3.html#c9a75d9c95a1144dc8b22ed31b7e6aa4">HxHexaField3</a>, <a class="el" href="class_hx_cluster.html#eed03738dd9b2a2f8f7ca6ac9ff73bad">HxCluster</a>, <a class="el" href="class_hx_iv_data.html#4b77a69cca9a25f720624c75d6430921">HxIvData</a>, <a class="el" href="class_hx_surface.html#d10f58c9946494f92b98e9a549665fd4">HxSurface</a>, <a class="el" href="class_hx_surface_field.html#bf64da46e1600cd859a49cd9b18223ef">HxSurfaceField</a>, <a class="el" href="class_hx_stacked_slices_lattice.html#020df2eed1d2d0e76059de65bd999687">HxStackedSlicesLattice</a>, <a class="el" href="class_hx_line_set.html#4e4f8007918b44d8d294925ede1ad929">HxLineSet</a>, <a class="el" href="class_hx_curve.html#1fbcaef6d2727e57049f9d6fcdb6a059">HxCurve</a>, <a class="el" href="class_hx_volume_data_object.html#0d9b0983f6d09c4d4f1a4a2be1a8d2a4">HxVolumeDataObject</a>, <a class="el" href="class_hx_arith_l_d_m.html#d473347a7ed66ac087562af06b8fa518">HxArithLDM</a>, <a class="el" href="class_hx_vertex_set.html#6d84c44bc29d172eaa67a938070147cc">HxVertexSet</a>, <a class="el" href="class_hx_landmark_set.html#b21c3633e9931d9f2ed55170efbbe3c9">HxLandmarkSet</a>, <a class="el" href="class_hx_block_structured_field3.html#9151642b01ccab57f756b8284bbdd0f2">HxBlockStructuredField3&lt; HxScalarField3 &gt;</a>, and <a class="el" href="class_hx_block_structured_field3.html#9151642b01ccab57f756b8284bbdd0f2">HxBlockStructuredField3&lt; HxVectorField3 &gt;</a>.
</div>
</div><p>
<a class="anchor" name="5af61662290251c31085de7660a79034"></a><!-- doxytag: member="HxSpatialData::setUndefinedValue" ref="5af61662290251c31085de7660a79034" args="(double undefinedValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::setUndefinedValue           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>undefinedValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the undefined value. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which data can be undefined. 
<p>
Reimplemented in <a class="el" href="class_hx_hexa_complex_vector_field3.html#cdd024e709f4f2f5ecc6273063f249e9">HxHexaComplexVectorField3</a>, <a class="el" href="class_hx_tetra_vector_field3.html#ba84161f110c76f5c0b828d608893256">HxTetraVectorField3</a>, <a class="el" href="class_hx_reg_scalar_field3.html#c55aef481870300ab0c6a7cb3137344d">HxRegScalarField3</a>, <a class="el" href="class_hx_tetra_sym2_tensor_field3.html#a9eb6cf9d6ae45219529c6572ebfd841">HxTetraSym2TensorField3</a>, <a class="el" href="class_hx_reg_color_field3.html#6c663df03d7a6786bd48b0ee50399c68">HxRegColorField3</a>, <a class="el" href="class_hx_hexa_complex_scalar_field3.html#578ef09a9f0fc7c1e3d6c28d08788fc7">HxHexaComplexScalarField3</a>, <a class="el" href="class_hx_hexa_vector_field3.html#192fbd4c6dbeea7765138e3a73388ec2">HxHexaVectorField3</a>, <a class="el" href="class_hx_hexa_scalar_field3.html#b7d9a572faecdcab39af81b554ab8a3f">HxHexaScalarField3</a>, <a class="el" href="class_hx_tetra_complex_scalar_field3.html#8163634951aacbe4a6a349614660c2e8">HxTetraComplexScalarField3</a>, <a class="el" href="class_hx_reg_field3.html#c500a361231313c4aeb221f34d66bec7">HxRegField3</a>, <a class="el" href="class_hx_tetra_field3.html#b50f8e3002f9e391810becbbbfd575b5">HxTetraField3</a>, <a class="el" href="class_hx_reg_complex_vector_field3.html#416302c7f1f2ad11203b7598350aaee1">HxRegComplexVectorField3</a>, <a class="el" href="class_hx_tetra_complex_vector_field3.html#f8f42482413eb3b3101636406ae2ad97">HxTetraComplexVectorField3</a>, <a class="el" href="class_hx_reg_vector_field3.html#b5d61a7ac26baaa2d13d4814d902d976">HxRegVectorField3</a>, <a class="el" href="class_hx_reg_complex_scalar_field3.html#a077e00b423ac4d4fb77c831fb444573">HxRegComplexScalarField3</a>, <a class="el" href="class_hx_reg_sym2_tensor_field3.html#1c66d9af4eb2871ecb5de720a82254af">HxRegSym2TensorField3</a>, <a class="el" href="class_hx_tetra_scalar_field3.html#7778ea20a5aeb3c286b94e9e51ccfe96">HxTetraScalarField3</a>, and <a class="el" href="class_hx_hexa_field3.html#7b36d1d7f5a96cf4341bb82ae74e0ebd">HxHexaField3</a>.
</div>
</div><p>
<a class="anchor" name="ce13531fe898946e3846ea3b9a23a357"></a><!-- doxytag: member="HxSpatialData::hasUndefinedValue" ref="ce13531fe898946e3846ea3b9a23a357" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HxSpatialData::hasUndefinedValue           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell if spatial data has undefined value. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which data can be undefined. 
</div>
</div><p>
<a class="anchor" name="82eba53dc3c3b0b50bb38fca85d53320"></a><!-- doxytag: member="HxSpatialData::getUndefinedValue" ref="82eba53dc3c3b0b50bb38fca85d53320" args="(double &amp;undefinedValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int HxSpatialData::getUndefinedValue           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>undefinedValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the undefined value. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which data can be undefined. If there is no undefined value, this method return 0 otherwise, 1. 
</div>
</div><p>
<a class="anchor" name="d43328d48d72c08cb473f6889e67cf02"></a><!-- doxytag: member="HxSpatialData::getMemSize" ref="d43328d48d72c08cb473f6889e67cf02" args="(mcuint64 &amp;size, const McBox3f &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HxSpatialData::getMemSize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mclib.html#g8d69b8479c19b5f1de35a4030c6a859b">mcuint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_box3f.html">McBox3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the approximative data size in bytes within a 3D bounding box. 
<p>
false is returned if could not be computed or the computation is not implemented. 
<p>
Reimplemented in <a class="el" href="class_hx_reg_scalar_field3.html#b0eecec9749f37c0cbd7d402124a2080">HxRegScalarField3</a>, <a class="el" href="class_hx_reg_color_field3.html#74bb4932022934213fcf629b40da4294">HxRegColorField3</a>, and <a class="el" href="class_hx_volume_data_object.html#12e22719159f35ff38e9f9ec1396ed70">HxVolumeDataObject</a>.
</div>
</div><p>
<a class="anchor" name="04b35fbf3475f77df3a724c771caec5f"></a><!-- doxytag: member="HxSpatialData::hasDataWindow" ref="04b35fbf3475f77df3a724c771caec5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HxSpatialData::hasDataWindow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell if spatial data has a DataWindow parameter. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which data can be undefined. 
</div>
</div><p>
<a class="anchor" name="2376e614b23e9648b46e5d02097b8233"></a><!-- doxytag: member="HxSpatialData::setDataWindow" ref="2376e614b23e9648b46e5d02097b8233" args="(double min, double max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::setDataWindow           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the DataWindow parameter. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which a data window can be defined. This range can be greater than the real raw data range. See <code>getRange(float&amp; min, float&amp; max, RangeType rangeType=RAW_DATA)</code> method to get it. 
</div>
</div><p>
<a class="anchor" name="f10601977afb7d0e879a6f37810f6adf"></a><!-- doxytag: member="HxSpatialData::removeDataWindow" ref="f10601977afb7d0e879a6f37810f6adf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::removeDataWindow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the DataWindow parameter. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which a data window can be defined. 
</div>
</div><p>
<a class="anchor" name="c1e5406df233978b63b23b8411d34365"></a><!-- doxytag: member="HxSpatialData::getBoundingBoxSize" ref="c1e5406df233978b63b23b8411d34365" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_vec3f.html">McVec3f</a> HxSpatialData::getBoundingBoxSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes bounding box of data object. 
<p>

</div>
</div><p>
<a class="anchor" name="16ae162437652228ac48c0dc68f8fcb4"></a><!-- doxytag: member="HxSpatialData::getBoundingBoxCenter" ref="16ae162437652228ac48c0dc68f8fcb4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_vec3f.html">McVec3f</a> HxSpatialData::getBoundingBoxCenter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes bounding box of data object. 
<p>

</div>
</div><p>
<a class="anchor" name="28ef76ba89e998a0028f3b747bf5fbfd"></a><!-- doxytag: member="HxSpatialData::getBoundingBoxOrigin" ref="28ef76ba89e998a0028f3b747bf5fbfd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_vec3f.html">McVec3f</a> HxSpatialData::getBoundingBoxOrigin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the lower, left corner. 
<p>

</div>
</div><p>
<a class="anchor" name="fdf67f58d6ceec6aa95806b18e1096d3"></a><!-- doxytag: member="HxSpatialData::getTransform" ref="fdf67f58d6ceec6aa95806b18e1096d3" args="(bool create=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SoTransform* HxSpatialData::getTransform           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>create</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Each data object can have an optional pointer to an SoTransform object. 
<p>
This allows for global scaling, translation and rotation of data objects.<p>
This transformation will automatically be applied to any geometry displayed by modules connected to this data object. Therefore there is normally no need to think about these transformations. However in cases where two or more datasets are treated by one module, transformations are to be considered.<p>
The transformation may be accessed using the <code> SoTransform* <a class="el" href="class_hx_spatial_data.html#fdf67f58d6ceec6aa95806b18e1096d3">getTransform()</a></code> method, which may return a NULL pointer, if the data object is not transformed and create is false.<p>
Often it is easier to use the <code><a class="el" href="class_hx_spatial_data.html#103ccc12e68baed27fb7427dffa0ec80">getTransform(SbMatrix&amp; matrix)</a></code>, which returns the current transformation matrix or the identity matrix, when there is no transformation. This matrix is to be applied by multiplying it to a vector from the right hand side. It transforms vectors from the local coordinate system to the global coordinate system.<p>
If you want to transform world coordinates to local coordinates, use <code> getInverseTransform(SbMatrix&amp; matrix)</code>.<p>
As an example, consider the following code, which transforms the origin of a field A to the local coordinate system of a second field B. <div class="fragment"><pre class="fragment">        <span class="keywordtype">float</span> bbox[6];
        SbVec3f originWorld,originB;
        SbMatrix matrixA, inverseMatrixB;

        / / Compute origin in local (A) coordinates
        fieldA-&gt;<a class="code" href="class_hx_spatial_data.html#011177a1cbab0860116c192dbc9ce23a">getBoundingBox</a>(bbox);
        SbVec3f origin(bbox[0],bbox[1],bbox[2]);

        fieldA-&gt;<a class="code" href="class_hx_spatial_data.html#fdf67f58d6ceec6aa95806b18e1096d3">getTransform</a>(matrixA);
        fieldB-&gt;<a class="code" href="class_hx_spatial_data.html#c2d3ce02dd0720d886915c727949778b">getInverseTransform</a>(inverseMatrixB);

        / / <a class="code" href="class_hx_spatial_data.html#37992a2de25efbd87d6377061fc7f3a5">transform</a> origin to world coordinates:
        matrixA.multVecMatrix(origin,originWorld);

        / / <a class="code" href="class_hx_spatial_data.html#37992a2de25efbd87d6377061fc7f3a5">transform</a> origin from world to local B coordinates:
        inverseMatrixB.multVecMatrix(originWorld,originB);
</pre></div> Instead of the last lines of code one could also combine the two matrices: <div class="fragment"><pre class="fragment">        SbMatrix allInOne;
        allInOne = matrixA;
        allInOne.multRight(inverseMatrixB);
</pre></div><p>
Note that this is the same as: SbMatrix allInOne; <div class="fragment"><pre class="fragment">        allInOne = inverseMatrixB;
        allInOne.multLeft(matrixA);
</pre></div><p>
Since the transformation could contain a translational part, special attention has to be paid, when directional vectors are transformed. In this case the method <code> getTransformNoTranslation(SbMatrix&amp; matrix)</code> should be used. 
</div>
</div><p>
<a class="anchor" name="31b73c3f74942917b8e333488b61aec7"></a><!-- doxytag: member="HxSpatialData::getTransform" ref="31b73c3f74942917b8e333488b61aec7" args="(bool create=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoTransform* HxSpatialData::getTransform           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>create</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns current transformation. 
<p>
If this object has no transformation and if create is true, a new identity transform node will be created. Otherwise NULL will be returned. 
</div>
</div><p>
<a class="anchor" name="73448f125e59b60ee08e67be591260b6"></a><!-- doxytag: member="HxSpatialData::hasTransform" ref="73448f125e59b60ee08e67be591260b6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HxSpatialData::hasTransform           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicator if data has a transformation. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true if the transformation is not the identity, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="94b72ee31318df2c9600c629ebcfa5fd"></a><!-- doxytag: member="HxSpatialData::setTransform" ref="94b72ee31318df2c9600c629ebcfa5fd" args="(SoTransform *xform)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::setTransform           </td>
          <td>(</td>
          <td class="paramtype">SoTransform *&nbsp;</td>
          <td class="paramname"> <em>xform</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set current transformation. 
<p>
If xform is not null, its ref-count will be increased and it will be used as the new object's transform node. If xform is null the object's transformation will be reset to the identity transformation. 
</div>
</div><p>
<a class="anchor" name="3fb138b788ef36e0ba47a5cc41406c86"></a><!-- doxytag: member="HxSpatialData::setTransform" ref="3fb138b788ef36e0ba47a5cc41406c86" args="(const SbMatrix &amp;matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::setTransform           </td>
          <td>(</td>
          <td class="paramtype">const SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set transformation to be this matrix. 
<p>
If no transformation exists one is created. 
</div>
</div><p>
<a class="anchor" name="f985bf5f0dac0e94eb578d2e1bcb0f4d"></a><!-- doxytag: member="HxSpatialData::setTransformRounded" ref="f985bf5f0dac0e94eb578d2e1bcb0f4d" args="(const SbMatrix &amp;matrix, unsigned short precision=6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::setTransformRounded           </td>
          <td>(</td>
          <td class="paramtype">const SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>precision</em> = <code>6</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set current transformation via setTransform after rounding each entry to the number of digits given by <code>precision</code>. 
<p>
In order to get the same transformation back, getTransformRounded needs to be called with the same precision. For the default precision value of 6 and smaller, the transformation should be equal. For larger precision values this is not guaranteed. 
</div>
</div><p>
<a class="anchor" name="11e3f2c8c66de8a3050d2df766fdb5ff"></a><!-- doxytag: member="HxSpatialData::getTransform" ref="11e3f2c8c66de8a3050d2df766fdb5ff" args="(SbMatrix &amp;matrix) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::getTransform           </td>
          <td>(</td>
          <td class="paramtype">SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get current transformation matrix. 
<p>
If this object has no transformation, identity is returned. 
</div>
</div><p>
<a class="anchor" name="1533cc17970891bcc9f39c870d67188f"></a><!-- doxytag: member="HxSpatialData::getTransformRounded" ref="1533cc17970891bcc9f39c870d67188f" args="(SbMatrix &amp;matrix, unsigned short precision=6) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::getTransformRounded           </td>
          <td>(</td>
          <td class="paramtype">SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>precision</em> = <code>6</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get current transformation via getTransform and round each entry to the number of digits specified by <code>precision</code>. 
<p>
getTransformRounded should be called with the same precision as <a class="el" href="class_hx_spatial_data.html#f985bf5f0dac0e94eb578d2e1bcb0f4d">setTransformRounded()</a> to obtain the same transformation. For the default precision value of 6 and smaller, the transformation should be equal. For larger precision values this is not guaranteed. 
</div>
</div><p>
<a class="anchor" name="103ccc12e68baed27fb7427dffa0ec80"></a><!-- doxytag: member="HxSpatialData::getTransform" ref="103ccc12e68baed27fb7427dffa0ec80" args="(SbMatrix &amp;matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::getTransform           </td>
          <td>(</td>
          <td class="paramtype">SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get current transformation matrix. 
<p>
If this object has no transformation, identity is returned. 
</div>
</div><p>
<a class="anchor" name="c2d3ce02dd0720d886915c727949778b"></a><!-- doxytag: member="HxSpatialData::getInverseTransform" ref="c2d3ce02dd0720d886915c727949778b" args="(SbMatrix &amp;matrix) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::getInverseTransform           </td>
          <td>(</td>
          <td class="paramtype">SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get inverse of current transformation matrix. 
<p>
If this object has no transformation, identity is returned. 
</div>
</div><p>
<a class="anchor" name="2ddf6c3f9dc19534c7d9e9e1cc2fecb7"></a><!-- doxytag: member="HxSpatialData::getInverseTransformRounded" ref="2ddf6c3f9dc19534c7d9e9e1cc2fecb7" args="(SbMatrix &amp;matrix, unsigned short precision=6) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::getInverseTransformRounded           </td>
          <td>(</td>
          <td class="paramtype">SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>precision</em> = <code>6</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get rounded inverse of current transformation matrix. 
<p>
If this object has no transformation, identity is returned. 
</div>
</div><p>
<a class="anchor" name="c5246bf7b591c264fa26d69d02661498"></a><!-- doxytag: member="HxSpatialData::getTransformNoTranslation" ref="c5246bf7b591c264fa26d69d02661498" args="(SbMatrix &amp;matrix) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::getTransformNoTranslation           </td>
          <td>(</td>
          <td class="paramtype">SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get current transformation matrix without translational part. 
<p>
If this object has no transformation, identity is returned. 
</div>
</div><p>
<a class="anchor" name="b5d7229a9cbf9f23134ac571d080f402"></a><!-- doxytag: member="HxSpatialData::getInverseTransformNoTranslation" ref="b5d7229a9cbf9f23134ac571d080f402" args="(SbMatrix &amp;matrix) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::getInverseTransformNoTranslation           </td>
          <td>(</td>
          <td class="paramtype">SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get inverse of current transformation matrix without translational part. 
<p>
If this object has no transformation, identity is returned. 
</div>
</div><p>
<a class="anchor" name="ef8b2b7e82f9a4a4727aa877c5a0759b"></a><!-- doxytag: member="HxSpatialData::copyTransformFrom" ref="ef8b2b7e82f9a4a4727aa877c5a0759b" args="(const HxSpatialData *other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::copyTransformFrom           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_hx_spatial_data.html">HxSpatialData</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy value of transformation from other data object. 
<p>

</div>
</div><p>
<a class="anchor" name="e2991f6ee5515ea60e6013a7e1cabb46"></a><!-- doxytag: member="HxSpatialData::translate" ref="e2991f6ee5515ea60e6013a7e1cabb46" args="(const McVec3f &amp;displacement, int localCoords=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::translate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>displacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>localCoords</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Translates the object by modifying its transformation matrix. 
<p>
The translation is applied in local coordinates (after the existing transformation) if the argument <code>localCoords</code> is 1, Otherwise it is applied in world coordinates (before the existing transformation). 
</div>
</div><p>
<a class="anchor" name="b04d339fb2cc80c3ec76926cd76b1e32"></a><!-- doxytag: member="HxSpatialData::rotate" ref="b04d339fb2cc80c3ec76926cd76b1e32" args="(const SbRotation &amp;rotation, int localCoords=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::rotate           </td>
          <td>(</td>
          <td class="paramtype">const SbRotation &amp;&nbsp;</td>
          <td class="paramname"> <em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>localCoords</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotates the object by modifying its transformation matrix. 
<p>
The rotation is applied in local coordinates (after the existing transformation) if the argument <code>localCoords</code> is 1, Otherwise it is applied in world coordinates (before the existing transformation). 
</div>
</div><p>
<a class="anchor" name="09ae94c523ccb485abfd59ba37342ef4"></a><!-- doxytag: member="HxSpatialData::scale" ref="09ae94c523ccb485abfd59ba37342ef4" args="(const McVec3f &amp;scaleFactor, int localCoords=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::scale           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scaleFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>localCoords</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scales the object by modifying its transformation matrix. 
<p>
The scaling is applied in local coordinates (after the existing transformation) if the argument <code>localCoords</code> is 1, Otherwise it is applied in world coordinates (before the existing transformation). 
</div>
</div><p>
<a class="anchor" name="7a4333ccb13f2596899d24b441330eee"></a><!-- doxytag: member="HxSpatialData::parse" ref="7a4333ccb13f2596899d24b441330eee" args="(Tcl_Interp *interpreter, int argc, char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int HxSpatialData::parse           </td>
          <td>(</td>
          <td class="paramtype">Tcl_Interp *&nbsp;</td>
          <td class="paramname"> <em>interpreter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Reimplemented from <a class="el" href="class_hx_data.html#1495dab429a1fd834467f061df4a14fa">HxData</a>.
<p>
Reimplemented in <a class="el" href="class_hx_anna_vector_field3.html#a289ef3caacfebf37dcfdaf808e6b8e2">HxAnnaVectorField3</a>, <a class="el" href="class_hx_reg_scalar_field3.html#ff69233f58a014cb917472aecd666bce">HxRegScalarField3</a>, <a class="el" href="class_hx_reg_color_field3.html#7bcb9cf53c823baff699196d79d5e515">HxRegColorField3</a>, <a class="el" href="class_hx_uniform_label_field3.html#681f7c2a5c07c206b82f24b207cb6062">HxUniformLabelField3</a>, <a class="el" href="class_hx_multi_channel_field3.html#4dafad50a422175a1971b311f5ba359c">HxMultiChannelField3</a>, <a class="el" href="class_hx_hexa_grid.html#9dcc9e935c88a930c48ed88bbff6f938">HxHexaGrid</a>, <a class="el" href="class_hx_uniform_scalar_field3.html#4e441b7531c0ce055d377b76664a037d">HxUniformScalarField3</a>, <a class="el" href="class_hx_uniform_color_field3.html#8e40d1a0b2166a5be82fc08c46761046">HxUniformColorField3</a>, <a class="el" href="class_hx_field3.html#0a25975ea6e9d817ffad453668af3f44">HxField3</a>, <a class="el" href="class_hx_anna_scalar_field3.html#469f5aa888f096ecf4455b3d393317a6">HxAnnaScalarField3</a>, <a class="el" href="class_hx_tetra_grid.html#a7e1a7f1d490ae8603344f58382c6395">HxTetraGrid</a>, <a class="el" href="class_hx_multi_channel_field.html#0111379e2f45e40b6af9295d92bae57c">HxMultiChannelField</a>, <a class="el" href="class_hx_cluster.html#b923290ffad3eecd99718e3741d68a79">HxCluster</a>, <a class="el" href="class_hx_iv_data.html#595950f43039d5bd37d7201176ceb2d4">HxIvData</a>, <a class="el" href="class_hx_surface.html#3aee9d1ccf1576d103476495411ae134">HxSurface</a>, <a class="el" href="class_hx_surface_field.html#7493f2f7b0ecf2a8ce6ee8b3663b5aff">HxSurfaceField</a>, <a class="el" href="class_hx_line_set.html#5ea7d3489e212d2be329e2ac35132467">HxLineSet</a>, <a class="el" href="class_hx_volume_data_object.html#6553a1f74d9cc5bf1a44dbe18b3a5bb0">HxVolumeDataObject</a>, <a class="el" href="class_hx_surface_path_set.html#827c1cd95b1a3f4143a783b0936acc4a">HxSurfacePathSet</a>, <a class="el" href="class_hx_vertex_set.html#922c36c6d42bd68c8bccfd43fbe2381d">HxVertexSet</a>, and <a class="el" href="class_hx_landmark_set.html#dbc3106b040bc0cbadb9fa71bbd973a9">HxLandmarkSet</a>.
</div>
</div><p>
<a class="anchor" name="5e2736cab8e9cb803750e7e9eddf6fa5"></a><!-- doxytag: member="HxSpatialData::savePorts" ref="5e2736cab8e9cb803750e7e9eddf6fa5" args="(FILE *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::savePorts           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves transformation in addition to <a class="el" href="class_hx_object.html#ee231bd26250b39fde1ebac894d25671">HxData::savePorts</a>. 
<p>

<p>
Reimplemented from <a class="el" href="class_hx_object.html#ee231bd26250b39fde1ebac894d25671">HxObject</a>.
<p>
Reimplemented in <a class="el" href="class_hx_anna_vector_field3.html#3b3e7c081c2249d60743a3c1c01f7542">HxAnnaVectorField3</a>, <a class="el" href="class_hx_anna_scalar_field3.html#3c828cf6562e785cc990d0ca2bc6609d">HxAnnaScalarField3</a>, and <a class="el" href="class_hx_multi_channel_field.html#e0512126b5512ccb5225693579f5f982">HxMultiChannelField</a>.
</div>
</div><p>
<a class="anchor" name="3c83fe844e86245111c1288c68a69804"></a><!-- doxytag: member="HxSpatialData::saveTransform" ref="3c83fe844e86245111c1288c68a69804" args="(FILE *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::saveTransform           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves transformation. 
<p>

</div>
</div><p>
<a class="anchor" name="9e2045d1c0d2dc843e61cf700f1e8769"></a><!-- doxytag: member="HxSpatialData::copyData" ref="9e2045d1c0d2dc843e61cf700f1e8769" args="(const HxSpatialData &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxSpatialData::copyData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_hx_spatial_data.html">HxSpatialData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This essentially copies the parameter bundle. 
<p>

</div>
</div><p>
<a class="anchor" name="fb2b8e0f72da0ae45f030db0c48bd635"></a><!-- doxytag: member="HxSpatialData::touch" ref="fb2b8e0f72da0ae45f030db0c48bd635" args="(unsigned int mask=0xffffffff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::touch           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0xffffffff</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Touch method. 
<p>

<p>
Reimplemented from <a class="el" href="class_hx_data.html#59b5a09ccc28cdcb29f94b6c02a3b990">HxData</a>.
<p>
Reimplemented in <a class="el" href="class_hx_reg_scalar_field3.html#defc7e62a435d6a3146fddf5ff8f5737">HxRegScalarField3</a>, and <a class="el" href="class_hx_reg_vector_field3.html#4c4525c409e816ac647cabdbe72b654c">HxRegVectorField3</a>.
</div>
</div><p>
<a class="anchor" name="596f0151bd2d60cceca6537d4f9d6bf9"></a><!-- doxytag: member="HxSpatialData::touchMinMax" ref="596f0151bd2d60cceca6537d4f9d6bf9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::touchMinMax           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates cached minimal and maximal values. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which min max values can be computed. 
<p>
Reimplemented in <a class="el" href="class_hx_field3.html#704b27363418da65f9c60aa36472941e">HxField3</a>.
</div>
</div><p>
<a class="anchor" name="ff05ad9b11534d909379758509004283"></a><!-- doxytag: member="HxSpatialData::getRange" ref="ff05ad9b11534d909379758509004283" args="(float &amp;min, float &amp;max, RangeType rangeType=RAW_DATA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::getRange           </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_hx_spatial_data.html#71a58eda3c67a50f78b342792e147b01">RangeType</a>&nbsp;</td>
          <td class="paramname"> <em>rangeType</em> = <code>RAW_DATA</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns min max data values. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which min max values can be computed. Internally, minimum and maximum values are cached to avoid unnecessary recomputations. If the stored values have been invalidated by calling <a class="el" href="class_hx_spatial_data.html#596f0151bd2d60cceca6537d4f9d6bf9">touchMinMax()</a> the protected virtual method <code>computeRange</code> is called to perform the actual min-max calculation. If <code>rangeType</code> is set to <code>RAW_DATA</code> and if data range can be computed, returned values represent the raw data range. If <code>rangeType</code> is set to <code>DEFINED_RAW_DATA</code> and if data range can be computed, returned values represent the valid raw data range (excluding the undefined value). If undefined value hasn't been set, the raw data range is returned. If <code>rangeType</code> is set to <code>DATA_WINDOW</code> and if data contains a DataWindow parameter, returned values are the defined DataWindow. If no DataWindow is set, the defined raw data range is returned and if no undefined value has been set, the raw data range is returned. If <code>rangeType</code> is set to <code>HISTOGRAM_DATA</code> the data range is defined, so that 99 % of all data values are greater than <code>min</code> and 99% of all data values are less than <code>max</code>. 
</div>
</div><p>
<a class="anchor" name="9d493403f40d2ab0304769fbed6e9b2b"></a><!-- doxytag: member="HxSpatialData::getHistogram" ref="9d493403f40d2ab0304769fbed6e9b2b" args="(int numBins=256)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_mc_histogram.html">McHistogram</a> HxSpatialData::getHistogram           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBins</em> = <code>256</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the data's histogram. 
<p>
This method is provided here for convenience because many spatial data objects (although not all) contain data values for which a histogram could be computed. Internally the histogram will be cached to avoid unnecessary histogram recomputations. Successive histogram computations with a number of bins <code>numBins</code> smaller than the maximum number of bins of previous histogram computations use the larger cached histogram to compute the smaller result histogram. The histogram will only be recomputed if the number of bins <code>numBins</code> is larger than the number of bins of all previous computed histograms. In addition the histogram will be invalidated if the data object has been touched and the <a class="el" href="class_hx_data.html#b6249834ee6f4873aa2f465fea65eed80d6b1525e804f89f091776caa392f6cd">HxData::NEW_DATA</a> flag has been set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numBins</em>&nbsp;</td><td>Number of histogram bins. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Resulting histogram. Might consist of less bins than specified by <code>numBins</code>.</dd></dl>
Note: Currently only data objects of type <a class="el" href="class_hx_reg_scalar_field3.html">HxRegScalarField3</a> are supported. For all other data objects a histogram with a size equal 0 will be returned. 
</div>
</div><p>
<a class="anchor" name="184207bf09d70e952022de7f3a838892"></a><!-- doxytag: member="HxSpatialData::computeRange" ref="184207bf09d70e952022de7f3a838892" args="(float &amp;min, float &amp;max, bool discardUndefinedValues=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::computeRange           </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>discardUndefinedValues</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Reimplemented in <a class="el" href="class_hx_hexa_complex_vector_field3.html#7bd3a9c76ccc4c111dfb6e38dcb8017a">HxHexaComplexVectorField3</a>, <a class="el" href="class_hx_tetra_vector_field3.html#aa415546632330c3da745f904340b812">HxTetraVectorField3</a>, <a class="el" href="class_hx_anna_vector_field3.html#5a6b717b1464755bc6380b5f4a77cde2">HxAnnaVectorField3</a>, <a class="el" href="class_hx_reg_scalar_field3.html#b78ce79b7c9a0af23aba1ac4f8a77a9c">HxRegScalarField3</a>, <a class="el" href="class_hx_tetra_sym2_tensor_field3.html#d82755f5b35f580d66ee0ad092c5caf0">HxTetraSym2TensorField3</a>, <a class="el" href="class_hx_reg_color_field3.html#10ccf8f388a22f4794e9a9783ac2be97">HxRegColorField3</a>, <a class="el" href="class_hx_hexa_complex_scalar_field3.html#12f23d4060809e5e29142e8f0d2c9fd4">HxHexaComplexScalarField3</a>, <a class="el" href="class_hx_edge_elem_complex_vector_field3.html#2f90394935b8cb810c72f7226fd3a5df">HxEdgeElemComplexVectorField3</a>, <a class="el" href="class_hx_hexa_vector_field3.html#e6e30b1bc268147fc8227ce122d23581">HxHexaVectorField3</a>, <a class="el" href="class_hx_hexa_scalar_field3.html#13a6fcfda529facbd3af008eb7735938">HxHexaScalarField3</a>, <a class="el" href="class_hx_tetra_complex_scalar_field3.html#46b99ba2cd77fae78a2f0ab6a2017cf0">HxTetraComplexScalarField3</a>, <a class="el" href="class_hx_tetra_field3.html#d6605b9186c35148e8e3c4b2215ed124">HxTetraField3</a>, <a class="el" href="class_hx_edge_elem_vector_field3.html#0a1b2b8b1f5bba5b59cf92d8c7a260b9">HxEdgeElemVectorField3</a>, <a class="el" href="class_hx_vector_field3.html#1b2dbe93f667fa70544ddf7213645dcc">HxVectorField3</a>, <a class="el" href="class_hx_field3.html#86562fb7d3420012e6861df46471af5b">HxField3</a>, <a class="el" href="class_hx_reg_complex_vector_field3.html#73c824c52ef409b4d1b5589071888042">HxRegComplexVectorField3</a>, <a class="el" href="class_hx_tetra_complex_vector_field3.html#da794163a8596f69c4b98179e0132baf">HxTetraComplexVectorField3</a>, <a class="el" href="class_hx_reg_vector_field3.html#541eee4288dffe5ffc2d006618079343">HxRegVectorField3</a>, <a class="el" href="class_hx_reg_complex_scalar_field3.html#8ccfc6d5b565430e45763748672c52f4">HxRegComplexScalarField3</a>, <a class="el" href="class_hx_reg_sym2_tensor_field3.html#f8dba3adcc4e63281ab74932b67d4826">HxRegSym2TensorField3</a>, <a class="el" href="class_hx_tetra_scalar_field3.html#c382d8e3a88f2b95d73b7982a9307588">HxTetraScalarField3</a>, <a class="el" href="class_hx_anna_scalar_field3.html#501a7dc3abd6d3d57b0882056439aac2">HxAnnaScalarField3</a>, <a class="el" href="class_hx_hexa_field3.html#36c0bf3a70c9af42a8992bdc1376eba1">HxHexaField3</a>, <a class="el" href="class_hx_surface_field.html#94e1effd20fe88b4729609600b22b7e3">HxSurfaceField</a>, <a class="el" href="class_hx_line_set.html#4d38b25d421370583565f0c672646984">HxLineSet</a>, <a class="el" href="class_hx_volume_data_object.html#66bd1e4df2dfbf87f4296fd27e9f1e4a">HxVolumeDataObject</a>, <a class="el" href="class_hx_block_structured_field3.html#d4a15c0e3baa2756deceaa05a021bb02">HxBlockStructuredField3&lt; HxScalarField3 &gt;</a>, and <a class="el" href="class_hx_block_structured_field3.html#d4a15c0e3baa2756deceaa05a021bb02">HxBlockStructuredField3&lt; HxVectorField3 &gt;</a>.
</div>
</div><p>
<a class="anchor" name="55e7a5590516e74e6bb1ae3d9af371c6"></a><!-- doxytag: member="HxSpatialData::computeHistogram" ref="55e7a5590516e74e6bb1ae3d9af371c6" args="(unsigned int numBins, McProgressInterface *progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_mc_handle.html">McHandle</a>&lt;<a class="el" href="class_mc_histogram.html">McHistogram</a>&gt; HxSpatialData::computeHistogram           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>numBins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Reimplemented in <a class="el" href="class_hx_reg_scalar_field3.html#0e92d4a9c74a6350d7cb325260233ee7">HxRegScalarField3</a>.
</div>
</div><p>
<a class="anchor" name="faf8827312e6be3a85c19b7121fb3b0c"></a><!-- doxytag: member="HxSpatialData::transformSensorCB" ref="faf8827312e6be3a85c19b7121fb3b0c" args="(void *userdata, SoSensor *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void HxSpatialData::transformSensorCB           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoSensor *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0a94f84fc455f8db5ab41d9668e89992"></a><!-- doxytag: member="HxSpatialData::transformSensorCallBack" ref="0a94f84fc455f8db5ab41d9668e89992" args="(SoSensor *sensor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxSpatialData::transformSensorCallBack           </td>
          <td>(</td>
          <td class="paramtype">SoSensor *&nbsp;</td>
          <td class="paramname"> <em>sensor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="5dafa0fc5cfcb9a807ac4c637195c59a"></a><!-- doxytag: member="HxSpatialData::QxHistogramWorker" ref="5dafa0fc5cfcb9a807ac4c637195c59a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_qx_histogram_worker.html">QxHistogramWorker</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="9e3f02210031dc8ee5bf51502a4deac8"></a><!-- doxytag: member="HxSpatialData::m_undefinedValue" ref="9e3f02210031dc8ee5bf51502a4deac8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_hx_spatial_data.html#9e3f02210031dc8ee5bf51502a4deac8">HxSpatialData::m_undefinedValue</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="58b1e33ee651c81df8e60154b2a2acd3"></a><!-- doxytag: member="HxSpatialData::m_rawDataMin" ref="58b1e33ee651c81df8e60154b2a2acd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_hx_spatial_data.html#58b1e33ee651c81df8e60154b2a2acd3">HxSpatialData::m_rawDataMin</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6d59801f1fc5f5d4cbfce48eb1675d47"></a><!-- doxytag: member="HxSpatialData::m_rawDataMax" ref="6d59801f1fc5f5d4cbfce48eb1675d47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_hx_spatial_data.html#6d59801f1fc5f5d4cbfce48eb1675d47">HxSpatialData::m_rawDataMax</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="aba059cadd9a0a30243641ad7597c624"></a><!-- doxytag: member="HxSpatialData::m_definedRawDataMin" ref="aba059cadd9a0a30243641ad7597c624" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_hx_spatial_data.html#aba059cadd9a0a30243641ad7597c624">HxSpatialData::m_definedRawDataMin</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c1d332578ff0b5a8058185fd8c2a0df7"></a><!-- doxytag: member="HxSpatialData::m_definedRawDataMax" ref="c1d332578ff0b5a8058185fd8c2a0df7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_hx_spatial_data.html#c1d332578ff0b5a8058185fd8c2a0df7">HxSpatialData::m_definedRawDataMax</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6a9a480a633455fb6cdc4ae9babad5a0"></a><!-- doxytag: member="HxSpatialData::m_dataWindowMin" ref="6a9a480a633455fb6cdc4ae9babad5a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_hx_spatial_data.html#6a9a480a633455fb6cdc4ae9babad5a0">HxSpatialData::m_dataWindowMin</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ae354085b7abf47bfab3f32c06672c25"></a><!-- doxytag: member="HxSpatialData::m_dataWindowMax" ref="ae354085b7abf47bfab3f32c06672c25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_hx_spatial_data.html#ae354085b7abf47bfab3f32c06672c25">HxSpatialData::m_dataWindowMax</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cf934507ef1455d18011b47e49d66406"></a><!-- doxytag: member="HxSpatialData::m_histogramDataMin" ref="cf934507ef1455d18011b47e49d66406" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_hx_spatial_data.html#cf934507ef1455d18011b47e49d66406">HxSpatialData::m_histogramDataMin</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="27f848e0a35e9d4467f0b688ca74b09d"></a><!-- doxytag: member="HxSpatialData::m_histogramDataMax" ref="27f848e0a35e9d4467f0b688ca74b09d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_hx_spatial_data.html#27f848e0a35e9d4467f0b688ca74b09d">HxSpatialData::m_histogramDataMax</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="37992a2de25efbd87d6377061fc7f3a5"></a><!-- doxytag: member="HxSpatialData::transform" ref="37992a2de25efbd87d6377061fc7f3a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoTransform* <a class="el" href="class_hx_spatial_data.html#37992a2de25efbd87d6377061fc7f3a5">HxSpatialData::transform</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ddf6781a764b3b46a0f34cbeaae2dfc0"></a><!-- doxytag: member="HxSpatialData::transformSensor" ref="ddf6781a764b3b46a0f34cbeaae2dfc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoNodeSensor* <a class="el" href="class_hx_spatial_data.html#ddf6781a764b3b46a0f34cbeaae2dfc0">HxSpatialData::transformSensor</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e935a824328cfb9d31651750ed3814ec"></a><!-- doxytag: member="HxSpatialData::m_histogramWorker" ref="e935a824328cfb9d31651750ed3814ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_qx_histogram_worker.html">QxHistogramWorker</a>* <a class="el" href="class_hx_spatial_data.html#e935a824328cfb9d31651750ed3814ec">HxSpatialData::m_histogramWorker</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b9558a5ec748d52348ee45cd6f8457c7"></a><!-- doxytag: member="HxSpatialData::mHasTransform" ref="b9558a5ec748d52348ee45cd6f8457c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_hx_spatial_data.html#b9558a5ec748d52348ee45cd6f8457c7">HxSpatialData::mHasTransform</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>hxcore/<a class="el" href="hxcore_2_hx_spatial_data_8h.html">HxSpatialData.h</a></ul>
<hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
