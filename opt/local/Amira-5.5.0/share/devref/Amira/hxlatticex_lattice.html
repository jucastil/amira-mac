<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: The Lattice Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1><a class="anchor" name="hxlatticex_Lattice">The Lattice Interface</a></h1>See also <a class="el" href="hxlatticex_latticetech.html">hxlatticex_LatticeTech</a>.<p>
The purpose of this document is to describe the interface to data on a structured grid. In amira this this kind of data is denoted a Lattice.<p>
Several concepts are gathered in a HxLattice interface. The concepts are briefly explained below.<h2><a class="anchor" name="hxlatticex_Lattice_requirements">
Requirements</a></h2>
The interface was designed with the following requirements in mind:<ul>
<li>Separation of implementation and interface<ul>
<li>No direct access to pointers</li><li>Readonly access, Mutable access</li></ul>
</li><li>Backwards compatibility (or simple wrappers) to<ul>
<li><a class="el" href="class_hx_lattice3.html">HxLattice3</a></li><li>HxExternalData</li><li><a class="el" href="class_hx_multi_channel_field.html">HxMultiChannelField</a></li></ul>
</li><li>Support for internal and external data<ul>
<li>Data sets may be larger than main memory</li><li>Hyperslabs</li><li>Multiresolution (Subsampling, Resampling)</li><li>Prefetching/Caching (only to some extent)</li></ul>
</li><li>Support for multiple data sets per lattice<ul>
<li>May be useful for Labels, Weights, Weights2</li><li>May be used to unify access to Data, Positions, Times</li></ul>
</li></ul>
<p>
The following requirements are <b>not</b> part of the current implementation.<ul>
<li>Support for remote data<ul>
<li>Asynchronous/Nonblocking access</li><li>Threaded implementation</li></ul>
</li><li>Threading compatible with Qt<ul>
<li>Qt provides a threadsafe postEvent()</li><li>Calls which trigger signals are only allowed in the main thread --&gt; The user's view is 'single threaded'</li></ul>
</li><li>Simple support for time dependent data when the lattice doesn't change size in different time steps.<ul>
<li>Resampling may be easily extended to resampling in time</li><li>3D is a special case if dims[3] == 1</li></ul>
</li></ul>
<h2><a class="anchor" name="hxlatticex_Lattice_top">
Combinatorical Topology</a></h2>
A lattice has the same combinatorical structure as a multidimensional array. The data values explained below are vertex centered meaning they are located at the point intersections of adjacent voxels.<p>
This fact makes things a little bit intricated. A lattice of size <img class="formulaInl" alt="$ m_d $" src="form_9.png"> in dimension <img class="formulaInl" alt="$ d $" src="form_10.png"> is made up of only <img class="formulaInl" alt="$ m_d - 1 $" src="form_11.png"> elements of dimensionality <img class="formulaInl" alt="$ d $" src="form_10.png"> (voxels) in this dimension.<p>
More formally a lattice has the same combinatorical topology as a grid whose cells in <img class="formulaInl" alt="$ d $" src="form_10.png"> dimensions of size <img class="formulaInl" alt="$ m_1, \ldots, m_d $" src="form_12.png"> are <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \{ [i_1, i+1] \times \ldots \times [i_d, i_d+1] | 0 \leq i_j < m_j - 1\} \]" src="form_13.png">
<p>
<p>
The combinatorical structure is completely known if you know the number of dimensions and the size of each dimension. These informations are available through HxLattice::getDataSpace().<h2><a class="anchor" name="hxlatticex_Lattice_data">
Data Values</a></h2>
Multiple data sets can be stored at each vertex of the lattice, similar to a struct: <div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>latticedata {
        datatype0 set0[ndatavar0];
        datatype1 set1[ndatavar1];
            .
            .                           <span class="comment">/* ndata sets */</span>
            .
    }
</pre></div><p>
The sets are indexed using an integer. The information required to describe the data are available through HxLattice::nDataSets(), HxLattice::dataTypeOfSet(int), HxLattice::nDataVarOfSet(int).<h2><a class="anchor" name="hxlatticex_Lattice_meta">
Meta Data</a></h2>
Each data set also has metadata associated:<ul>
<li>A name HxLattice::getNameOfSet(int)</li><li>A description HxLattice::getDescriptionOfSet(int)</li><li>A range HxLattice::getRangeOfSet, HxLattice::trygetRangeOfSet (see below).</li></ul>
<h2><a class="anchor" name="hxlatticex_Lattice_geometry">
Geometry</a></h2>
To display the data in space and time the geometry of the lattice is needed.<p>
More formally the geometry is a mapping from the combinatorical topology's space to the <img class="formulaInl" alt="$ R^d $" src="form_14.png">. How this mapping is specified is strongly dependent on the details of the mapping. Specifications might be given:<ul>
<li>implicitly, e.g. uniform coordinates from bounding box and size.</li><li>global parameters together with rule, e.g. one dimensional time vector.</li><li>linear geometry, e.g. positions for vertices which are connected by straight lines.</li><li>global mappings, e.g. spherical coordinates.</li><li>per cell parameters, e.g. higher order FE.</li></ul>
<p>
In general only the bounding box can be requested using HxLattice::getBoundingBox().<p>
Mappings are identified using a HxLatticeType which can accessed using HxLattice::latticeType().<p>
All amira lattice types are a combination of implicitly or explicitly given coordinates for the lower dimensions. Coordinates for higher dimensions given by 1 dimensional vectors which can be accessed using the Partially Rectilinear Lattice Geometry Interface, HxPartRectLatticeGeom::getRectPositions(). The positions are connected using straight lines (linear geometry).<p>
The lattice types are detailed below.<h3><a class="anchor" name="hxlatticex_Lattice_c_uniform">
Uniform</a></h3>
For <a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce737115bdb16447e2d4a2b1e55d7286a559">HxLatticeType::c_uniform</a> the positions of the points of the grid are given in dims 0, 1, 2 by the formular <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{q}(i_q) = min_{q} + \frac{max_{q} - min_{q}}{m_{q} - 1} i_q \quad ; \quad 0 \leq i_q < m_q \quad , \quad 0 \leq q \leq 2 \]" src="form_15.png">
<p>
<p>
All higher dimensions are explicitly given by a coordinate vector coords: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{q} (i_q) = coords_{q} [i_q] \quad ; \quad 0 \leq i_q < m_q \quad , \quad 3 \leq q < d \]" src="form_16.png">
<p>
<h3><a class="anchor" name="hxlatticex_Lattice_c_stacked">
Stacked</a></h3>
For <a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce73f9b101be644dd3c27480dcdbef9e5666">HxLatticeType::c_stacked</a> the positions of the points of the grid are given in dims 0, 1 by the formular <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{q}(i_q) = min_{q} + \frac{max_{q} - min_{q}}{m_{q} - 1} i_q \quad ; \quad 0 \leq i_q < m_q \quad , \quad 0 \leq q \leq 1 \]" src="form_17.png">
<p>
<p>
All higher dimensions are explicitly given by a coordinate vector coords: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{q} (i_q) = coords_{q} [i_q] \quad ; \quad 0 \leq i_q < m_q \quad , \quad 2 \leq q < d \]" src="form_18.png">
<p>
<h3><a class="anchor" name="hxlatticex_Lattice_c_rectilinear">
Rectilinear</a></h3>
For <a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce73263c1932363ac239b0965103da68e97a">HxLatticeType::c_rectilinear</a> all dimensions are explicitly given by a coordinate vector coords: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{q} (i_q) = coords_{q} [i_q] \quad ; \quad 0 \leq i_q < m_q \quad , \quad 0 \leq q < d \]" src="form_19.png">
<p>
<h3><a class="anchor" name="hxlatticex_Lattice_c_curvilinear">
Curvilinear</a></h3>
For <a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce7330da36a349804648d464764eb30a1048">HxLatticeType::c_curvilinear</a> the positions are explicitly given for dims 0, 1, 2 through a data set which can be accessed at data set index HxLattice::nDataSets() - 1 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{q}(i_0, i_1, i_2) = coords_{q}[i_0, i_1, i_2] \quad ; \quad 0 \leq q \leq 2 \]" src="form_20.png">
<p>
<p>
All higher dimensions are explicitly given by a coordinate vector coords: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{q} (i_q) = coords_{q} [i_q] \quad ; \quad 0 \leq i_q < m_q \quad , \quad 3 \leq q < d \]" src="form_16.png">
<p>
<h2><a class="anchor" name="hxlatticex_Lattice_access">
Data Access</a></h2>
Two ways for memory management of the accessed data is provided. Either the caller is responsible for providing memory (block I/O) or data is managed by the Lattice (mmapped I/O). Additionally, meta data about the data sets is provided. The relevant methods are listed in the following table.<p>
<div class="fragment"><pre class="fragment">                <span class="comment">/* block io */</span>                 <span class="comment">/* mmapped io */</span>              <span class="comment">/* meta data */</span>
<span class="comment">/*------------------------------------------------------------------------------------------------------*/</span>
<span class="comment">/* sync    */</span>   HxLattice::getDataOfSet()     HxLattice::getHandle()       HxLattice::getRangeOfSet() 
                HxLattice::valueOfSet()       HxLatticeHandle::move()      HxLattice::getNameOfSet()
<span class="comment">/*------------------------------------------------------------------------------------------------------*/</span>
</pre></div><p>
The preferred way is to use mmapped io. This mode allows the HxLattice to optimize memory usage and avoids memory copy operations.<p>
In HxLattice memory mapped IO is available through a HxLatticeHandle. With a call to HxLatticeHandle::move() you indicate which part of the lattice you're requesting. The implementation might start prefetch at this time. It is allowed to freely choose or change the memory layout. Only after a call to HxLatticeHandle::lockReadable() it has to fix the layout and return it until you release the selection by calling HxLatticeHandle::unlock ().<p>
As a convenience to the user, the HxLattice also provides a way to write data into an user defined buffer (HxLattice::getDataOfSet()). This is the deprecated way of using the HxLattice but it may be a very convenient way because you can choose the memory layout which may ease processing. If you're planning to copy the data anyway then HxLattice::getData is preferred to using HxLatticeHandle and performing the copy manually. Using HxLattice::getDataOfSet directly might prevent the system from allocating own buffers.<h3><a class="anchor" name="hxlatticex_Lattice_mempattern">
Memory Patterns</a></h3>
The location of data in memory is described using a <a class="el" href="class_mc_memory_selection.html">McMemorySelection</a>.<p>
<b>Note: the following text may be outdated.</b><p>
We're dealing with multidimensional datasets. These datasets, or parts of them could be located on disk, on a server or in main memory. The class which is used to describe the size of the dataset and a selection in it is <a class="el" href="class_mc_data_space.html">McDataSpace</a>. It doesnt require to have local memory attached. It provides as simplified version of hyperslabs similar to those in hdf5 (see <a href="http://hdf.ncsa.uiuc.edu/HDF5/doc/H5.intro.html#Intro-PMSelectHyper">http://hdf.ncsa.uiuc.edu/HDF5/doc/H5.intro.html#Intro-PMSelectHyper</a>).<p>
If you need access to the data they'll have to be transfered into main memory. A preferred way to do this when using parts of large files is to use memory mapped IO (mmap) instead of standard read/write IO (open, read, write). The main advantage is that the system (operating system, amira) deals with the memory management and can use this freedom (might be a burdon) to implement caching, prefetching and similar things.<p>
The pysical memory is 1D memory. Normal IO only deals with getting contigous parts out of a larger 1D array which makes things rather simple compared to a multidimensional case. Non overlapping but adjacent blocks of memory can easily be managed in a cache to form one larger contigous part of 1D memory. This is not the case in higher dimensions. Dependent on the array order it might be the case (requesting two blocks adjacent in z might be joined to one large block in z) or not (requesting two block adjacent in any other direction can not be joined without changing the layout of the first block).<p>
Another example: Assume a 1D array (char* buf, int size). 'Mapping' the part starting at start (int) with selsize (int) is simply done by some pointer arithmetic yielding the resulting array (buf + start, selsize). The mapping is trivial. Trying to do the same on a 2D array (char* buf, (sizex, sizey)) fails. There's no way to return a simple 2D array for any other selection than the whole array. But if you give some more freedom to the system it will be able to do the job. If you select ((startx, starty), (selx, sely)) the first element of your selection will be at buf + starty * sizex + startx. The next element in x will be at the next position but the next element in y will not be selx elements further but sizex elements. Additionaly to the pointer to the selection the system has to return the offsets describing the distances to the next elements for all dimensions. This is what a <a class="el" href="class_mc_memory_selection.html">McMemorySelection</a> does. The complete array can be described by a McMemoryDataspace. After selecting a part from it a <a class="el" href="class_mc_memory_selection.html">McMemorySelection</a> is the way to only describe this part.<p>
Using <a class="el" href="class_mc_memory_selection.html">McMemorySelection</a> is harder than expecting simple multidimensional arrays but it gives the freedom to the system to use mapped IO instead of copying data. Selecting parts from a large array available completely in memory is done with pointer arithmetic. Selecting parts from an array residing on disk allows the system to freely choose the layout of a cache and returning a part of it in a <a class="el" href="class_mc_memory_selection.html">McMemorySelection</a>. <hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
