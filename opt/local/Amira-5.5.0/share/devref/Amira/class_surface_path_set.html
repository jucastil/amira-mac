<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: SurfacePathSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>SurfacePathSet Class Reference<br>
<small>
[<a class="el" href="group__hxsurfacepath.html">hxsurfacepath</a>]</small>
</h1><!-- doxytag: class="SurfacePathSet" -->This class implements a data structure representing a path on a surface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;hxsurfacepath/SurfacePathSet.h&gt;</code>
<p>
<p>Inheritance diagram for SurfacePathSet:
<p><center><img src="class_surface_path_set.png" usemap="#SurfacePathSet_map" border="0" alt=""></center>
<map name="SurfacePathSet_map">
<area href="class_hx_surface_path_set.html" alt="HxSurfacePathSet" shape="rect" coords="0,56,115,80">
</map>
<a href="class_surface_path_set-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#a8e74644c55853521d42e0fccfd6a3b7">SurfacePathSet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a8e74644c55853521d42e0fccfd6a3b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#046af6fa60bc4897cd6a4f627f18dbd9">~SurfacePathSet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#046af6fa60bc4897cd6a4f627f18dbd9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_surface_path_set_1_1_surface_path.html">SurfacePath</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#126c4175b2215b598b3ff8143ab9151d">operator[]</a> (int index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const index operator to single path.  <a href="#126c4175b2215b598b3ff8143ab9151d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_vec3f.html">McVec3f</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#08bb0343c818159488d51fff445defca">getCoords</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointer to vertex coordinates.  <a href="#08bb0343c818159488d51fff445defca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface_node.html">SurfaceNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#42b1e151d19aad982795cc6365c43e61">getNode</a> (int index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointer to node with <code>index</code>.  <a href="#42b1e151d19aad982795cc6365c43e61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#b004140f72092992b20455ebbef0801b">getNodeIndex</a> (<a class="el" href="class_surface_node.html">SurfaceNode</a> *node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the given node in the node array.  <a href="#b004140f72092992b20455ebbef0801b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#e34017a671fd372731e35654ebcc1f2d">getNodeIndex</a> (int path, int node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of node in the nodes array, which is on position <code>node</code> of <code>path</code>.  <a href="#e34017a671fd372731e35654ebcc1f2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#4530cd754cc3fbf0146dcfe4fa409b74">getPathNodeIndex</a> (int path, <a class="el" href="class_surface_node.html">SurfaceNode</a> *node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the given node in the path nodes array.  <a href="#4530cd754cc3fbf0146dcfe4fa409b74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#4bd40ac6ed611d585a16573d99ab1e95">isPureSurfaceVertexPath</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is every node in the object referred to by <code>theOwner</code> a vertex-node?  <a href="#4bd40ac6ed611d585a16573d99ab1e95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#c5494c5630f6f651b0f6ce316899de5d">vertex</a> (int path, int node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the surface vertex for path <code>path</code> and node <code>node</code>, if path is purely vertex-path.  <a href="#c5494c5630f6f651b0f6ce316899de5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#08d32c3880d2b001335e437d742b17a0">getPath</a> (int path, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pathData) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the path given in argument <code>path</code> as an array of path nodes.  <a href="#08d32c3880d2b001335e437d742b17a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#cecb6308e89299459ab8a744b4f83c64">getSurfNodePath</a> (int path, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_handle.html">McHandle</a>&lt; <a class="el" href="class_surface_node.html">SurfaceNode</a> &gt; &gt; &amp;pathData) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the path given in argument <code>path</code> as an array of surface nodes.  <a href="#cecb6308e89299459ab8a744b4f83c64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface_node.html">SurfaceNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#fd1d81d5ad7cdc8af38a6c4660cdd4e5">getSurfaceNode</a> (int path, int node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns node of given path.  <a href="#fd1d81d5ad7cdc8af38a6c4660cdd4e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface.html">Surface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#8408133ab7fcdb711375ec3ae73400d3">getSurface</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointer to surface the path is defined on.  <a href="#8408133ab7fcdb711375ec3ae73400d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#b6be66362579766b7a130727ee1050cc">isConsistent</a> (bool verbose=true, int *badNode=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether paths match surface.  <a href="#b6be66362579766b7a130727ee1050cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#02f6834d282bca5e4137e473ea8fe82d">getNumControlPointsOnPath</a> (int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of control points on given path.  <a href="#02f6834d282bca5e4137e473ea8fe82d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#b7d4bb50d168936f3fdd9fab3fe4202d">isPathClosed</a> (int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether path is closed.  <a href="#b7d4bb50d168936f3fdd9fab3fe4202d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#db42613ab8738c30f09b052a54cbdde2">isEmpty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether path set contains any paths.  <a href="#db42613ab8738c30f09b052a54cbdde2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#ad69be4a4ce1006371928991a549fe8a">isPathEmpty</a> (int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether path with index <code>path</code> is empty.  <a href="#ad69be4a4ce1006371928991a549fe8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#e980221334492514cb4148766024c787">getFirstNodeIndexOnPath</a> (int path, int node) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the first occurrence of <code>node</code> in <code>path</code>, -1 otherwise.  <a href="#e980221334492514cb4148766024c787"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#d6a960552980785a06ccf151156018d6">getNumNodesOnPath</a> (int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of nodes on <code>path</code>.  <a href="#d6a960552980785a06ccf151156018d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#c37c3e9765bab94b519bcb46602149cf">getCPIndexOnPath</a> (int cp, int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of control points (CP) on path before control point <code>cp</code>.  <a href="#c37c3e9765bab94b519bcb46602149cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#60c65d942d86bb8140b64fbfa10520ad">getIndexOfIthCP</a> (int cpIdx, int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the node index in the path nodes array of the control point with index <code>cpIdx</code>.  <a href="#60c65d942d86bb8140b64fbfa10520ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#8ea293af50599bf41c42a8cb73c5b023">getPathForNode</a> (int nodeIndex) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the path that contains the node with index <code>nodeIndex</code>.  <a href="#8ea293af50599bf41c42a8cb73c5b023"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#6f51fb2a5b4f939403a42ab33d4ab47d">getPathLength</a> (int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns path length.  <a href="#6f51fb2a5b4f939403a42ab33d4ab47d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#737de39157ce21e1a9ea1fab51a5c832">getNumNodes</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns total number of path nodes.  <a href="#737de39157ce21e1a9ea1fab51a5c832"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#8c3a2368bd6b055d35771608e048908f">getNumPaths</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns total number of paths.  <a href="#8c3a2368bd6b055d35771608e048908f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface_node.html">SurfaceNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#d88e83205310f4b3db47b425df7db09d">getLastSurfaceNode</a> (int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns last node on given path.  <a href="#d88e83205310f4b3db47b425df7db09d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#c1960a039f4bc01e906303dd557633a5">getPrevControlPoint</a> (int path, int idx) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns index of previous editable control point in path.  <a href="#c1960a039f4bc01e906303dd557633a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#a4ef8b3219f95ae8fdd384a2defdec37">getNextControlPoint</a> (int path, int idx) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns index of next editable control point in path.  <a href="#a4ef8b3219f95ae8fdd384a2defdec37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#45cb4a1ed5744ee89748e41b8cad9daa">getNumControlPoints</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of control points in the <a class="el" href="class_surface_path_set.html">SurfacePathSet</a>.  <a href="#45cb4a1ed5744ee89748e41b8cad9daa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#7d74e80024ade8d55ee1e7ff6dbfec07">getTangent</a> (int path, int idx, <a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;tangent) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes tangent at path node (always points along path indexing).  <a href="#7d74e80024ade8d55ee1e7ff6dbfec07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#73ce64b36361acfce495c7cd0fabdf65">getNodeIndexOnPath</a> (int path, int nodeIdx) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns index of node <code>nodeIdx</code> in the path nodes array of <code>path</code>.  <a href="#73ce64b36361acfce495c7cd0fabdf65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#a104415a7358481d76fbd5580a05a7c2">getNumPathsForNode</a> (int nodeIdx) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of paths, a node belongs to.  <a href="#a104415a7358481d76fbd5580a05a7c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#7fd844582e86028efe5b6781036a5044">getNumEntangledNodes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of entangled nodes.  <a href="#7fd844582e86028efe5b6781036a5044"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#03318c598de2ece3a1da4427bc5c22ac">boundingBox</a> (<a class="el" href="class_mc_box3f.html">McBox3f</a> &amp;bb) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes bounding box from coordinates.  <a href="#03318c598de2ece3a1da4427bc5c22ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#4d0ad0c5ce63f5625257243ce5c7fc3d">isInnerPathNodeIdx</a> (int pathNodeIdx, int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if index <code>nodeIdx</code> in paths.nodes array is an inner node, meaning it is not a first and nor a last idx.  <a href="#4d0ad0c5ce63f5625257243ce5c7fc3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#dcbc57f7685943135c1c58c115a5f389">isInnerNodeIdx</a> (int nodeIdx, int path) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if index <code>nodeIdx</code> in nodes array is an inner node, meaning it is not a first and nor a last idx.  <a href="#dcbc57f7685943135c1c58c115a5f389"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#7fd42bace18d3a3935b5ab94e396a6f2">getAllPathsContainingNode</a> (int nodeIdx, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pathsCN, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;idxInPaths) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collects all paths that contain given node, and an array with pathnodeIdx.  <a href="#7fd42bace18d3a3935b5ab94e396a6f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#0d32c144a2bdf9c2e85b446e66217e89">getAllPathsContainingNode</a> (int nodeIdx, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pathsCN) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collects all paths that contain given node.  <a href="#0d32c144a2bdf9c2e85b446e66217e89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#564493b0ae1a9b7e4a1cb0c4ed41caff">getAllPathsContainingInnerNode</a> (int nodeIdx, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pathsCN) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collects all paths that contain given node but not at first or last index.  <a href="#564493b0ae1a9b7e4a1cb0c4ed41caff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#7f99c76f81f13ea6eb644e6f78ad8142">getInnerPathNodesIdxAlsoInOtherPaths</a> (int pathIdx, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;allNodesThatAreAlsoInOtherPAths) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collects all inner nodes of path <code>pathIdx</code> that are also contained in other paths.  <a href="#7f99c76f81f13ea6eb644e6f78ad8142"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#85f69d64701dc6d4e8d20f20b73de23c">getAllInnerEntangledPaths</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;allInnerEntagelPaths) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collects all paths that are entangled, but not paths that are only entangled on first or last point.  <a href="#85f69d64701dc6d4e8d20f20b73de23c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#b0e8b342c2534c640b4b80eae96ebcbf">getAllEntangledPaths</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;allEntagelPaths) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collect all paths that are entangled.  <a href="#b0e8b342c2534c640b4b80eae96ebcbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#604d1b242f54f0a0b40458542c492f16">getInnerCrossedNodeIdxOfPath</a> (int pathIdx, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;allInnerNodeIdx, float mTol) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#4722f3e8aea9bcea8b6ed1bac7bffd9f">getInnerCrossedPaths</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;allInnerEntagelPaths, float mTol=1.e-3) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collects all paths that are crossed from other paths (crossings at first or last point noticed if one of the crossings is inner).  <a href="#4722f3e8aea9bcea8b6ed1bac7bffd9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#489c391e8571d9599bcbd9abba551c9d">getCrossedPaths</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;allEntagelPaths, float mTol=1.e-3) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collects all paths that are crossed from other paths (crossings at first or last point are noticed).  <a href="#489c391e8571d9599bcbd9abba551c9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#15d5b7395c87865662aa7c17d19234bf">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the path-array.  <a href="#15d5b7395c87865662aa7c17d19234bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#7617d2afdf9e03b9e8bffe7262427ff4">cleanup</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes unused points or empty lines.  <a href="#7617d2afdf9e03b9e8bffe7262427ff4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#7fde15a46b6ce1ebb0880f4db6f4100e">removeDuplicateNodes</a> (float tol=1.e-6, int mode=SurfaceNodeFactory::BARY_TOL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for duplicate points.  <a href="#7fde15a46b6ce1ebb0880f4db6f4100e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#7433e4ccd4d5b6b55e31463fc7200e97">removeInteriorNodes</a> (int pathIdx, int removeControlPoints=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes interior triangle and duplicate edge/vertex nodes.  <a href="#7433e4ccd4d5b6b55e31463fc7200e97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#5a6a4ed3cc7ace6eef619bc2e16685a3">copyData</a> (const <a class="el" href="class_surface_path_set.html">SurfacePathSet</a> &amp;other, <a class="el" href="class_surface.html">Surface</a> *surface=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data, possibly attach to new surface (yet with same connectivity!).  <a href="#5a6a4ed3cc7ace6eef619bc2e16685a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#d41a60b9d9f1976a853f192439222d4e">untangle</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collapses shared pathnodes to single node.  <a href="#d41a60b9d9f1976a853f192439222d4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#25b9e6d891e269b94c04f97030e04172">untangle</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;selectedPaths)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply shared pathnodes.  <a href="#25b9e6d891e269b94c04f97030e04172"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#62660fb6b92fdbc7fb762a931e6b7bd4">importContours</a> (<a class="el" href="class_surface.html">Surface</a> *surface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses contours from <code>surface</code> and creates a corresponding vertex pathset.  <a href="#62660fb6b92fdbc7fb762a931e6b7bd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#b36999c4dbf84f529d916aeb731774bf">setSurface</a> (<a class="el" href="class_surface.html">Surface</a> *surface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes pointer to surface for all nodes.  <a href="#b36999c4dbf84f529d916aeb731774bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#e6f85d9c57e8c3f02337290b48167297">addPath</a> (int n, int *whichPoints, int pos=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new path to the path set.  <a href="#e6f85d9c57e8c3f02337290b48167297"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#e1c0a0a99b4fed198b45607f6645edbd">removePathVertex</a> (int p, int vertex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes <code>vertex</code> of <code>path</code>.  <a href="#e1c0a0a99b4fed198b45607f6645edbd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#9376121927d4aeffda6c2e07dd6a741f">addPathVertex</a> (int p, int v, int pos=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an additional vertex to path <code>p</code>.  <a href="#9376121927d4aeffda6c2e07dd6a741f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface_path_set_1_1_surface_path.html">SurfacePath</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#bb7e2b8451496de49acba17a64ce6ff8">operator[]</a> (int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index operator to single path.  <a href="#bb7e2b8451496de49acba17a64ce6ff8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface_path_set.html">SurfacePathSet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#ee42a47a3437330b41d82fbe6ba13f4e">operator=</a> (const <a class="el" href="class_surface_path_set.html">SurfacePathSet</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#ee42a47a3437330b41d82fbe6ba13f4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#913996c3da554c66e1895de4b83dea5b">rotateClosedPath</a> (int path, int idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotates closed path so that idx becomes 0.  <a href="#913996c3da554c66e1895de4b83dea5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#bc8ba1f5d92cd2fc14eb35e7bedd108e">removeIntermediateNodesFromPath</a> (int pathID, int pathIndex1, int pathIndex2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This Method removes all nodes from a path between pathIndex1 and pathIndex2, regardless of whether they are controlPoints, or not.  <a href="#bc8ba1f5d92cd2fc14eb35e7bedd108e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#9ddb24ee07946bfd13725c598ba82815">connectSurfaceNodes</a> (int pathId, int index1, int index2, <a class="el" href="class_path_connector.html">PathConnector</a> *connector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method computes a path between the node on <code>index1</code> and <code>index2</code> on the path and inserts the found nodes after index1 on the path.  <a href="#9ddb24ee07946bfd13725c598ba82815"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#65853260e786eeb065997bc43b2c06b7">makePath</a> (<a class="el" href="class_surface.html">Surface</a> *surface, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;vertices)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create path from given vertex chain.  <a href="#65853260e786eeb065997bc43b2c06b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#574a0f6c324191a8c5271d2f01e9a8c2">addVertexToPath</a> (<a class="el" href="class_surface.html">Surface</a> *surface, int vertex, int path, bool isControlPoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds new vertex to given path.  <a href="#574a0f6c324191a8c5271d2f01e9a8c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#1dd95552c6ffc5428dfedc56f2f9a2d8">removeStandAloneNodes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes paths that consists of only one node.  <a href="#1dd95552c6ffc5428dfedc56f2f9a2d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#aee5e50ab2acc1309adfe3759bf311ec">sortPathsByLength</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts paths according to their euclidean length in ascending order.  <a href="#aee5e50ab2acc1309adfe3759bf311ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#4053cf58f864f83c1d83f365e843bcfd">updateCoords</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update 3d coordinates.  <a href="#4053cf58f864f83c1d83f365e843bcfd"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#03a66361b556832d60532d89279a26ff">compareID</a> (const <a class="el" href="class_mc_handle.html">McHandle</a>&lt; <a class="el" href="class_surface_path_set_1_1_indexed_surface_node.html">IndexedSurfaceNode</a> &gt; &amp;node1, const <a class="el" href="class_mc_handle.html">McHandle</a>&lt; <a class="el" href="class_surface_path_set_1_1_indexed_surface_node.html">IndexedSurfaceNode</a> &gt; &amp;node2)</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_surface_path_set_1_1_surface_path.html">SurfacePath</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#48845858c28969aa18f06de5ff6ce5dc">paths</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The paths of the path set.  <a href="#48845858c28969aa18f06de5ff6ce5dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_handle.html">McHandle</a>&lt; <a class="el" href="class_surface_node.html">SurfaceNode</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#e2ac8da38871215b32fde5664a3a5249">nodes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All nodes of the path set, stored per path.  <a href="#e2ac8da38871215b32fde5664a3a5249"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_surface_node_factory.html">SurfaceNodeFactory</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#7a178cdce042acff9b55a1aa83455963">nFactory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_surface.html">Surface</a> node factory, which creates new nodes.  <a href="#7a178cdce042acff9b55a1aa83455963"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#53aac647b3da5012b6625c1f6c896abc">getSelfIntersections</a> (int path, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;splitPositions)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shows self-intersections in the following manner: anywhere where path-segments begin or end to self-intersect, a split position is appended at the end of <code>splitPositions</code>.  <a href="#53aac647b3da5012b6625c1f6c896abc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#c29b69795a7ec93c89575de7aa5eeb94">isSubArray</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;word1, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;word2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if <code>word1</code> is contained as a subsequence in <code>word2</code>.  <a href="#c29b69795a7ec93c89575de7aa5eeb94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#b73cdd6452c757b267f1811a4d4bfee9">compute_prefix</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;word, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;pi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the prefix for the KMP-matching-algorithm used in <a class="el" href="class_surface_path_set.html#c29b69795a7ec93c89575de7aa5eeb94">isSubArray()</a>.  <a href="#b73cdd6452c757b267f1811a4d4bfee9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_vec3f.html">McVec3f</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set.html#af8c24c56fa03b2891ca52d10b820a6e">coords</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set_1_1_indexed_surface_node.html">IndexedSurfaceNode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_surface_node.html">SurfaceNode</a> whose index points into the <a class="el" href="class_surface_path_set.html#e2ac8da38871215b32fde5664a3a5249">SurfacePathSet::nodes</a> array.  <a href="class_surface_path_set_1_1_indexed_surface_node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set_1_1_path_length.html">PathLength</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements functionality to compute the length of a path and stores the respective information in member variables.  <a href="class_surface_path_set_1_1_path_length.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface_path_set_1_1_surface_path.html">SurfacePath</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclass representing a single path.  <a href="class_surface_path_set_1_1_surface_path.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class implements a data structure representing a path on a surface. 
<p>
Such a path consists of <code>SurfaceNodes</code> that form a <code><a class="el" href="class_surface_path_set_1_1_surface_path.html">SurfacePathSet::SurfacePath</a></code>. A <a class="el" href="class_surface_path_set.html">SurfacePathSet</a> is a set of such paths. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a8e74644c55853521d42e0fccfd6a3b7"></a><!-- doxytag: member="SurfacePathSet::SurfacePathSet" ref="a8e74644c55853521d42e0fccfd6a3b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurfacePathSet::SurfacePathSet           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="046af6fa60bc4897cd6a4f627f18dbd9"></a><!-- doxytag: member="SurfacePathSet::~SurfacePathSet" ref="046af6fa60bc4897cd6a4f627f18dbd9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SurfacePathSet::~SurfacePathSet           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="03a66361b556832d60532d89279a26ff"></a><!-- doxytag: member="SurfacePathSet::compareID" ref="03a66361b556832d60532d89279a26ff" args="(const McHandle&lt; IndexedSurfaceNode &gt; &amp;node1, const McHandle&lt; IndexedSurfaceNode &gt; &amp;node2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SurfacePathSet::compareID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_handle.html">McHandle</a>&lt; <a class="el" href="class_surface_path_set_1_1_indexed_surface_node.html">IndexedSurfaceNode</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_handle.html">McHandle</a>&lt; <a class="el" href="class_surface_path_set_1_1_indexed_surface_node.html">IndexedSurfaceNode</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>node2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="126c4175b2215b598b3ff8143ab9151d"></a><!-- doxytag: member="SurfacePathSet::operator[]" ref="126c4175b2215b598b3ff8143ab9151d" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_surface_path_set_1_1_surface_path.html">SurfacePath</a>&amp; SurfacePathSet::operator[]           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Const index operator to single path. 
<p>

</div>
</div><p>
<a class="anchor" name="08bb0343c818159488d51fff445defca"></a><!-- doxytag: member="SurfacePathSet::getCoords" ref="08bb0343c818159488d51fff445defca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_vec3f.html">McVec3f</a>* SurfacePathSet::getCoords           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns pointer to vertex coordinates. 
<p>

<p>
Reimplemented in <a class="el" href="class_hx_surface_path_set.html#82f887586e3e93db130f2fc728875b59">HxSurfacePathSet</a>.
</div>
</div><p>
<a class="anchor" name="42b1e151d19aad982795cc6365c43e61"></a><!-- doxytag: member="SurfacePathSet::getNode" ref="42b1e151d19aad982795cc6365c43e61" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface_node.html">SurfaceNode</a>* SurfacePathSet::getNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns pointer to node with <code>index</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="b004140f72092992b20455ebbef0801b"></a><!-- doxytag: member="SurfacePathSet::getNodeIndex" ref="b004140f72092992b20455ebbef0801b" args="(SurfaceNode *node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNodeIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_surface_node.html">SurfaceNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the given node in the node array. 
<p>

</div>
</div><p>
<a class="anchor" name="e34017a671fd372731e35654ebcc1f2d"></a><!-- doxytag: member="SurfacePathSet::getNodeIndex" ref="e34017a671fd372731e35654ebcc1f2d" args="(int path, int node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNodeIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of node in the nodes array, which is on position <code>node</code> of <code>path</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="4530cd754cc3fbf0146dcfe4fa409b74"></a><!-- doxytag: member="SurfacePathSet::getPathNodeIndex" ref="4530cd754cc3fbf0146dcfe4fa409b74" args="(int path, SurfaceNode *node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getPathNodeIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_surface_node.html">SurfaceNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the given node in the path nodes array. 
<p>

</div>
</div><p>
<a class="anchor" name="4bd40ac6ed611d585a16573d99ab1e95"></a><!-- doxytag: member="SurfacePathSet::isPureSurfaceVertexPath" ref="4bd40ac6ed611d585a16573d99ab1e95" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::isPureSurfaceVertexPath           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is every node in the object referred to by <code>theOwner</code> a vertex-node? 
<p>
Returns false if there exists a non-vertex-node currently referenced in <a class="el" href="class_surface_path_set.html">SurfacePathSet</a>, and true if all nodes are vertex-nodes. 
</div>
</div><p>
<a class="anchor" name="c5494c5630f6f651b0f6ce316899de5d"></a><!-- doxytag: member="SurfacePathSet::vertex" ref="c5494c5630f6f651b0f6ce316899de5d" args="(int path, int node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::vertex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the surface vertex for path <code>path</code> and node <code>node</code>, if path is purely vertex-path. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>surface-vertexId for <code>path's</code> <code>nodes'</code> node<br>
 -1 is surface is null<br>
 -2 if <code>path</code> is out of bounds<br>
 -3 if <code>node</code> is out of bounds </dd></dl>

</div>
</div><p>
<a class="anchor" name="08d32c3880d2b001335e437d742b17a0"></a><!-- doxytag: member="SurfacePathSet::getPath" ref="08d32c3880d2b001335e437d742b17a0" args="(int path, McDArray&lt; int &gt; &amp;pathData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::getPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pathData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the path given in argument <code>path</code> as an array of path nodes. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if path exists, false otherwise. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Index</em>&nbsp;</td><td>of path for which path nodes are returned. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Array</em>&nbsp;</td><td>of path nodes on <code>path</code>. The path nodes are appended to the <code>pathData</code> array.</td></tr>
  </table>
</dl>
An empty array is returned in case surface attached to <a class="el" href="class_surface_path_set.html">SurfacePathSet</a> is null or <code>path</code> is out of bounds 
</div>
</div><p>
<a class="anchor" name="cecb6308e89299459ab8a744b4f83c64"></a><!-- doxytag: member="SurfacePathSet::getSurfNodePath" ref="cecb6308e89299459ab8a744b4f83c64" args="(int path, McDArray&lt; McHandle&lt; SurfaceNode &gt; &gt; &amp;pathData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::getSurfNodePath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_handle.html">McHandle</a>&lt; <a class="el" href="class_surface_node.html">SurfaceNode</a> &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pathData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the path given in argument <code>path</code> as an array of surface nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="fd1d81d5ad7cdc8af38a6c4660cdd4e5"></a><!-- doxytag: member="SurfacePathSet::getSurfaceNode" ref="fd1d81d5ad7cdc8af38a6c4660cdd4e5" args="(int path, int node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface_node.html">SurfaceNode</a>* SurfacePathSet::getSurfaceNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns node of given path. 
<p>

</div>
</div><p>
<a class="anchor" name="8408133ab7fcdb711375ec3ae73400d3"></a><!-- doxytag: member="SurfacePathSet::getSurface" ref="8408133ab7fcdb711375ec3ae73400d3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface.html">Surface</a>* SurfacePathSet::getSurface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns pointer to surface the path is defined on. 
<p>

<p>
Reimplemented in <a class="el" href="class_hx_surface_path_set.html#3dfd84e65be6c13f16fd560cca3b9fa1">HxSurfacePathSet</a>.
</div>
</div><p>
<a class="anchor" name="b6be66362579766b7a130727ee1050cc"></a><!-- doxytag: member="SurfacePathSet::isConsistent" ref="b6be66362579766b7a130727ee1050cc" args="(bool verbose=true, int *badNode=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::isConsistent           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>verbose</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>badNode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether paths match surface. 
<p>
Returns index of first inconsistent node. 
</div>
</div><p>
<a class="anchor" name="02f6834d282bca5e4137e473ea8fe82d"></a><!-- doxytag: member="SurfacePathSet::getNumControlPointsOnPath" ref="02f6834d282bca5e4137e473ea8fe82d" args="(int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNumControlPointsOnPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns number of control points on given path. 
<p>

</div>
</div><p>
<a class="anchor" name="b7d4bb50d168936f3fdd9fab3fe4202d"></a><!-- doxytag: member="SurfacePathSet::isPathClosed" ref="b7d4bb50d168936f3fdd9fab3fe4202d" args="(int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::isPathClosed           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether path is closed. 
<p>

</div>
</div><p>
<a class="anchor" name="db42613ab8738c30f09b052a54cbdde2"></a><!-- doxytag: member="SurfacePathSet::isEmpty" ref="db42613ab8738c30f09b052a54cbdde2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::isEmpty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether path set contains any paths. 
<p>

</div>
</div><p>
<a class="anchor" name="ad69be4a4ce1006371928991a549fe8a"></a><!-- doxytag: member="SurfacePathSet::isPathEmpty" ref="ad69be4a4ce1006371928991a549fe8a" args="(int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::isPathEmpty           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether path with index <code>path</code> is empty. 
<p>

</div>
</div><p>
<a class="anchor" name="e980221334492514cb4148766024c787"></a><!-- doxytag: member="SurfacePathSet::getFirstNodeIndexOnPath" ref="e980221334492514cb4148766024c787" args="(int path, int node) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getFirstNodeIndexOnPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the first occurrence of <code>node</code> in <code>path</code>, -1 otherwise. 
<p>

</div>
</div><p>
<a class="anchor" name="d6a960552980785a06ccf151156018d6"></a><!-- doxytag: member="SurfacePathSet::getNumNodesOnPath" ref="d6a960552980785a06ccf151156018d6" args="(int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNumNodesOnPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of nodes on <code>path</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="c37c3e9765bab94b519bcb46602149cf"></a><!-- doxytag: member="SurfacePathSet::getCPIndexOnPath" ref="c37c3e9765bab94b519bcb46602149cf" args="(int cp, int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getCPIndexOnPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of control points (CP) on path before control point <code>cp</code>. 
<p>
Returns -1 if cp not on path. 
</div>
</div><p>
<a class="anchor" name="60c65d942d86bb8140b64fbfa10520ad"></a><!-- doxytag: member="SurfacePathSet::getIndexOfIthCP" ref="60c65d942d86bb8140b64fbfa10520ad" args="(int cpIdx, int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getIndexOfIthCP           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cpIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the node index in the path nodes array of the control point with index <code>cpIdx</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="8ea293af50599bf41c42a8cb73c5b023"></a><!-- doxytag: member="SurfacePathSet::getPathForNode" ref="8ea293af50599bf41c42a8cb73c5b023" args="(int nodeIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getPathForNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the path that contains the node with index <code>nodeIndex</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="6f51fb2a5b4f939403a42ab33d4ab47d"></a><!-- doxytag: member="SurfacePathSet::getPathLength" ref="6f51fb2a5b4f939403a42ab33d4ab47d" args="(int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SurfacePathSet::getPathLength           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns path length. 
<p>

</div>
</div><p>
<a class="anchor" name="737de39157ce21e1a9ea1fab51a5c832"></a><!-- doxytag: member="SurfacePathSet::getNumNodes" ref="737de39157ce21e1a9ea1fab51a5c832" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNumNodes           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns total number of path nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="8c3a2368bd6b055d35771608e048908f"></a><!-- doxytag: member="SurfacePathSet::getNumPaths" ref="8c3a2368bd6b055d35771608e048908f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNumPaths           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns total number of paths. 
<p>

</div>
</div><p>
<a class="anchor" name="d88e83205310f4b3db47b425df7db09d"></a><!-- doxytag: member="SurfacePathSet::getLastSurfaceNode" ref="d88e83205310f4b3db47b425df7db09d" args="(int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface_node.html">SurfaceNode</a>* SurfacePathSet::getLastSurfaceNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns last node on given path. 
<p>

</div>
</div><p>
<a class="anchor" name="c1960a039f4bc01e906303dd557633a5"></a><!-- doxytag: member="SurfacePathSet::getPrevControlPoint" ref="c1960a039f4bc01e906303dd557633a5" args="(int path, int idx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getPrevControlPoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns index of previous editable control point in path. 
<p>

</div>
</div><p>
<a class="anchor" name="a4ef8b3219f95ae8fdd384a2defdec37"></a><!-- doxytag: member="SurfacePathSet::getNextControlPoint" ref="a4ef8b3219f95ae8fdd384a2defdec37" args="(int path, int idx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNextControlPoint           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns index of next editable control point in path. 
<p>

</div>
</div><p>
<a class="anchor" name="45cb4a1ed5744ee89748e41b8cad9daa"></a><!-- doxytag: member="SurfacePathSet::getNumControlPoints" ref="45cb4a1ed5744ee89748e41b8cad9daa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNumControlPoints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of control points in the <a class="el" href="class_surface_path_set.html">SurfacePathSet</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="7d74e80024ade8d55ee1e7ff6dbfec07"></a><!-- doxytag: member="SurfacePathSet::getTangent" ref="7d74e80024ade8d55ee1e7ff6dbfec07" args="(int path, int idx, McVec3f &amp;tangent) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::getTangent           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tangent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes tangent at path node (always points along path indexing). 
<p>

</div>
</div><p>
<a class="anchor" name="73ce64b36361acfce495c7cd0fabdf65"></a><!-- doxytag: member="SurfacePathSet::getNodeIndexOnPath" ref="73ce64b36361acfce495c7cd0fabdf65" args="(int path, int nodeIdx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNodeIndexOnPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIdx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns index of node <code>nodeIdx</code> in the path nodes array of <code>path</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="a104415a7358481d76fbd5580a05a7c2"></a><!-- doxytag: member="SurfacePathSet::getNumPathsForNode" ref="a104415a7358481d76fbd5580a05a7c2" args="(int nodeIdx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNumPathsForNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of paths, a node belongs to. 
<p>

</div>
</div><p>
<a class="anchor" name="7fd844582e86028efe5b6781036a5044"></a><!-- doxytag: member="SurfacePathSet::getNumEntangledNodes" ref="7fd844582e86028efe5b6781036a5044" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::getNumEntangledNodes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns number of entangled nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="03318c598de2ece3a1da4427bc5c22ac"></a><!-- doxytag: member="SurfacePathSet::boundingBox" ref="03318c598de2ece3a1da4427bc5c22ac" args="(McBox3f &amp;bb) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::boundingBox           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_box3f.html">McBox3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes bounding box from coordinates. 
<p>

</div>
</div><p>
<a class="anchor" name="4d0ad0c5ce63f5625257243ce5c7fc3d"></a><!-- doxytag: member="SurfacePathSet::isInnerPathNodeIdx" ref="4d0ad0c5ce63f5625257243ce5c7fc3d" args="(int pathNodeIdx, int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::isInnerPathNodeIdx           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pathNodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if index <code>nodeIdx</code> in paths.nodes array is an inner node, meaning it is not a first and nor a last idx. 
<p>

</div>
</div><p>
<a class="anchor" name="dcbc57f7685943135c1c58c115a5f389"></a><!-- doxytag: member="SurfacePathSet::isInnerNodeIdx" ref="dcbc57f7685943135c1c58c115a5f389" args="(int nodeIdx, int path) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::isInnerNodeIdx           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if index <code>nodeIdx</code> in nodes array is an inner node, meaning it is not a first and nor a last idx. 
<p>

</div>
</div><p>
<a class="anchor" name="7fd42bace18d3a3935b5ab94e396a6f2"></a><!-- doxytag: member="SurfacePathSet::getAllPathsContainingNode" ref="7fd42bace18d3a3935b5ab94e396a6f2" args="(int nodeIdx, McDArray&lt; int &gt; &amp;pathsCN, McDArray&lt; int &gt; &amp;idxInPaths) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::getAllPathsContainingNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pathsCN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>idxInPaths</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collects all paths that contain given node, and an array with pathnodeIdx. 
<p>
<ul>
<li>get all paths that containing node with nodeIdx</li><li>all pathIdx are returned in pathsCN</li><li>the idx in path, where the containing node will be find is stored in idxInPaths on corresponding idx</li><li>regard that the same pathIdx can be in pathsCN more than once if containing node is in path more than once </li></ul>

</div>
</div><p>
<a class="anchor" name="0d32c144a2bdf9c2e85b446e66217e89"></a><!-- doxytag: member="SurfacePathSet::getAllPathsContainingNode" ref="0d32c144a2bdf9c2e85b446e66217e89" args="(int nodeIdx, McDArray&lt; int &gt; &amp;pathsCN) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::getAllPathsContainingNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pathsCN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collects all paths that contain given node. 
<p>

</div>
</div><p>
<a class="anchor" name="564493b0ae1a9b7e4a1cb0c4ed41caff"></a><!-- doxytag: member="SurfacePathSet::getAllPathsContainingInnerNode" ref="564493b0ae1a9b7e4a1cb0c4ed41caff" args="(int nodeIdx, McDArray&lt; int &gt; &amp;pathsCN) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::getAllPathsContainingInnerNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pathsCN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collects all paths that contain given node but not at first or last index. 
<p>

</div>
</div><p>
<a class="anchor" name="7f99c76f81f13ea6eb644e6f78ad8142"></a><!-- doxytag: member="SurfacePathSet::getInnerPathNodesIdxAlsoInOtherPaths" ref="7f99c76f81f13ea6eb644e6f78ad8142" args="(int pathIdx, McDArray&lt; int &gt; &amp;allNodesThatAreAlsoInOtherPAths) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::getInnerPathNodesIdxAlsoInOtherPaths           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pathIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>allNodesThatAreAlsoInOtherPAths</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collects all inner nodes of path <code>pathIdx</code> that are also contained in other paths. 
<p>

</div>
</div><p>
<a class="anchor" name="85f69d64701dc6d4e8d20f20b73de23c"></a><!-- doxytag: member="SurfacePathSet::getAllInnerEntangledPaths" ref="85f69d64701dc6d4e8d20f20b73de23c" args="(McDArray&lt; int &gt; &amp;allInnerEntagelPaths) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::getAllInnerEntangledPaths           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>allInnerEntagelPaths</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collects all paths that are entangled, but not paths that are only entangled on first or last point. 
<p>

</div>
</div><p>
<a class="anchor" name="b0e8b342c2534c640b4b80eae96ebcbf"></a><!-- doxytag: member="SurfacePathSet::getAllEntangledPaths" ref="b0e8b342c2534c640b4b80eae96ebcbf" args="(McDArray&lt; int &gt; &amp;allEntagelPaths) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::getAllEntangledPaths           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>allEntagelPaths</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collect all paths that are entangled. 
<p>

</div>
</div><p>
<a class="anchor" name="604d1b242f54f0a0b40458542c492f16"></a><!-- doxytag: member="SurfacePathSet::getInnerCrossedNodeIdxOfPath" ref="604d1b242f54f0a0b40458542c492f16" args="(int pathIdx, McDArray&lt; int &gt; &amp;allInnerNodeIdx, float mTol) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::getInnerCrossedNodeIdxOfPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pathIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>allInnerNodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>mTol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4722f3e8aea9bcea8b6ed1bac7bffd9f"></a><!-- doxytag: member="SurfacePathSet::getInnerCrossedPaths" ref="4722f3e8aea9bcea8b6ed1bac7bffd9f" args="(McDArray&lt; int &gt; &amp;allInnerEntagelPaths, float mTol=1.e-3) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::getInnerCrossedPaths           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>allInnerEntagelPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>mTol</em> = <code>1.e-3</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collects all paths that are crossed from other paths (crossings at first or last point noticed if one of the crossings is inner). 
<p>

</div>
</div><p>
<a class="anchor" name="489c391e8571d9599bcbd9abba551c9d"></a><!-- doxytag: member="SurfacePathSet::getCrossedPaths" ref="489c391e8571d9599bcbd9abba551c9d" args="(McDArray&lt; int &gt; &amp;allEntagelPaths, float mTol=1.e-3) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::getCrossedPaths           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>allEntagelPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>mTol</em> = <code>1.e-3</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collects all paths that are crossed from other paths (crossings at first or last point are noticed). 
<p>

</div>
</div><p>
<a class="anchor" name="15d5b7395c87865662aa7c17d19234bf"></a><!-- doxytag: member="SurfacePathSet::clear" ref="15d5b7395c87865662aa7c17d19234bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the path-array. 
<p>

</div>
</div><p>
<a class="anchor" name="7617d2afdf9e03b9e8bffe7262427ff4"></a><!-- doxytag: member="SurfacePathSet::cleanup" ref="7617d2afdf9e03b9e8bffe7262427ff4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::cleanup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes unused points or empty lines. 
<p>

</div>
</div><p>
<a class="anchor" name="7fde15a46b6ce1ebb0880f4db6f4100e"></a><!-- doxytag: member="SurfacePathSet::removeDuplicateNodes" ref="7fde15a46b6ce1ebb0880f4db6f4100e" args="(float tol=1.e-6, int mode=SurfaceNodeFactory::BARY_TOL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::removeDuplicateNodes           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>tol</em> = <code>1.e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>SurfaceNodeFactory::BARY_TOL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for duplicate points. 
<p>

</div>
</div><p>
<a class="anchor" name="7433e4ccd4d5b6b55e31463fc7200e97"></a><!-- doxytag: member="SurfacePathSet::removeInteriorNodes" ref="7433e4ccd4d5b6b55e31463fc7200e97" args="(int pathIdx, int removeControlPoints=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::removeInteriorNodes           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pathIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>removeControlPoints</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes interior triangle and duplicate edge/vertex nodes. 
<p>
Control Points will be kept if /p removeControlPoints is set (default). 
</div>
</div><p>
<a class="anchor" name="5a6a4ed3cc7ace6eef619bc2e16685a3"></a><!-- doxytag: member="SurfacePathSet::copyData" ref="5a6a4ed3cc7ace6eef619bc2e16685a3" args="(const SurfacePathSet &amp;other, Surface *surface=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::copyData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_surface_path_set.html">SurfacePathSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_surface.html">Surface</a> *&nbsp;</td>
          <td class="paramname"> <em>surface</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data, possibly attach to new surface (yet with same connectivity!). 
<p>

</div>
</div><p>
<a class="anchor" name="d41a60b9d9f1976a853f192439222d4e"></a><!-- doxytag: member="SurfacePathSet::untangle" ref="d41a60b9d9f1976a853f192439222d4e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::untangle           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collapses shared pathnodes to single node. 
<p>

</div>
</div><p>
<a class="anchor" name="25b9e6d891e269b94c04f97030e04172"></a><!-- doxytag: member="SurfacePathSet::untangle" ref="25b9e6d891e269b94c04f97030e04172" args="(const McDArray&lt; int &gt; &amp;selectedPaths)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::untangle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>selectedPaths</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply shared pathnodes. 
<p>

</div>
</div><p>
<a class="anchor" name="62660fb6b92fdbc7fb762a931e6b7bd4"></a><!-- doxytag: member="SurfacePathSet::importContours" ref="62660fb6b92fdbc7fb762a931e6b7bd4" args="(Surface *surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::importContours           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_surface.html">Surface</a> *&nbsp;</td>
          <td class="paramname"> <em>surface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses contours from <code>surface</code> and creates a corresponding vertex pathset. 
<p>

</div>
</div><p>
<a class="anchor" name="b36999c4dbf84f529d916aeb731774bf"></a><!-- doxytag: member="SurfacePathSet::setSurface" ref="b36999c4dbf84f529d916aeb731774bf" args="(Surface *surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::setSurface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_surface.html">Surface</a> *&nbsp;</td>
          <td class="paramname"> <em>surface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes pointer to surface for all nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="e6f85d9c57e8c3f02337290b48167297"></a><!-- doxytag: member="SurfacePathSet::addPath" ref="e6f85d9c57e8c3f02337290b48167297" args="(int n, int *whichPoints, int pos=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::addPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>whichPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pos</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a new path to the path set. 
<p>
The path consists of <code>n</code> points. <code>points</code> specifies the index of each point in the global node array. <code>pos</code> specifies the index of the new path. If <code>pos</code> is -1 the new path will be appended after all existing paths. 
</div>
</div><p>
<a class="anchor" name="e1c0a0a99b4fed198b45607f6645edbd"></a><!-- doxytag: member="SurfacePathSet::removePathVertex" ref="e1c0a0a99b4fed198b45607f6645edbd" args="(int p, int vertex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::removePathVertex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes <code>vertex</code> of <code>path</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="9376121927d4aeffda6c2e07dd6a741f"></a><!-- doxytag: member="SurfacePathSet::addPathVertex" ref="9376121927d4aeffda6c2e07dd6a741f" args="(int p, int v, int pos=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::addPathVertex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pos</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an additional vertex to path <code>p</code>. 
<p>
The second argument <code>v</code> is the index of the referenced point. <code>pos</code> specifies the position of the new vertex within the path. If <code>pos</code> is -1 the new vertex will be appended after all other vertices of the path. 
</div>
</div><p>
<a class="anchor" name="bb7e2b8451496de49acba17a64ce6ff8"></a><!-- doxytag: member="SurfacePathSet::operator[]" ref="bb7e2b8451496de49acba17a64ce6ff8" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface_path_set_1_1_surface_path.html">SurfacePath</a>&amp; SurfacePathSet::operator[]           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index operator to single path. 
<p>

</div>
</div><p>
<a class="anchor" name="ee42a47a3437330b41d82fbe6ba13f4e"></a><!-- doxytag: member="SurfacePathSet::operator=" ref="ee42a47a3437330b41d82fbe6ba13f4e" args="(const SurfacePathSet &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface_path_set.html">SurfacePathSet</a>&amp; SurfacePathSet::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_surface_path_set.html">SurfacePathSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. 
<p>

</div>
</div><p>
<a class="anchor" name="913996c3da554c66e1895de4b83dea5b"></a><!-- doxytag: member="SurfacePathSet::rotateClosedPath" ref="913996c3da554c66e1895de4b83dea5b" args="(int path, int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::rotateClosedPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotates closed path so that idx becomes 0. 
<p>

</div>
</div><p>
<a class="anchor" name="bc8ba1f5d92cd2fc14eb35e7bedd108e"></a><!-- doxytag: member="SurfacePathSet::removeIntermediateNodesFromPath" ref="bc8ba1f5d92cd2fc14eb35e7bedd108e" args="(int pathID, int pathIndex1, int pathIndex2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::removeIntermediateNodesFromPath           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pathID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pathIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pathIndex2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This Method removes all nodes from a path between pathIndex1 and pathIndex2, regardless of whether they are controlPoints, or not. 
<p>
Nodes are removed forward, so, if the pathIndex2 is smaller that pathIndex1, all nodes after pathIndex1 and all before pathIndex2 are deleted This method will leave the path afterwards as is and therefore the path is likely to be inconsistent. 
</div>
</div><p>
<a class="anchor" name="9ddb24ee07946bfd13725c598ba82815"></a><!-- doxytag: member="SurfacePathSet::connectSurfaceNodes" ref="9ddb24ee07946bfd13725c598ba82815" args="(int pathId, int index1, int index2, PathConnector *connector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SurfacePathSet::connectSurfaceNodes           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pathId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_path_connector.html">PathConnector</a> *&nbsp;</td>
          <td class="paramname"> <em>connector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method computes a path between the node on <code>index1</code> and <code>index2</code> on the path and inserts the found nodes after index1 on the path. 
<p>
It does not check for consistency and does not delete any intermediate nodes, if any. If index1 is the last index on the path, than the path lacks a last ControlPoint.<p>
Returns true on success, false on failure 
</div>
</div><p>
<a class="anchor" name="65853260e786eeb065997bc43b2c06b7"></a><!-- doxytag: member="SurfacePathSet::makePath" ref="65853260e786eeb065997bc43b2c06b7" args="(Surface *surface, McDArray&lt; int &gt; &amp;vertices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::makePath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_surface.html">Surface</a> *&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vertices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create path from given vertex chain. 
<p>
The function does not unnecessarily create new nodes, surface- and control-point-properties are modified if needed. Note that no consistency check is being performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertices</em>&nbsp;</td><td>contains the surface-vertices to be included. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="574a0f6c324191a8c5271d2f01e9a8c2"></a><!-- doxytag: member="SurfacePathSet::addVertexToPath" ref="574a0f6c324191a8c5271d2f01e9a8c2" args="(Surface *surface, int vertex, int path, bool isControlPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SurfacePathSet::addVertexToPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_surface.html">Surface</a> *&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isControlPoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds new vertex to given path. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>1 if operation was successfull<br>
 0 if surface is null<br>
 -1 if vertex is out of bounds<br>
 -2 if path is out of bounds </dd></dl>

</div>
</div><p>
<a class="anchor" name="1dd95552c6ffc5428dfedc56f2f9a2d8"></a><!-- doxytag: member="SurfacePathSet::removeStandAloneNodes" ref="1dd95552c6ffc5428dfedc56f2f9a2d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::removeStandAloneNodes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes paths that consists of only one node. 
<p>

</div>
</div><p>
<a class="anchor" name="aee5e50ab2acc1309adfe3759bf311ec"></a><!-- doxytag: member="SurfacePathSet::sortPathsByLength" ref="aee5e50ab2acc1309adfe3759bf311ec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::sortPathsByLength           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts paths according to their euclidean length in ascending order. 
<p>

</div>
</div><p>
<a class="anchor" name="4053cf58f864f83c1d83f365e843bcfd"></a><!-- doxytag: member="SurfacePathSet::updateCoords" ref="4053cf58f864f83c1d83f365e843bcfd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::updateCoords           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update 3d coordinates. 
<p>

</div>
</div><p>
<a class="anchor" name="c29b69795a7ec93c89575de7aa5eeb94"></a><!-- doxytag: member="SurfacePathSet::isSubArray" ref="c29b69795a7ec93c89575de7aa5eeb94" args="(const McDArray&lt; int &gt; &amp;word1, const McDArray&lt; int &gt; &amp;word2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool SurfacePathSet::isSubArray           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>word1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>word2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if <code>word1</code> is contained as a subsequence in <code>word2</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="b73cdd6452c757b267f1811a4d4bfee9"></a><!-- doxytag: member="SurfacePathSet::compute_prefix" ref="b73cdd6452c757b267f1811a4d4bfee9" args="(const McDArray&lt; int &gt; &amp;word, McDArray&lt; int &gt; &amp;pi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SurfacePathSet::compute_prefix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pi</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the prefix for the KMP-matching-algorithm used in <a class="el" href="class_surface_path_set.html#c29b69795a7ec93c89575de7aa5eeb94">isSubArray()</a>. 
<p>
<code>word</code> is the array the prefix-array <code>pi</code> is calculated for. 
</div>
</div><p>
<a class="anchor" name="53aac647b3da5012b6625c1f6c896abc"></a><!-- doxytag: member="SurfacePathSet::getSelfIntersections" ref="53aac647b3da5012b6625c1f6c896abc" args="(int path, McDArray&lt; int &gt; &amp;splitPositions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SurfacePathSet::getSelfIntersections           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>splitPositions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shows self-intersections in the following manner: anywhere where path-segments begin or end to self-intersect, a split position is appended at the end of <code>splitPositions</code>. 
<p>
Note that <code>is</code> NOT modified by this operation, only the second argument is filled with split-nodes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>splitPositions</em>&nbsp;</td><td>are the split-nodes for <code>path</code>, where each entry denotes a position in the corresponding paths-array (<a class="el" href="class_surface_path_set_1_1_surface_path.html#3b5dc54f1ceff88d04cb3a77d76ab2ee">SurfacePathSet::SurfacePath::nodes</a>). </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="48845858c28969aa18f06de5ff6ce5dc"></a><!-- doxytag: member="SurfacePathSet::paths" ref="48845858c28969aa18f06de5ff6ce5dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_surface_path_set_1_1_surface_path.html">SurfacePath</a>&gt; <a class="el" href="class_surface_path_set.html#48845858c28969aa18f06de5ff6ce5dc">SurfacePathSet::paths</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The paths of the path set. 
<p>

</div>
</div><p>
<a class="anchor" name="e2ac8da38871215b32fde5664a3a5249"></a><!-- doxytag: member="SurfacePathSet::nodes" ref="e2ac8da38871215b32fde5664a3a5249" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_handle.html">McHandle</a>&lt;<a class="el" href="class_surface_node.html">SurfaceNode</a>&gt; &gt; <a class="el" href="class_surface_path_set.html#e2ac8da38871215b32fde5664a3a5249">SurfacePathSet::nodes</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All nodes of the path set, stored per path. 
<p>

</div>
</div><p>
<a class="anchor" name="7a178cdce042acff9b55a1aa83455963"></a><!-- doxytag: member="SurfacePathSet::nFactory" ref="7a178cdce042acff9b55a1aa83455963" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface_node_factory.html">SurfaceNodeFactory</a> <a class="el" href="class_surface_path_set.html#7a178cdce042acff9b55a1aa83455963">SurfacePathSet::nFactory</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="class_surface.html">Surface</a> node factory, which creates new nodes. 
<p>

</div>
</div><p>
<a class="anchor" name="af8c24c56fa03b2891ca52d10b820a6e"></a><!-- doxytag: member="SurfacePathSet::coords" ref="af8c24c56fa03b2891ca52d10b820a6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_mc_vec3f.html">McVec3f</a>&gt; <a class="el" href="class_surface_path_set.html#af8c24c56fa03b2891ca52d10b820a6e">SurfacePathSet::coords</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>hxsurfacepath/<a class="el" href="_surface_path_set_8h.html">SurfacePathSet.h</a></ul>
<hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
