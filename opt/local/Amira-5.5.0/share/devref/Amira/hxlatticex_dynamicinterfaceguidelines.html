<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: Guidelines for Interfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1><a class="anchor" name="hxlatticex_DynamicInterfaceGuidelines">Guidelines for Interfaces</a></h1>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.<p>
(<a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>)<p>
Computational and Display modules SHOULD only use interfaces If you feel that a particular module needs to access objects derived from <a class="el" href="class_hx_object.html">HxObject</a> this points to some deficiencies in the provided interfaces. The best way is to improve the interfaces, by extending existing ones or adding new ones. If you ignore the problems you restrict the usability of the module in the future. Your module might be unable to operate on newly added datatypes.<p>
You SHOULD check if the interface is available. Normally there should not be any problems if the class is properly registered in the .rc file, but who knows.<p>
Some examples: <div class="fragment"><pre class="fragment">HxLattice* lat = static_cast&lt;HxLattice*&gt;
                   (portData.source (HxLattice::getClassTypeId ()));
<span class="keywordflow">if</span> (!lat) {
   <span class="keywordflow">return</span>;
}
</pre></div><p>
or<p>
<div class="fragment"><pre class="fragment"><a class="code" href="class_hx_object.html">HxObject</a>* in = portData.source ();
<span class="keywordflow">if</span> (!in) {
   <span class="keywordflow">return</span>;
}
HxLattice* lat = static_cast&lt;HxLattice*&gt;
                   (in-&gt;<a class="code" href="class_mc_interface.html#e176f258f2944d43e62eb82fde925dbf">getInterface</a>(HxLattice::getClassTypeId ()));
HxField* field = static_cast&lt;HxField*&gt;
                   (in-&gt;<a class="code" href="class_mc_interface.html#e176f258f2944d43e62eb82fde925dbf">getInterface</a>(HxField::getClassTypeId ()));
<span class="keywordflow">if</span> (!lat || !field) {
   <span class="keywordflow">return</span>;
}
</pre></div><p>
You MUST NOT derive classes which would introduce two paths to HxInterface/HxObject. The details of multiple inheritance are bothering. Most of the time you're not aware of all the details which might introduce a lot of problems. Nontheless we don't want to enforce our view completely. If you think you need multiple inheritance, go forth and use it. But do not use it in the <a class="el" href="class_hx_interface.html">HxInterface</a>, <a class="el" href="class_hx_object.html">HxObject</a> part of the inheritance tree.<p>
Interfaces SHOULD be made up of a minimal but complete set of methods. They SHOULD provide everything an user might expect. The number of interfaces SHOULD be kept small. These request are contradictory to some amount. The details of a decision are difficult. Therefore, only some hints and some discussion might help to clarify the point.<p>
If you don't include enough methods in an interface the programmer is forced to use a lot of them or to build work-arounds. Both is annoying. On the other side if you include too many redundant methods it's getting unclear how to use the interface. Additionally, it's hard to implement it. You should choose a minimal set of methods which must be virtual and should be overriden by derived classes implementing the interface. Most of them SHOULD be pure virtual indicating that these methods must be overriden in an implementation of the interface. You SHOULD follow the nonvirtual interface idiom (see e.g. <a href="http://www.gotw.ca/publications/mill18.htm">http://www.gotw.ca/publications/mill18.htm</a>): Public methods should be nonvirtual, virtual methods should be private. You might add non-virtual methods for convenience implementing wrappers or small helpful algorithms. The documentation MUST clearly explain what is expected from an implementation.<p>
See e.g. HxLattice. The public methods are nonvirtual and mostly just forward the call to a privat viritual template method.<p>
Interfaces SHOULD be lightweight meaning they SHOULD not contain any data members. As a convenience to other developers you may want to provide a default implementation. A good way is to provide a helper class which could easily be instantiated in a derived interface. Some requests to the interface can be forwarded to this helper class. See e.g. HxLattice::DefaultComputeRange.<p>
Interfaces SHOULD be available in a readonly version. They MAY also have a mutable version derived from the readonly version (see HxLattice, HxMutableLattice). Display modules only need a readonly version of the interfaces. Readonly versions are most of the times easier to implement and easier to reason about. This gives hope to get many display modules working with many data implementations. The most striking argument is perhaps that you don't need a real data object for providing a read only interface because you will not have to store changes. You can easily create the required data on-the-fly. E.g the orthoslice could provide a HxField2 interface, even some kind of HxLattice2 but never a HxMutableLattice2. It would only extract the data from the attached field but would never have to write it back. <hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
