<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: McSparseMatrix&lt; T, SYMMETRIC &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>McSparseMatrix&lt; T, SYMMETRIC &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__mclib.html">mclib</a>]</small>
</h1><!-- doxytag: class="McSparseMatrix" -->A template class for sparse matrices.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;mclib/McSparseMatrix.h&gt;</code>
<p>
<a href="class_mc_sparse_matrix-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#278a33f1c5a949e9334e813f193f3e07">McSparseMatrix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Constructor.  <a href="#278a33f1c5a949e9334e813f193f3e07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#cb0e838bf44f5ae8db992e9400594d44">McSparseMatrix</a> (int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#7a650a5fb5088f7fe605cc28027eb8cc">McSparseMatrix</a> (int rows, int columns)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#1227653bf92ff214f75b0dc8fa110a60">operator()</a> (int i, int j) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index operator. Only for element reading.  <a href="#1227653bf92ff214f75b0dc8fa110a60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#c2691e4e9347866b701bf21b74876e75">operator *=</a> (const T &amp;scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplication with a scalar.  <a href="#c2691e4e9347866b701bf21b74876e75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#463f3ea7722456e635d353e3e2b47c6b">init</a> (const int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#d9336e0550346314da7c9dde651d1d84">resize</a> (int m, int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#88421e1f3ec72f52b860cc7d5a6b45f5">resizeRows</a> (int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#28ac9644086ec94340890875642a40ed">nRows</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of rows of the matrix.  <a href="#28ac9644086ec94340890875642a40ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#1e2decc1a7aacfdff79e08a1ba5a9858">nCols</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of columns of the matrix.  <a href="#1e2decc1a7aacfdff79e08a1ba5a9858"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#3d4e592198a3a74998d7bd74df72363d">nElements</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of elements.  <a href="#3d4e592198a3a74998d7bd74df72363d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#d1cc36747929c3f29ebd00a5aac5abd8">isQuadratic</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quadratic matrix or not?  <a href="#d1cc36747929c3f29ebd00a5aac5abd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#2461d13c4bdba21389f43e29c6f9f1ba">isSymmetric</a> (float epsilon=1.e-6)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test the matrix for symmetry.  <a href="#2461d13c4bdba21389f43e29c6f9f1ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#4f531c5be070e4d188e651a369a50674">makeSymmetric</a> (<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, true &gt; &amp;sym)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create symmetric matrix by removing upper right part.  <a href="#4f531c5be070e4d188e651a369a50674"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#c4a303200822c52dcc8dc526814f6b42">fillSymmetric</a> (<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, false &gt; &amp;Result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the lower left part into the upper right part.  <a href="#c4a303200822c52dcc8dc526814f6b42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#184065acfdb72c52662c4703909dc80c">clearRow</a> (const int iRow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears an entire row.  <a href="#184065acfdb72c52662c4703909dc80c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#02c34256ce23af9cf92ffc47bf360846">setEntry</a> (int i, int j, const T &amp;newValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#8add4e037168f4e216c8f2df78612b69">addToEntry</a> (int i, int j, const T &amp;newValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#d52cc6b120fd4eb7cdeef1e4edd4a3e4">squareSym</a> (<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a> &amp;Result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a symmetric matrix with itself.  <a href="#d52cc6b120fd4eb7cdeef1e4edd4a3e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#95d0d6850cbbd5ed9575cfd785968118">Transpose</a> (<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a> &amp;Result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the transpose of the matrix.  <a href="#95d0d6850cbbd5ed9575cfd785968118"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#4c32b894088b189489f17d4570018513">multMat</a> (<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a> &amp;Other, <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, false &gt; &amp;Result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies this matrix with the given other matrix.  <a href="#4c32b894088b189489f17d4570018513"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#2fe411c866323ce79daaecb8b0a19c99">multMatSymResult</a> (<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a> &amp;Other, <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, true &gt; &amp;Result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies this matrix with the given other matrix and the result is known to be symmetric, i.e., A^T * A.  <a href="#2fe411c866323ce79daaecb8b0a19c99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#1cc7a39c2c0daade428f5f8abaac171d">ATA</a> (<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, true &gt; &amp;Result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies a matrix with its transposed self, i.e., A^T * A. The result is symmetric.  <a href="#1cc7a39c2c0daade428f5f8abaac171d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#3e2e62e9aafd66669cd6ca7ffd938658">multVec</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;v, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply sparse matrix with vector.  <a href="#3e2e62e9aafd66669cd6ca7ffd938658"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#2feb920dc2c288640b491e56d87f7c29">multVecC</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;v, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply real sparse matrix with complex vector.  <a href="#2feb920dc2c288640b491e56d87f7c29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#bd8f011c5f94883634679727b2645e65">multVecM</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;v, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply sparse matrix with multiple vectors.  <a href="#bd8f011c5f94883634679727b2645e65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#857644db06f5999a6c7a79bce4fa5678">SSORIteration</a> (float relaxFact, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One SSOR step.  <a href="#857644db06f5999a6c7a79bce4fa5678"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#c2f51f4c5a058c17780395ebe0119089">SSORIterationC</a> (float relaxFact, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One SSOR step, real matrix, complex vector.  <a href="#c2f51f4c5a058c17780395ebe0119089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#3b4f350c24e068152f85911bf1ddb99c">SSORIterationM</a> (float relaxFact, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;result) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One SSOR step for multiple right hand sides.  <a href="#3b4f350c24e068152f85911bf1ddb99c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#5e7e67f7cbacf1bc0e9fc456d6e83303">SORIteration</a> (float relaxFact, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;rhs, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;xOld, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;xNew) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One SOR iteration.  <a href="#5e7e67f7cbacf1bc0e9fc456d6e83303"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#9e192b5c7f5a5afd5d5ddb7ae6888958">SORIterationC</a> (float relaxFact, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;xOld, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;xNew) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">One SOR iteration, real matrix, complex vector.  <a href="#9e192b5c7f5a5afd5d5ddb7ae6888958"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#83a976f7b0c5a925e278bf44c60376de">SOR</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;result, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, <a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *progress=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterative solver: SOR.  <a href="#83a976f7b0c5a925e278bf44c60376de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#c6b4ebe00a1a183f2055fa2d68a67f6d">SORC</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;result, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, <a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *progress=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterative solver: SOR, real matrix, complex vector.  <a href="#c6b4ebe00a1a183f2055fa2d68a67f6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#e6006c13224957621f2f33935466e508">pcg</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;result, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, <a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *progress=0, char *progressText=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterative solver: preconditioned conjugate gradient method.  <a href="#e6006c13224957621f2f33935466e508"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#ef08ab6738523317c493eea021da421b">pcgM</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;result, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, <a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *progress=0, char *progressText=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preconditioned CG method for multiple right hand sides.  <a href="#ef08ab6738523317c493eea021da421b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#34e0a75cc073b5ade01ea3a34c66a582">pcgC</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;result, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, <a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *progress=0, char *progressText=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preconditioned CG method for real matrix &amp; complex vector.  <a href="#34e0a75cc073b5ade01ea3a34c66a582"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#d9223a525e457a197b2d8292036ae7b7">BiCGSTAB</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;result, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;residuum, int *maxIter, const double tolerance, <a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *progress=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">another iterative solver for nonsymmetric matrices: BI-CGSTAB  <a href="#d9223a525e457a197b2d8292036ae7b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#3ecadd987572d83bc9ad5453c57111b9">BiCGSTABC</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;result, <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;residuum, int *maxIter, const double tolerance, <a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *progress=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">another iterative solver for nonsymmetric matrices: BI-CGSTAB  <a href="#3ecadd987572d83bc9ad5453c57111b9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">MC_complex&lt; float &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#d608e0f1c52f86f8a6a562b200a5fd4b">conjug</a> (const MC_complex&lt; float &gt; &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">MC_complex&lt; double &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#3fa0bda666a96b5ebcb139afecad7227">conjug</a> (const MC_complex&lt; double &gt; &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">MC_complex&lt; float &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#0ed76b06b2efac2ed0c634e04b91b7ad">conjug</a> (const MC_complex&lt; float &gt; &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">MC_complex&lt; double &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#e99ac42ba89f2a13586bcee1e8c74ea7">conjug</a> (const MC_complex&lt; double &gt; &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#0996d0ad1fd3a63c94b96750a1b90751">realPart</a> (const MC_complex&lt; float &gt; &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#9e360fd55ef8f563df938e8e6ba20810">realPart</a> (const MC_complex&lt; double &gt; &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#c8244df5ec663c751c47c2608d4812dd">realPart</a> (const MC_complex&lt; float &gt; &amp;z)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#78083a2ed1f45f037c1ee6be0ace2589">realPart</a> (const MC_complex&lt; double &gt; &amp;z)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#96ac16f5f5c10b048c1159ed5c7861f6">dotProduct</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;a, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static MC_complex&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#a8d4bb00183c6909726c71492f5c4a53">dotProductC</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;a, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static MC_complex&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#1abe12b6c4a7f9b74e0818fa4894dca1">dotProductCRI</a> (const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;a, const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#ac2c853cac97ed60a8954c115c0ee6e4">conjug</a> (const T &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">complex conjugate, if T is complex, nothing if T is not  <a href="#ac2c853cac97ed60a8954c115c0ee6e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#b135772d7fd77efc9733c6b3af418191">realPart</a> (const T &amp;z)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; <a class="el" href="struct_mc_sparse_matrix_1_1_matrix_entry.html">MatrixEntry</a>, 10 &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#548c25b59e7093453fad8920a029d759">data</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_sparse_matrix.html#f343c7e1b32c0207bd8effc7cdacb18a">numCols</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mc_sparse_matrix_1_1_matrix_entry.html">MatrixEntry</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mc_sparse_matrix_1_1_symmetric_matrix_iter.html">SymmetricMatrixIter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper class to iterate over a symmetric matrix during multiplication with itself.  <a href="struct_mc_sparse_matrix_1_1_symmetric_matrix_iter.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, bool SYMMETRIC&gt;<br>
 class McSparseMatrix&lt; T, SYMMETRIC &gt;</h3>

A template class for sparse matrices. 
<p>
The first template parameter should be one of float, double, complex&lt;float&gt; or complex&lt;double&gt;. The second parameter is a boolean value specifying whether the matrix is symmetric or not. Symmetric matrices automatically use special algorithms and need less memory. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="278a33f1c5a949e9334e813f193f3e07"></a><!-- doxytag: member="McSparseMatrix::McSparseMatrix" ref="278a33f1c5a949e9334e813f193f3e07" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="cb0e838bf44f5ae8db992e9400594d44"></a><!-- doxytag: member="McSparseMatrix::McSparseMatrix" ref="cb0e838bf44f5ae8db992e9400594d44" args="(int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7a650a5fb5088f7fe605cc28027eb8cc"></a><!-- doxytag: member="McSparseMatrix::McSparseMatrix" ref="7a650a5fb5088f7fe605cc28027eb8cc" args="(int rows, int columns)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::<a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>columns</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1227653bf92ff214f75b0dc8fa110a60"></a><!-- doxytag: member="McSparseMatrix::operator()" ref="1227653bf92ff214f75b0dc8fa110a60" args="(int i, int j) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index operator. Only for element reading. 
<p>

</div>
</div><p>
<a class="anchor" name="c2691e4e9347866b701bf21b74876e75"></a><!-- doxytag: member="McSparseMatrix::operator *=" ref="c2691e4e9347866b701bf21b74876e75" args="(const T &amp;scalar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::operator *=           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>scalar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplication with a scalar. 
<p>

</div>
</div><p>
<a class="anchor" name="463f3ea7722456e635d353e3e2b47c6b"></a><!-- doxytag: member="McSparseMatrix::init" ref="463f3ea7722456e635d353e3e2b47c6b" args="(const int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::init           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d9336e0550346314da7c9dde651d1d84"></a><!-- doxytag: member="McSparseMatrix::resize" ref="d9336e0550346314da7c9dde651d1d84" args="(int m, int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::resize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="88421e1f3ec72f52b860cc7d5a6b45f5"></a><!-- doxytag: member="McSparseMatrix::resizeRows" ref="88421e1f3ec72f52b860cc7d5a6b45f5" args="(int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::resizeRows           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="28ac9644086ec94340890875642a40ed"></a><!-- doxytag: member="McSparseMatrix::nRows" ref="28ac9644086ec94340890875642a40ed" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::nRows           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of rows of the matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="1e2decc1a7aacfdff79e08a1ba5a9858"></a><!-- doxytag: member="McSparseMatrix::nCols" ref="1e2decc1a7aacfdff79e08a1ba5a9858" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::nCols           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of columns of the matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="3d4e592198a3a74998d7bd74df72363d"></a><!-- doxytag: member="McSparseMatrix::nElements" ref="3d4e592198a3a74998d7bd74df72363d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::nElements           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of elements. 
<p>

</div>
</div><p>
<a class="anchor" name="d1cc36747929c3f29ebd00a5aac5abd8"></a><!-- doxytag: member="McSparseMatrix::isQuadratic" ref="d1cc36747929c3f29ebd00a5aac5abd8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::isQuadratic           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Quadratic matrix or not? 
<p>

</div>
</div><p>
<a class="anchor" name="2461d13c4bdba21389f43e29c6f9f1ba"></a><!-- doxytag: member="McSparseMatrix::isSymmetric" ref="2461d13c4bdba21389f43e29c6f9f1ba" args="(float epsilon=1.e-6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::isSymmetric           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code>1.e-6</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test the matrix for symmetry. 
<p>

</div>
</div><p>
<a class="anchor" name="4f531c5be070e4d188e651a369a50674"></a><!-- doxytag: member="McSparseMatrix::makeSymmetric" ref="4f531c5be070e4d188e651a369a50674" args="(McSparseMatrix&lt; T, true &gt; &amp;sym)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::makeSymmetric           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, true &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sym</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create symmetric matrix by removing upper right part. 
<p>

</div>
</div><p>
<a class="anchor" name="c4a303200822c52dcc8dc526814f6b42"></a><!-- doxytag: member="McSparseMatrix::fillSymmetric" ref="c4a303200822c52dcc8dc526814f6b42" args="(McSparseMatrix&lt; T, false &gt; &amp;Result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::fillSymmetric           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, false &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the lower left part into the upper right part. 
<p>
While the result is still symmetric from a mathematical point of view, the SYMMETRIC template parameter of the result is set to false. Hence, everything is prepared to make non-symmetric modifications. This function can be seen as the opposite to <a class="el" href="class_mc_sparse_matrix.html#4f531c5be070e4d188e651a369a50674">makeSymmetric()</a>. 
</div>
</div><p>
<a class="anchor" name="184065acfdb72c52662c4703909dc80c"></a><!-- doxytag: member="McSparseMatrix::clearRow" ref="184065acfdb72c52662c4703909dc80c" args="(const int iRow)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::clearRow           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>iRow</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears an entire row. 
<p>

</div>
</div><p>
<a class="anchor" name="02c34256ce23af9cf92ffc47bf360846"></a><!-- doxytag: member="McSparseMatrix::setEntry" ref="02c34256ce23af9cf92ffc47bf360846" args="(int i, int j, const T &amp;newValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::setEntry           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>newValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8add4e037168f4e216c8f2df78612b69"></a><!-- doxytag: member="McSparseMatrix::addToEntry" ref="8add4e037168f4e216c8f2df78612b69" args="(int i, int j, const T &amp;newValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::addToEntry           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>newValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d52cc6b120fd4eb7cdeef1e4edd4a3e4"></a><!-- doxytag: member="McSparseMatrix::squareSym" ref="d52cc6b120fd4eb7cdeef1e4edd4a3e4" args="(McSparseMatrix &amp;Result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::squareSym           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a symmetric matrix with itself. 
<p>

</div>
</div><p>
<a class="anchor" name="95d0d6850cbbd5ed9575cfd785968118"></a><!-- doxytag: member="McSparseMatrix::Transpose" ref="95d0d6850cbbd5ed9575cfd785968118" args="(McSparseMatrix &amp;Result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::Transpose           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the transpose of the matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="4c32b894088b189489f17d4570018513"></a><!-- doxytag: member="McSparseMatrix::multMat" ref="4c32b894088b189489f17d4570018513" args="(McSparseMatrix &amp;Other, McSparseMatrix&lt; T, false &gt; &amp;Result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::multMat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, false &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies this matrix with the given other matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="2fe411c866323ce79daaecb8b0a19c99"></a><!-- doxytag: member="McSparseMatrix::multMatSymResult" ref="2fe411c866323ce79daaecb8b0a19c99" args="(McSparseMatrix &amp;Other, McSparseMatrix&lt; T, true &gt; &amp;Result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::multMatSymResult           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, true &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies this matrix with the given other matrix and the result is known to be symmetric, i.e., A^T * A. 
<p>

</div>
</div><p>
<a class="anchor" name="1cc7a39c2c0daade428f5f8abaac171d"></a><!-- doxytag: member="McSparseMatrix::ATA" ref="1cc7a39c2c0daade428f5f8abaac171d" args="(McSparseMatrix&lt; T, true &gt; &amp;Result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::ATA           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, true &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies a matrix with its transposed self, i.e., A^T * A. The result is symmetric. 
<p>

</div>
</div><p>
<a class="anchor" name="3e2e62e9aafd66669cd6ca7ffd938658"></a><!-- doxytag: member="McSparseMatrix::multVec" ref="3e2e62e9aafd66669cd6ca7ffd938658" args="(const McDArray&lt; T &gt; &amp;v, McDArray&lt; T &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::multVec           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply sparse matrix with vector. 
<p>

</div>
</div><p>
<a class="anchor" name="2feb920dc2c288640b491e56d87f7c29"></a><!-- doxytag: member="McSparseMatrix::multVecC" ref="2feb920dc2c288640b491e56d87f7c29" args="(const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;v, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::multVecC           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply real sparse matrix with complex vector. 
<p>

</div>
</div><p>
<a class="anchor" name="bd8f011c5f94883634679727b2645e65"></a><!-- doxytag: member="McSparseMatrix::multVecM" ref="bd8f011c5f94883634679727b2645e65" args="(const McDArray&lt; McDArray&lt; T &gt; &gt; &amp;v, McDArray&lt; McDArray&lt; T &gt; &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::multVecM           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply sparse matrix with multiple vectors. 
<p>

</div>
</div><p>
<a class="anchor" name="857644db06f5999a6c7a79bce4fa5678"></a><!-- doxytag: member="McSparseMatrix::SSORIteration" ref="857644db06f5999a6c7a79bce4fa5678" args="(float relaxFact, const McDArray&lt; T &gt; &amp;rhs, McDArray&lt; T &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::SSORIteration           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
One SSOR step. 
<p>

</div>
</div><p>
<a class="anchor" name="c2f51f4c5a058c17780395ebe0119089"></a><!-- doxytag: member="McSparseMatrix::SSORIterationC" ref="c2f51f4c5a058c17780395ebe0119089" args="(float relaxFact, const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::SSORIterationC           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
One SSOR step, real matrix, complex vector. 
<p>

</div>
</div><p>
<a class="anchor" name="3b4f350c24e068152f85911bf1ddb99c"></a><!-- doxytag: member="McSparseMatrix::SSORIterationM" ref="3b4f350c24e068152f85911bf1ddb99c" args="(float relaxFact, const McDArray&lt; McDArray&lt; T &gt; &gt; &amp;rhs, McDArray&lt; McDArray&lt; T &gt; &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::SSORIterationM           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
One SSOR step for multiple right hand sides. 
<p>

</div>
</div><p>
<a class="anchor" name="5e7e67f7cbacf1bc0e9fc456d6e83303"></a><!-- doxytag: member="McSparseMatrix::SORIteration" ref="5e7e67f7cbacf1bc0e9fc456d6e83303" args="(float relaxFact, const McDArray&lt; T &gt; &amp;rhs, const McDArray&lt; T &gt; &amp;xOld, McDArray&lt; T &gt; &amp;xNew) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::SORIteration           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xNew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
One SOR iteration. 
<p>

</div>
</div><p>
<a class="anchor" name="9e192b5c7f5a5afd5d5ddb7ae6888958"></a><!-- doxytag: member="McSparseMatrix::SORIterationC" ref="9e192b5c7f5a5afd5d5ddb7ae6888958" args="(float relaxFact, const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;xOld, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;xNew) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::SORIterationC           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xNew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
One SOR iteration, real matrix, complex vector. 
<p>

</div>
</div><p>
<a class="anchor" name="83a976f7b0c5a925e278bf44c60376de"></a><!-- doxytag: member="McSparseMatrix::SOR" ref="83a976f7b0c5a925e278bf44c60376de" args="(const McDArray&lt; T &gt; &amp;rhs, McDArray&lt; T &gt; &amp;result, McDArray&lt; T &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, McProgressInterface *progress=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::SOR           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residuum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterative solver: SOR. 
<p>

</div>
</div><p>
<a class="anchor" name="c6b4ebe00a1a183f2055fa2d68a67f6d"></a><!-- doxytag: member="McSparseMatrix::SORC" ref="c6b4ebe00a1a183f2055fa2d68a67f6d" args="(const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;result, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, McProgressInterface *progress=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::SORC           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residuum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterative solver: SOR, real matrix, complex vector. 
<p>

</div>
</div><p>
<a class="anchor" name="e6006c13224957621f2f33935466e508"></a><!-- doxytag: member="McSparseMatrix::pcg" ref="e6006c13224957621f2f33935466e508" args="(const McDArray&lt; T &gt; &amp;rhs, McDArray&lt; T &gt; &amp;result, McDArray&lt; T &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, McProgressInterface *progress=0, char *progressText=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::pcg           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residuum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>progressText</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterative solver: preconditioned conjugate gradient method. 
<p>

</div>
</div><p>
<a class="anchor" name="ef08ab6738523317c493eea021da421b"></a><!-- doxytag: member="McSparseMatrix::pcgM" ref="ef08ab6738523317c493eea021da421b" args="(const McDArray&lt; McDArray&lt; T &gt; &gt; &amp;rhs, McDArray&lt; McDArray&lt; T &gt; &gt; &amp;result, McDArray&lt; McDArray&lt; T &gt; &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, McProgressInterface *progress=0, char *progressText=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::pcgM           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residuum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>progressText</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Preconditioned CG method for multiple right hand sides. 
<p>

</div>
</div><p>
<a class="anchor" name="34e0a75cc073b5ade01ea3a34c66a582"></a><!-- doxytag: member="McSparseMatrix::pcgC" ref="34e0a75cc073b5ade01ea3a34c66a582" args="(const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;result, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;residuum, int *maxIter, const double tolerance, const double relaxFact, McProgressInterface *progress=0, char *progressText=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::pcgC           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residuum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>relaxFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>progressText</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Preconditioned CG method for real matrix &amp; complex vector. 
<p>

</div>
</div><p>
<a class="anchor" name="d9223a525e457a197b2d8292036ae7b7"></a><!-- doxytag: member="McSparseMatrix::BiCGSTAB" ref="d9223a525e457a197b2d8292036ae7b7" args="(const McDArray&lt; T &gt; &amp;rhs, McDArray&lt; T &gt; &amp;result, McDArray&lt; T &gt; &amp;residuum, int *maxIter, const double tolerance, McProgressInterface *progress=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::BiCGSTAB           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residuum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
another iterative solver for nonsymmetric matrices: BI-CGSTAB 
<p>

</div>
</div><p>
<a class="anchor" name="3ecadd987572d83bc9ad5453c57111b9"></a><!-- doxytag: member="McSparseMatrix::BiCGSTABC" ref="3ecadd987572d83bc9ad5453c57111b9" args="(const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;rhs, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;result, McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;residuum, int *maxIter, const double tolerance, McProgressInterface *progress=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::BiCGSTABC           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residuum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_progress_interface.html">McProgressInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>progress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
another iterative solver for nonsymmetric matrices: BI-CGSTAB 
<p>

</div>
</div><p>
<a class="anchor" name="96ac16f5f5c10b048c1159ed5c7861f6"></a><!-- doxytag: member="McSparseMatrix::dotProduct" ref="96ac16f5f5c10b048c1159ed5c7861f6" args="(const McDArray&lt; T &gt; &amp;a, const McDArray&lt; T &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::dotProduct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a8d4bb00183c6909726c71492f5c4a53"></a><!-- doxytag: member="McSparseMatrix::dotProductC" ref="a8d4bb00183c6909726c71492f5c4a53" args="(const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;a, const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static MC_complex&lt;T&gt; <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::dotProductC           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1abe12b6c4a7f9b74e0818fa4894dca1"></a><!-- doxytag: member="McSparseMatrix::dotProductCRI" ref="1abe12b6c4a7f9b74e0818fa4894dca1" args="(const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;a, const McDArray&lt; MC_complex&lt; T &gt; &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static MC_complex&lt;double&gt; <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::dotProductCRI           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; MC_complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ac2c853cac97ed60a8954c115c0ee6e4"></a><!-- doxytag: member="McSparseMatrix::conjug" ref="ac2c853cac97ed60a8954c115c0ee6e4" args="(const T &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::conjug           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
complex conjugate, if T is complex, nothing if T is not 
<p>

</div>
</div><p>
<a class="anchor" name="b135772d7fd77efc9733c6b3af418191"></a><!-- doxytag: member="McSparseMatrix::realPart" ref="b135772d7fd77efc9733c6b3af418191" args="(const T &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::realPart           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d608e0f1c52f86f8a6a562b200a5fd4b"></a><!-- doxytag: member="McSparseMatrix::conjug" ref="d608e0f1c52f86f8a6a562b200a5fd4b" args="(const MC_complex&lt; float &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MC_complex&lt; float &gt; <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; MC_complex&lt; float &gt;, false &gt;::conjug           </td>
          <td>(</td>
          <td class="paramtype">const MC_complex&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3fa0bda666a96b5ebcb139afecad7227"></a><!-- doxytag: member="McSparseMatrix::conjug" ref="3fa0bda666a96b5ebcb139afecad7227" args="(const MC_complex&lt; double &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MC_complex&lt; double &gt; <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; MC_complex&lt; double &gt;, false &gt;::conjug           </td>
          <td>(</td>
          <td class="paramtype">const MC_complex&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0ed76b06b2efac2ed0c634e04b91b7ad"></a><!-- doxytag: member="McSparseMatrix::conjug" ref="0ed76b06b2efac2ed0c634e04b91b7ad" args="(const MC_complex&lt; float &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MC_complex&lt; float &gt; <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; MC_complex&lt; float &gt;, true &gt;::conjug           </td>
          <td>(</td>
          <td class="paramtype">const MC_complex&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e99ac42ba89f2a13586bcee1e8c74ea7"></a><!-- doxytag: member="McSparseMatrix::conjug" ref="e99ac42ba89f2a13586bcee1e8c74ea7" args="(const MC_complex&lt; double &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MC_complex&lt; double &gt; <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; MC_complex&lt; double &gt;, true &gt;::conjug           </td>
          <td>(</td>
          <td class="paramtype">const MC_complex&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0996d0ad1fd3a63c94b96750a1b90751"></a><!-- doxytag: member="McSparseMatrix::realPart" ref="0996d0ad1fd3a63c94b96750a1b90751" args="(const MC_complex&lt; float &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; MC_complex&lt; float &gt;, false &gt;::realPart           </td>
          <td>(</td>
          <td class="paramtype">const MC_complex&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9e360fd55ef8f563df938e8e6ba20810"></a><!-- doxytag: member="McSparseMatrix::realPart" ref="9e360fd55ef8f563df938e8e6ba20810" args="(const MC_complex&lt; double &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; MC_complex&lt; double &gt;, false &gt;::realPart           </td>
          <td>(</td>
          <td class="paramtype">const MC_complex&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c8244df5ec663c751c47c2608d4812dd"></a><!-- doxytag: member="McSparseMatrix::realPart" ref="c8244df5ec663c751c47c2608d4812dd" args="(const MC_complex&lt; float &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; MC_complex&lt; float &gt;, true &gt;::realPart           </td>
          <td>(</td>
          <td class="paramtype">const MC_complex&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="78083a2ed1f45f037c1ee6be0ace2589"></a><!-- doxytag: member="McSparseMatrix::realPart" ref="78083a2ed1f45f037c1ee6be0ace2589" args="(const MC_complex&lt; double &gt; &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; MC_complex&lt; double &gt;, true &gt;::realPart           </td>
          <td>(</td>
          <td class="paramtype">const MC_complex&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="548c25b59e7093453fad8920a029d759"></a><!-- doxytag: member="McSparseMatrix::data" ref="548c25b59e7093453fad8920a029d759" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt;<a class="el" href="struct_mc_sparse_matrix_1_1_matrix_entry.html">MatrixEntry</a>, 10&gt; &gt; <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::<a class="el" href="class_mc_sparse_matrix.html#548c25b59e7093453fad8920a029d759">data</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f343c7e1b32c0207bd8effc7cdacb18a"></a><!-- doxytag: member="McSparseMatrix::numCols" ref="f343c7e1b32c0207bd8effc7cdacb18a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool SYMMETRIC&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_mc_sparse_matrix.html">McSparseMatrix</a>&lt; T, SYMMETRIC &gt;::<a class="el" href="class_mc_sparse_matrix.html#f343c7e1b32c0207bd8effc7cdacb18a">numCols</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>mclib/<a class="el" href="_mc_sparse_matrix_8h.html">McSparseMatrix.h</a></ul>
<hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
