<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: McWorkerThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>McWorkerThread Class Reference<br>
<small>
[<a class="el" href="group__mclibthreaded.html">mclibthreaded</a>]</small>
</h1><!-- doxytag: class="McWorkerThread" -->This class implements a worker thread.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;mclibthreaded/McWorkerThread.h&gt;</code>
<p>
<a href="class_mc_worker_thread-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b918c8b6613b1904188d789ad255ea4a8a">TERMINATED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9a861252df0ff14e8c14384bb11910cd5">WAITING</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9e91bbb145fbc8a312aad7de2ad49617d">RUNNING</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9a2c35198629ba7bfbd201a8963f3a500">SUSPENDED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9d2e86f4fdd985f4dd4cc62f84f184df8">CANCELED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9a6176877f3d5078f186e4dc8ea015240">SHOULD_SUSPEND</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b91e795b099e9b0660ad4a3d29fb9e0ca2">SHOULD_CANCEL</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b94e1f5dfc7313737655988ee37c2fcaa2">SHOULD_EXIT</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9">State</a> { <br>
&nbsp;&nbsp;<a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b918c8b6613b1904188d789ad255ea4a8a">TERMINATED</a>, 
<a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9a861252df0ff14e8c14384bb11910cd5">WAITING</a>, 
<a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9e91bbb145fbc8a312aad7de2ad49617d">RUNNING</a>, 
<a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9a2c35198629ba7bfbd201a8963f3a500">SUSPENDED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9d2e86f4fdd985f4dd4cc62f84f184df8">CANCELED</a>, 
<a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9a6176877f3d5078f186e4dc8ea015240">SHOULD_SUSPEND</a>, 
<a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b91e795b099e9b0660ad4a3d29fb9e0ca2">SHOULD_CANCEL</a>, 
<a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b94e1f5dfc7313737655988ee37c2fcaa2">SHOULD_EXIT</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerates all states the worker thread can take on.  <a href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#fa84b8337330f72d40e0fd163c4483b7">setName</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the name of the worker thread.  <a href="#fa84b8337330f72d40e0fd163c4483b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#60260205258ba3f1941b6623a7e6ea9a">name</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the worker thread.  <a href="#60260205258ba3f1941b6623a7e6ea9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9">State</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#e5c1f42f055ce48c5178d24d97f2e158">state</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current state of the worker thread.  <a href="#e5c1f42f055ce48c5178d24d97f2e158"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#c71d3ae144b3c0406eaf94effa2e1687">start</a> (bool inBlocking=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts working.  <a href="#c71d3ae144b3c0406eaf94effa2e1687"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#33a44136fea5a049d129a133afa52eb0">wakeCaller</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">De-block the thread that has invoked a blocking <a class="el" href="class_mc_worker_thread.html#c71d3ae144b3c0406eaf94effa2e1687">start()</a>.  <a href="#33a44136fea5a049d129a133afa52eb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#503d39caf48ed5abfd5e50fd35651cd0">wait</a> (bool &amp;timeoutFlag, unsigned long timeoutMsec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits until the worker thread finished or accepted a suspend or cancel request.  <a href="#503d39caf48ed5abfd5e50fd35651cd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#2222666247810fbe10561da9bb3ffba8">wait</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits until the worker thread finished or accepted a suspend or cancel request.  <a href="#2222666247810fbe10561da9bb3ffba8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#eb29714825f021ec16f923d969d4dde6">suspend</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks the worker thread to suspend its current operation.  <a href="#eb29714825f021ec16f923d969d4dde6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#7c3692fe66b9b6f1c2c7b79b195e7f47">resume</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the worker thread do resume computation.  <a href="#7c3692fe66b9b6f1c2c7b79b195e7f47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#dd3fa362b00ab500e8d649cb5e611e73">cancel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the worker thread to cancel computation.  <a href="#dd3fa362b00ab500e8d649cb5e611e73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#e5d49b61427870a94fa2f75290c577ca">suspended</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the main thread requested the worker thread to pause.  <a href="#e5d49b61427870a94fa2f75290c577ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#f81cdccb75e826e024e15789328bf802">canceled</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the main thread requested the worker thread to pause.  <a href="#f81cdccb75e826e024e15789328bf802"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#4e5fd17f85c66961abfc848db68d3c25">terminate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminates the worker thread.  <a href="#4e5fd17f85c66961abfc848db68d3c25"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#81d46a018b5722a70b17c050b2f93768">test</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#511990c04f771cd8b28c5983fe3c29a0">McWorkerThread</a> (const char *name=&quot;McWorkerThread&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#511990c04f771cd8b28c5983fe3c29a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#64f21bd27099e7fe2d2cbbaa81d67e86">~McWorkerThread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#64f21bd27099e7fe2d2cbbaa81d67e86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#5246ad3779d1dd00ddf400ee607679be">computeCtor</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute constructor.  <a href="#5246ad3779d1dd00ddf400ee607679be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#b4cd3f3337ca3cb6b1665c63fb8606db">compute</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute method.  <a href="#b4cd3f3337ca3cb6b1665c63fb8606db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#7b55b320d8738e4b2979bac5c07c3641">computeDtor</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute destructor.  <a href="#7b55b320d8738e4b2979bac5c07c3641"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">McWorkerThreadPrivate *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#62359f72b612715eab04a2217ce3199b">d</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mc_worker_thread.html#656ef236236a1de4409b27d13d5d7759">McWorkerThreadPrivate</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class implements a worker thread. 
<p>
In contrast to the standard thread class <a class="el" href="class_mc_thread.html">McThread</a> this class provides more sophisticated means of synchronization between the main thread and the worker thread. In particular, the worker thread is running permanently but it waits without consuming resources until the main thread calls <a class="el" href="class_mc_worker_thread.html#c71d3ae144b3c0406eaf94effa2e1687">start()</a>. While the worker thread is running, computation may be paused and resumed, or it may be canncelled completely.<p>
Derived classes should implement <a class="el" href="class_mc_worker_thread.html#b4cd3f3337ca3cb6b1665c63fb8606db">compute()</a>. This method will be executed after the worker thread is started via <a class="el" href="class_mc_worker_thread.html#c71d3ae144b3c0406eaf94effa2e1687">start()</a>. Inside the <a class="el" href="class_mc_worker_thread.html#b4cd3f3337ca3cb6b1665c63fb8606db">compute()</a> method the worker thread should regularly call the two methods <a class="el" href="class_mc_worker_thread.html#e5d49b61427870a94fa2f75290c577ca">suspended()</a> and <a class="el" href="class_mc_worker_thread.html#f81cdccb75e826e024e15789328bf802">canceled()</a> in order to check if the main thread asked the worker thread to pause computation or to cancel it. Both methods simply check an internal state variable and do not require any locking or synchronization procedures. 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="88206116af67c99444a0ae3eb54726b9"></a><!-- doxytag: member="McWorkerThread::State" ref="88206116af67c99444a0ae3eb54726b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9">McWorkerThread::State</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerates all states the worker thread can take on. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="88206116af67c99444a0ae3eb54726b918c8b6613b1904188d789ad255ea4a8a"></a><!-- doxytag: member="TERMINATED" ref="88206116af67c99444a0ae3eb54726b918c8b6613b1904188d789ad255ea4a8a" args="" -->TERMINATED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="88206116af67c99444a0ae3eb54726b9a861252df0ff14e8c14384bb11910cd5"></a><!-- doxytag: member="WAITING" ref="88206116af67c99444a0ae3eb54726b9a861252df0ff14e8c14384bb11910cd5" args="" -->WAITING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="88206116af67c99444a0ae3eb54726b9e91bbb145fbc8a312aad7de2ad49617d"></a><!-- doxytag: member="RUNNING" ref="88206116af67c99444a0ae3eb54726b9e91bbb145fbc8a312aad7de2ad49617d" args="" -->RUNNING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="88206116af67c99444a0ae3eb54726b9a2c35198629ba7bfbd201a8963f3a500"></a><!-- doxytag: member="SUSPENDED" ref="88206116af67c99444a0ae3eb54726b9a2c35198629ba7bfbd201a8963f3a500" args="" -->SUSPENDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="88206116af67c99444a0ae3eb54726b9d2e86f4fdd985f4dd4cc62f84f184df8"></a><!-- doxytag: member="CANCELED" ref="88206116af67c99444a0ae3eb54726b9d2e86f4fdd985f4dd4cc62f84f184df8" args="" -->CANCELED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="88206116af67c99444a0ae3eb54726b9a6176877f3d5078f186e4dc8ea015240"></a><!-- doxytag: member="SHOULD_SUSPEND" ref="88206116af67c99444a0ae3eb54726b9a6176877f3d5078f186e4dc8ea015240" args="" -->SHOULD_SUSPEND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="88206116af67c99444a0ae3eb54726b91e795b099e9b0660ad4a3d29fb9e0ca2"></a><!-- doxytag: member="SHOULD_CANCEL" ref="88206116af67c99444a0ae3eb54726b91e795b099e9b0660ad4a3d29fb9e0ca2" args="" -->SHOULD_CANCEL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="88206116af67c99444a0ae3eb54726b94e1f5dfc7313737655988ee37c2fcaa2"></a><!-- doxytag: member="SHOULD_EXIT" ref="88206116af67c99444a0ae3eb54726b94e1f5dfc7313737655988ee37c2fcaa2" args="" -->SHOULD_EXIT</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="511990c04f771cd8b28c5983fe3c29a0"></a><!-- doxytag: member="McWorkerThread::McWorkerThread" ref="511990c04f771cd8b28c5983fe3c29a0" args="(const char *name=&quot;McWorkerThread&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">McWorkerThread::McWorkerThread           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>&quot;McWorkerThread&quot;</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
The constructor does not actually start the working thread. This happens on-the-fly the first time <a class="el" href="class_mc_worker_thread.html#c71d3ae144b3c0406eaf94effa2e1687">start()</a> is called from the main thread. 
</div>
</div><p>
<a class="anchor" name="64f21bd27099e7fe2d2cbbaa81d67e86"></a><!-- doxytag: member="McWorkerThread::~McWorkerThread" ref="64f21bd27099e7fe2d2cbbaa81d67e86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual McWorkerThread::~McWorkerThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Derived classes should implement their own descructor and call <a class="el" href="class_mc_worker_thread.html#4e5fd17f85c66961abfc848db68d3c25">terminate()</a> in it. This is necessary in order to ensure that an overloaded version of <a class="el" href="class_mc_worker_thread.html#7b55b320d8738e4b2979bac5c07c3641">computeDtor()</a> will be called when the worker thread terminates. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="fa84b8337330f72d40e0fd163c4483b7"></a><!-- doxytag: member="McWorkerThread::setName" ref="fa84b8337330f72d40e0fd163c4483b7" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void McWorkerThread::setName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the name of the worker thread. 
<p>
The name is not used internally but may be helpful for testing and debugging. 
</div>
</div><p>
<a class="anchor" name="60260205258ba3f1941b6623a7e6ea9a"></a><!-- doxytag: member="McWorkerThread::name" ref="60260205258ba3f1941b6623a7e6ea9a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* McWorkerThread::name           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the worker thread. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="class_mc_worker_thread.html#fa84b8337330f72d40e0fd163c4483b7">setName()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5c1f42f055ce48c5178d24d97f2e158"></a><!-- doxytag: member="McWorkerThread::state" ref="e5c1f42f055ce48c5178d24d97f2e158" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_worker_thread.html#88206116af67c99444a0ae3eb54726b9">State</a> McWorkerThread::state           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current state of the worker thread. 
<p>

</div>
</div><p>
<a class="anchor" name="c71d3ae144b3c0406eaf94effa2e1687"></a><!-- doxytag: member="McWorkerThread::start" ref="c71d3ae144b3c0406eaf94effa2e1687" args="(bool inBlocking=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool McWorkerThread::start           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inBlocking</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts working. 
<p>
This method assigns the worker thread to call <a class="el" href="class_mc_worker_thread.html#b4cd3f3337ca3cb6b1665c63fb8606db">compute()</a>. The method returns false if the worker thread is not waiting when calling this method. If inBlocking is set to true, the method blocks until the worker thread de-blocked the caller from inside <a class="el" href="class_mc_worker_thread.html#b4cd3f3337ca3cb6b1665c63fb8606db">compute()</a> or <a class="el" href="class_mc_worker_thread.html#b4cd3f3337ca3cb6b1665c63fb8606db">compute()</a> terminated. 
</div>
</div><p>
<a class="anchor" name="33a44136fea5a049d129a133afa52eb0"></a><!-- doxytag: member="McWorkerThread::wakeCaller" ref="33a44136fea5a049d129a133afa52eb0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void McWorkerThread::wakeCaller           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
De-block the thread that has invoked a blocking <a class="el" href="class_mc_worker_thread.html#c71d3ae144b3c0406eaf94effa2e1687">start()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="503d39caf48ed5abfd5e50fd35651cd0"></a><!-- doxytag: member="McWorkerThread::wait" ref="503d39caf48ed5abfd5e50fd35651cd0" args="(bool &amp;timeoutFlag, unsigned long timeoutMsec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool McWorkerThread::wait           </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>timeoutFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>timeoutMsec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits until the worker thread finished or accepted a suspend or cancel request. 
<p>
A time out interval can be specified in <code>timeoutMsec</code> (to be specified in milliseconds). If <code>timeoutMsec</code> is set to ULONG_MAX, the method will wait without a time limit. The parameter <code>timeoutFlag</code> will be set to <code>true</code> is a time out occurred. Otherwise, it will be set to <code>false</code>. The method returns <code>true</code> if the worker thread was actually running when this method was called (so the return value indicates whether the method waited at all or not). If the thread was not running, the method immediately returns <code>false</code> (and <code>timeoutFlag</code> is set to <code>false</code> as well). 
</div>
</div><p>
<a class="anchor" name="2222666247810fbe10561da9bb3ffba8"></a><!-- doxytag: member="McWorkerThread::wait" ref="2222666247810fbe10561da9bb3ffba8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool McWorkerThread::wait           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits until the worker thread finished or accepted a suspend or cancel request. 
<p>
This is an overloaded member function, provided for convenience. It essentially behaves like the above method, but it will wait without a time limit. 
</div>
</div><p>
<a class="anchor" name="eb29714825f021ec16f923d969d4dde6"></a><!-- doxytag: member="McWorkerThread::suspend" ref="eb29714825f021ec16f923d969d4dde6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool McWorkerThread::suspend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks the worker thread to suspend its current operation. 
<p>
The method returns immediately. In order to wait for the worker thread to actually react on the suspend request, you should call <a class="el" href="class_mc_worker_thread.html#2222666247810fbe10561da9bb3ffba8">wait()</a>. The worker thread should call <a class="el" href="class_mc_worker_thread.html#eb29714825f021ec16f923d969d4dde6">suspend()</a> in regular intervals. 
</div>
</div><p>
<a class="anchor" name="7c3692fe66b9b6f1c2c7b79b195e7f47"></a><!-- doxytag: member="McWorkerThread::resume" ref="7c3692fe66b9b6f1c2c7b79b195e7f47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool McWorkerThread::resume           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells the worker thread do resume computation. 
<p>
Calling this method causes the worker thread to return from a previous call of <a class="el" href="class_mc_worker_thread.html#eb29714825f021ec16f923d969d4dde6">suspend()</a>. The method returns false if the worker thread was not sucessfully suspended via <a class="el" href="class_mc_worker_thread.html#eb29714825f021ec16f923d969d4dde6">suspend()</a>. 
</div>
</div><p>
<a class="anchor" name="dd3fa362b00ab500e8d649cb5e611e73"></a><!-- doxytag: member="McWorkerThread::cancel" ref="dd3fa362b00ab500e8d649cb5e611e73" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool McWorkerThread::cancel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells the worker thread to cancel computation. 
<p>
If this method is called, a subsequent call to <a class="el" href="class_mc_worker_thread.html#f81cdccb75e826e024e15789328bf802">canceled()</a> in the worker thread returns true, indicating that the worker thread should cancel its current computation. The method does not block. In order to ensure that the current operation was actually canceled or finished, call <a class="el" href="class_mc_worker_thread.html#2222666247810fbe10561da9bb3ffba8">wait()</a>. The method works on a suspended worker thread as well. Suspended threads are automatically resumed, to allow them to cleanly cancel the computation. 
</div>
</div><p>
<a class="anchor" name="e5d49b61427870a94fa2f75290c577ca"></a><!-- doxytag: member="McWorkerThread::suspended" ref="e5d49b61427870a94fa2f75290c577ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool McWorkerThread::suspended           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the main thread requested the worker thread to pause. 
<p>
This method should be called frequently inside the <a class="el" href="class_mc_worker_thread.html#b4cd3f3337ca3cb6b1665c63fb8606db">compute()</a> method of the worker thread. If the main thread called <a class="el" href="class_mc_worker_thread.html#eb29714825f021ec16f923d969d4dde6">suspend()</a>, the method blocks until the main thread calls <a class="el" href="class_mc_worker_thread.html#7c3692fe66b9b6f1c2c7b79b195e7f47">resume()</a>. The method returns true if computation was actually paused. This allows the worker thread to check if some resources have to be reallocated or reinitialized. 
</div>
</div><p>
<a class="anchor" name="f81cdccb75e826e024e15789328bf802"></a><!-- doxytag: member="McWorkerThread::canceled" ref="f81cdccb75e826e024e15789328bf802" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool McWorkerThread::canceled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the main thread requested the worker thread to pause. 
<p>
This method should be called frequently inside the <a class="el" href="class_mc_worker_thread.html#b4cd3f3337ca3cb6b1665c63fb8606db">compute()</a> method of the worker thread. 
</div>
</div><p>
<a class="anchor" name="4e5fd17f85c66961abfc848db68d3c25"></a><!-- doxytag: member="McWorkerThread::terminate" ref="4e5fd17f85c66961abfc848db68d3c25" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void McWorkerThread::terminate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Terminates the worker thread. 
<p>
This method should be called from the destructor of a derived class. It terminates the worker thread, calling the overloaded version of <a class="el" href="class_mc_worker_thread.html#7b55b320d8738e4b2979bac5c07c3641">computeDtor()</a>. 
</div>
</div><p>
<a class="anchor" name="81d46a018b5722a70b17c050b2f93768"></a><!-- doxytag: member="McWorkerThread::test" ref="81d46a018b5722a70b17c050b2f93768" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void McWorkerThread::test           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5246ad3779d1dd00ddf400ee607679be"></a><!-- doxytag: member="McWorkerThread::computeCtor" ref="5246ad3779d1dd00ddf400ee607679be" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void McWorkerThread::computeCtor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute constructor. 
<p>
This method is called synchronously inside the worker thread when the main thread the first time calls <a class="el" href="class_mc_worker_thread.html#c71d3ae144b3c0406eaf94effa2e1687">start()</a>. 
</div>
</div><p>
<a class="anchor" name="b4cd3f3337ca3cb6b1665c63fb8606db"></a><!-- doxytag: member="McWorkerThread::compute" ref="b4cd3f3337ca3cb6b1665c63fb8606db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void McWorkerThread::compute           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute method. 
<p>
This method will be called asynchronously inside the worker thread when the main thread calls <a class="el" href="class_mc_worker_thread.html#c71d3ae144b3c0406eaf94effa2e1687">start()</a>. 
</div>
</div><p>
<a class="anchor" name="7b55b320d8738e4b2979bac5c07c3641"></a><!-- doxytag: member="McWorkerThread::computeDtor" ref="7b55b320d8738e4b2979bac5c07c3641" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void McWorkerThread::computeDtor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute destructor. 
<p>
This method is called synchronously inside the worker thread when the main thread calls <a class="el" href="class_mc_worker_thread.html#4e5fd17f85c66961abfc848db68d3c25">terminate()</a>. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="656ef236236a1de4409b27d13d5d7759"></a><!-- doxytag: member="McWorkerThread::McWorkerThreadPrivate" ref="656ef236236a1de4409b27d13d5d7759" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class McWorkerThreadPrivate<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="62359f72b612715eab04a2217ce3199b"></a><!-- doxytag: member="McWorkerThread::d" ref="62359f72b612715eab04a2217ce3199b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">McWorkerThreadPrivate* <a class="el" href="class_mc_worker_thread.html#62359f72b612715eab04a2217ce3199b">McWorkerThread::d</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>mclibthreaded/<a class="el" href="_mc_worker_thread_8h.html">McWorkerThread.h</a></ul>
<hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
