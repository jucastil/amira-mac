<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: HxPlanarMod Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>HxPlanarMod Class Reference<br>
<small>
[<a class="el" href="group__hxcore.html">hxcore</a>]</small>
</h1><!-- doxytag: class="HxPlanarMod" --><!-- doxytag: inherits="HxModule" -->Base class for all cutting plane modules.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;hxcore/HxPlanarMod.h&gt;</code>
<p>
<p>Inheritance diagram for HxPlanarMod:
<p><center><img src="class_hx_planar_mod.png" usemap="#HxPlanarMod_map" border="0" alt=""></center>
<map name="HxPlanarMod_map">
<area href="class_hx_module.html" alt="HxModule" shape="rect" coords="67,224,192,248">
<area href="class_hx_object.html" alt="HxObject" shape="rect" coords="67,168,192,192">
<area href="class_hx_base.html" alt="HxBase" shape="rect" coords="67,112,192,136">
<area href="class_mc_interface.html" alt="McInterface" shape="rect" coords="67,56,192,80">
<area href="class_mc_typed_object.html" alt="McTypedObject" shape="rect" coords="67,0,192,24">
<area href="class_hx_arbitrary_cut.html" alt="HxArbitraryCut" shape="rect" coords="0,336,125,360">
<area href="class_hx_ortho_slice_l_d_m.html" alt="HxOrthoSliceLDM" shape="rect" coords="135,336,260,360">
<area href="class_hx_oblique_slice_l_d_m.html" alt="HxObliqueSliceLDM" shape="rect" coords="0,392,125,416">
</map>
<a href="class_hx_planar_mod-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae68808a5de286cd47f98ccafbb968d8e8d1205">XY</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae6880805f1fe54e4a2b01a4936b04359f9aabb">XZ</a> = 1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae688086c3ae744cfe1c595a028f04a7228c8c2">YZ</a> = 2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae68808">OrthoPlane</a> { <a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae68808a5de286cd47f98ccafbb968d8e8d1205">XY</a> =  0, 
<a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae6880805f1fe54e4a2b01a4936b04359f9aabb">XZ</a> =  1, 
<a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae688086c3ae744cfe1c595a028f04a7228c8c2">YZ</a> =  2
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SbVec3f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#2e82766c8b4276d0dcaba3990b584b13">origin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns point on plane (lower left corner or center ?).  <a href="#2e82766c8b4276d0dcaba3990b584b13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const SbVec3f &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#f71c68d840e449dd63653f98dd2a0150">uVec</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns base vector in u direction.  <a href="#f71c68d840e449dd63653f98dd2a0150"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const SbVec3f &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#5f8610f398334ef2b0213ce341a9cf9b">vVec</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns base vector in v direction.  <a href="#5f8610f398334ef2b0213ce341a9cf9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SbVec3f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#be1cdca10fe2a9f0dd5d9fb9713c9b02">normal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns plane normal.  <a href="#be1cdca10fe2a9f0dd5d9fb9713c9b02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SbVec3f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#daea570a29fc6f19912869022411e57a">clippingNormal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns normal of clipping plane.  <a href="#daea570a29fc6f19912869022411e57a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_mc_box3f.html">McBox3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#b819f6cfce62172431bc096d0b82c570">boundingBox</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the bounding box of the underlying data set. Is empty if bounding the box is not given.  <a href="#b819f6cfce62172431bc096d0b82c570"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#0040fb076eb73bcc7c985ba583a27586">setAlphaPolicy</a> (<a class="el" href="class_so_decal.html#3f87e103b1380576deab001fa877fb2a">SoDecal::AlphaPolicy</a> policy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables Inventor's DELAY mechanism or binary ALPHATEST.  <a href="#0040fb076eb73bcc7c985ba583a27586"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#5889fd11ebc1789ecb996dd31737e6b6">addOverlay</a> (SoNode *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add some overlay geometry.  <a href="#5889fd11ebc1789ecb996dd31737e6b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#42df11d1c66ee94e884eb4338c7dd2b1">addBackground</a> (SoNode *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add some background geometry.  <a href="#42df11d1c66ee94e884eb4338c7dd2b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#493b80ec3bf9f6644cb32815a0d123e0">removeOverlay</a> (SoNode *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove overlay child.  <a href="#493b80ec3bf9f6644cb32815a0d123e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#f9a75ab1cb4007bfac574cbf6d3e27d5">removeBackground</a> (SoNode *node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove background child.  <a href="#f9a75ab1cb4007bfac574cbf6d3e27d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#57dc543ff35c175307dd2b4cc2a837c7">showDecal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show plane.  <a href="#57dc543ff35c175307dd2b4cc2a837c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#38d687f811226d75164ffa70ea03a3a0">hideDecal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hide plane.  <a href="#38d687f811226d75164ffa70ea03a3a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#08312ea2bd120c4a2c798aa97650134b">planeIsNew</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This may be used by derived modules to check if plane has changed.  <a href="#08312ea2bd120c4a2c798aa97650134b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#ca1369471d5eaf0aa46f9db4cf2c15ac">planeTouch</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dragger may call this to indicate a plane change.  <a href="#ca1369471d5eaf0aa46f9db4cf2c15ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#126e835df153f2a1029bfe4c588707e6">planeUntouch</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unset plane touched flag.  <a href="#126e835df153f2a1029bfe4c588707e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#a9473c241e5b6d6eec17177b2c160110">invertClippingPlane</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverts the clipping plane.  <a href="#a9473c241e5b6d6eec17177b2c160110"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#e8b6486d5f783a20944630a93236f1a4">isClippingPlaneInverted</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if clipping plane is inverted.  <a href="#e8b6486d5f783a20944630a93236f1a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#f3f8e76347cd9a18ec732ff682c50af4">isAutoClippingPlane</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if clipping plane is in autoClipping mode, false otherwise.  <a href="#f3f8e76347cd9a18ec732ff682c50af4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#bfea2398c276ceb552dbf55e7c90bf2e">isClipping</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if some other module is clipped by this plane.  <a href="#bfea2398c276ceb552dbf55e7c90bf2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#1a6e742e212e5b09d49026bf631ce136">createClipPlane</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if clip plane is already created.  <a href="#1a6e742e212e5b09d49026bf631ce136"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#50102500a2d7b9b45f4f6870d775a57e">setAutoClippingPlane</a> (bool autoState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the clip plane autoClipping mode.  <a href="#50102500a2d7b9b45f4f6870d775a57e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#55e9c79188e4827fc2298230590a2ba8">adjustView</a> (int orientation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset viewers (not plane) to one of the major axes.  <a href="#55e9c79188e4827fc2298230590a2ba8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#86665a54df1594332a311ce194f13279">computeFrame</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; SbVec3f &gt; &amp;frameCoords, const float offset=0.f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method computes the coordinates of the polygon which is the intersection of the bounding box with the current plane.  <a href="#86665a54df1594332a311ce194f13279"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_mc_color.html">McColor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#f5606d01cca999df82abbf9842854836">getIconColor</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Planar modules are lightsalmon.  <a href="#f5606d01cca999df82abbf9842854836"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#f241d22c162de54f7da7a870772bc8a8">parse</a> (Tcl_Interp *, int argc, char **argv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse method.  <a href="#f241d22c162de54f7da7a870772bc8a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#7891dbc26914b5ba0d9401643bc0c367">fire</a> (int shouldCompute=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls <a class="el" href="class_hx_planar_mod.html#126e835df153f2a1029bfe4c588707e6">planeUntouch()</a> if necessary.  <a href="#7891dbc26914b5ba0d9401643bc0c367"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#3a69c209a6a94130cb5acff733368700">setPolygonOffsetEnabled</a> (bool value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set to true an SoPolygonOffset node is inserted into the scene graph before all other nodes of the palnar module.  <a href="#3a69c209a6a94130cb5acff733368700"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#62a2e4d0445683c365e6258d008a50bc">getPolygonOffsetEnabled</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the module's geometry is rendered with polygon offset enabled or not.  <a href="#62a2e4d0445683c365e6258d008a50bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#52465f0bb36af63e910c91177190a9a9">getPlaneLength</a> (float &amp;uLength, float &amp;vLength, float *uMin=0, float *vMin=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return plane length into the plane coordinate system ( untransformed and without bounding box care).  <a href="#52465f0bb36af63e910c91177190a9a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#4a9d1289ca82ceb173c107707aa25b0a">enableDragging</a> (bool enableIt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable or Enable translation mouse dragging.  <a href="#4a9d1289ca82ceb173c107707aa25b0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#1b71dec61fe8c933b4630edd9a8b8965">update</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update method.  <a href="#1b71dec61fe8c933b4630edd9a8b8965"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#99a06a49480159553c90373f6577c4c6">connectPlane</a> (<a class="el" href="class_hx_planar_mod.html">HxPlanarMod</a> *planarMod, bool state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect or disconnect to other planarMod by interconnecting portOrigin &amp; portNormal depending on state flag.  <a href="#99a06a49480159553c90373f6577c4c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#afdaef8fa4fe7035d49e00634e4819f0">resetRepToOrthoPlane</a> (<a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae68808">OrthoPlane</a> orthoPlane)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method allows this plane and graphical representations displayed by inherited class over this plane to reset them to one of the 3 major orthogonal planes.  <a href="#afdaef8fa4fe7035d49e00634e4819f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#46a07bc3319a7c5ab84f8cbd6e96a855">updatePlaneFromPorts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update plane properties from normal &amp; origin.  <a href="#46a07bc3319a7c5ab84f8cbd6e96a855"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_hx_port3_d_point_list.html">HxPort3DPointList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#6413e29fa2299c03f080cd5cd74265e4">portOrigin</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Port defining plane origin.  <a href="#6413e29fa2299c03f080cd5cd74265e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_hx_port3_d_point_list.html">HxPort3DPointList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#408d2d4ddf662c4a74de32533d9bcaec">portNormal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Port defining plane normal.  <a href="#408d2d4ddf662c4a74de32533d9bcaec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_hx_port_generic.html">HxPortGeneric</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#894a3d388c296f8ceb85de558965d6de">portFrame</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show or hide frame, set frame width, set frame color.  <a href="#894a3d388c296f8ceb85de558965d6de"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#928fd19734336a767ed3371833353a16">HxPlanarMod</a> (const <a class="el" href="class_mc_type_info.html">McTypeInfo</a> *dataType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#166829e6b4d61eb290e9126bbd91b64c">~HxPlanarMod</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#b948b742375279c3e12599974cd89c1a">planeSet</a> (const SbVec3f &amp;orig, const SbVec3f &amp;uVec, const SbVec3f &amp;vVec, const SbVec3f &amp;norm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets clipping plane.  <a href="#b948b742375279c3e12599974cd89c1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#29b4173c98e62cb5c9f84b11ee5c84df">planeSetXY</a> (const SbVec3f &amp;origin, float u=1, float v=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets clipping plane.  <a href="#29b4173c98e62cb5c9f84b11ee5c84df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#3a0eb037ee014065be5b0b49b5cb1c13">planeSetZX</a> (const SbVec3f &amp;origin, float u=1, float v=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets clipping plane.  <a href="#3a0eb037ee014065be5b0b49b5cb1c13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#e4b81a5058334709e3dc124053c3dedf">planeSetYZ</a> (const SbVec3f &amp;origin, float u=1, float v=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets clipping plane.  <a href="#e4b81a5058334709e3dc124053c3dedf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#1fc362405a759542918f43fcb06fcc58">planeSetOrig</a> (const SbVec3f &amp;origin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the origin of the clipping plane.  <a href="#1fc362405a759542918f43fcb06fcc58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#d77066d6d33ac5b9f9faaef747eb2e7f">planeInit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the clipping plane to be the XY plane.  <a href="#d77066d6d33ac5b9f9faaef747eb2e7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#a22e3bde229eb48800c19ddfd156a040">transform</a> (const SbMatrix &amp;mat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the clipping plane using the given transformation matrix.  <a href="#a22e3bde229eb48800c19ddfd156a040"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#ace936009b8c6526307fa3d3b63223a4">isFirst</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if there are no planar modules in object pool yet.  <a href="#ace936009b8c6526307fa3d3b63223a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#e9fe4e5c1d343744dfc83bf414274772">updateClipPlane</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates clipping plane considering controlling data.  <a href="#e9fe4e5c1d343744dfc83bf414274772"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#94e4c60fd66a5e4c058239fcd06b7af4">updateDraggingActiveState</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Must be implemented by inherited classes in order to activate or deactivate plane dragging.  <a href="#94e4c60fd66a5e4c058239fcd06b7af4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#d59c5a08f3f47f963ccd0a5618ca02de">resetRepToOrthoPlane</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the connected data represents a 2D data set, automatically reset graphical representations to the plane defined by the 2D data.  <a href="#d59c5a08f3f47f963ccd0a5618ca02de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#af70c0a9065c384a4f702ffb4d1ca772">is2DData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if input represents a 2D data.  <a href="#af70c0a9065c384a4f702ffb4d1ca772"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#909f41a18dbc13506881107c072d4818">find2DPlane</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the 2D plane connected to the portData.  <a href="#909f41a18dbc13506881107c072d4818"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#6bf28190161b1a759169359295485a30">setPlaneControllerPortsVisible</a> (bool areVisibles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper method to set visibility of all ports which control the plane definition (translation and orientation).  <a href="#6bf28190161b1a759169359295485a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_hx_port.html">HxPort</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#9dccd084306925ed21d322b9913ba601">getTranslationPort</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inherited classes will have to return the port which will control the plane translation.  <a href="#9dccd084306925ed21d322b9913ba601"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_hx_port.html">HxPort</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#3bc309947eaf03bb41bb35f706675637">getResetToOrthoPlanePort</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inherited classes will have to return the port which will be in charge of aligning the plane to a XY, XZ or YZ plane.  <a href="#3bc309947eaf03bb41bb35f706675637"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SbVec3f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#737ab627ffd7055f73c412287689909f">puVec</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SbVec3f&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#5adbcc176184eecbde29f4b4790a7036">pvVec</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#de3f16ee44f3501c052ff545cbc9026e">changed</a>:1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#1dbba4d7c0ada026496c1858e95a906f">invert</a>:1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_so_decal.html">SoDecal</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#784abc6f32962abc10b8188deb6f9218">decal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_so_auto_clip_plane.html">SoAutoClipPlane</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#361bbd4b25d16c425f72726f984beaec">clipPlane</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_hx_base.html">HxBase</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#cb9970dc61a2c35295c52a4ef13c5359">clippedModules</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_handle.html">McHandle</a>&lt; SoSeparator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#e57b13ecd4d4c99324f8f0f5db7974af">m_separator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#e52e717bcfa7743d952f7fef0d8b1570">m_isDraggingEnabled</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To know if we allow plane dragging.  <a href="#e52e717bcfa7743d952f7fef0d8b1570"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#e5b953b4adef7ffc2a4c21b2b1da18ab">m_is2DData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To know if the connected is a kind of image.  <a href="#e5b953b4adef7ffc2a4c21b2b1da18ab"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_planar_mod.html#169ac695509edbc9c163e382cf4863fa">HxBase</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for all cutting plane modules. 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="d7b5fd6333e5de5c3e1bfe464ae68808"></a><!-- doxytag: member="HxPlanarMod::OrthoPlane" ref="d7b5fd6333e5de5c3e1bfe464ae68808" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae68808">HxPlanarMod::OrthoPlane</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="d7b5fd6333e5de5c3e1bfe464ae68808a5de286cd47f98ccafbb968d8e8d1205"></a><!-- doxytag: member="XY" ref="d7b5fd6333e5de5c3e1bfe464ae68808a5de286cd47f98ccafbb968d8e8d1205" args="" -->XY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="d7b5fd6333e5de5c3e1bfe464ae6880805f1fe54e4a2b01a4936b04359f9aabb"></a><!-- doxytag: member="XZ" ref="d7b5fd6333e5de5c3e1bfe464ae6880805f1fe54e4a2b01a4936b04359f9aabb" args="" -->XZ</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="d7b5fd6333e5de5c3e1bfe464ae688086c3ae744cfe1c595a028f04a7228c8c2"></a><!-- doxytag: member="YZ" ref="d7b5fd6333e5de5c3e1bfe464ae688086c3ae744cfe1c595a028f04a7228c8c2" args="" -->YZ</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="928fd19734336a767ed3371833353a16"></a><!-- doxytag: member="HxPlanarMod::HxPlanarMod" ref="928fd19734336a767ed3371833353a16" args="(const McTypeInfo *dataType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HxPlanarMod::HxPlanarMod           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mc_type_info.html">McTypeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>dataType</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="166829e6b4d61eb290e9126bbd91b64c"></a><!-- doxytag: member="HxPlanarMod::~HxPlanarMod" ref="166829e6b4d61eb290e9126bbd91b64c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual HxPlanarMod::~HxPlanarMod           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2e82766c8b4276d0dcaba3990b584b13"></a><!-- doxytag: member="HxPlanarMod::origin" ref="2e82766c8b4276d0dcaba3990b584b13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbVec3f HxPlanarMod::origin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns point on plane (lower left corner or center ?). 
<p>

</div>
</div><p>
<a class="anchor" name="f71c68d840e449dd63653f98dd2a0150"></a><!-- doxytag: member="HxPlanarMod::uVec" ref="f71c68d840e449dd63653f98dd2a0150" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SbVec3f&amp; HxPlanarMod::uVec           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns base vector in u direction. 
<p>

</div>
</div><p>
<a class="anchor" name="5f8610f398334ef2b0213ce341a9cf9b"></a><!-- doxytag: member="HxPlanarMod::vVec" ref="5f8610f398334ef2b0213ce341a9cf9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SbVec3f&amp; HxPlanarMod::vVec           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns base vector in v direction. 
<p>

</div>
</div><p>
<a class="anchor" name="be1cdca10fe2a9f0dd5d9fb9713c9b02"></a><!-- doxytag: member="HxPlanarMod::normal" ref="be1cdca10fe2a9f0dd5d9fb9713c9b02" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbVec3f HxPlanarMod::normal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns plane normal. 
<p>

</div>
</div><p>
<a class="anchor" name="daea570a29fc6f19912869022411e57a"></a><!-- doxytag: member="HxPlanarMod::clippingNormal" ref="daea570a29fc6f19912869022411e57a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbVec3f HxPlanarMod::clippingNormal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns normal of clipping plane. 
<p>

</div>
</div><p>
<a class="anchor" name="b819f6cfce62172431bc096d0b82c570"></a><!-- doxytag: member="HxPlanarMod::boundingBox" ref="b819f6cfce62172431bc096d0b82c570" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_mc_box3f.html">McBox3f</a> HxPlanarMod::boundingBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the bounding box of the underlying data set. Is empty if bounding the box is not given. 
<p>

<p>
Reimplemented in <a class="el" href="class_hx_arbitrary_cut.html#ea5136f8ca4a3031d32dbf250e3f1f49">HxArbitraryCut</a>.
</div>
</div><p>
<a class="anchor" name="0040fb076eb73bcc7c985ba583a27586"></a><!-- doxytag: member="HxPlanarMod::setAlphaPolicy" ref="0040fb076eb73bcc7c985ba583a27586" args="(SoDecal::AlphaPolicy policy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::setAlphaPolicy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_so_decal.html#3f87e103b1380576deab001fa877fb2a">SoDecal::AlphaPolicy</a>&nbsp;</td>
          <td class="paramname"> <em>policy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables Inventor's DELAY mechanism or binary ALPHATEST. 
<p>

</div>
</div><p>
<a class="anchor" name="5889fd11ebc1789ecb996dd31737e6b6"></a><!-- doxytag: member="HxPlanarMod::addOverlay" ref="5889fd11ebc1789ecb996dd31737e6b6" args="(SoNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::addOverlay           </td>
          <td>(</td>
          <td class="paramtype">SoNode *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add some overlay geometry. 
<p>

</div>
</div><p>
<a class="anchor" name="42df11d1c66ee94e884eb4338c7dd2b1"></a><!-- doxytag: member="HxPlanarMod::addBackground" ref="42df11d1c66ee94e884eb4338c7dd2b1" args="(SoNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::addBackground           </td>
          <td>(</td>
          <td class="paramtype">SoNode *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add some background geometry. 
<p>

</div>
</div><p>
<a class="anchor" name="493b80ec3bf9f6644cb32815a0d123e0"></a><!-- doxytag: member="HxPlanarMod::removeOverlay" ref="493b80ec3bf9f6644cb32815a0d123e0" args="(SoNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::removeOverlay           </td>
          <td>(</td>
          <td class="paramtype">SoNode *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove overlay child. 
<p>

</div>
</div><p>
<a class="anchor" name="f9a75ab1cb4007bfac574cbf6d3e27d5"></a><!-- doxytag: member="HxPlanarMod::removeBackground" ref="f9a75ab1cb4007bfac574cbf6d3e27d5" args="(SoNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::removeBackground           </td>
          <td>(</td>
          <td class="paramtype">SoNode *&nbsp;</td>
          <td class="paramname"> <em>node</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove background child. 
<p>

</div>
</div><p>
<a class="anchor" name="57dc543ff35c175307dd2b4cc2a837c7"></a><!-- doxytag: member="HxPlanarMod::showDecal" ref="57dc543ff35c175307dd2b4cc2a837c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::showDecal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show plane. 
<p>

</div>
</div><p>
<a class="anchor" name="38d687f811226d75164ffa70ea03a3a0"></a><!-- doxytag: member="HxPlanarMod::hideDecal" ref="38d687f811226d75164ffa70ea03a3a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::hideDecal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hide plane. 
<p>

</div>
</div><p>
<a class="anchor" name="08312ea2bd120c4a2c798aa97650134b"></a><!-- doxytag: member="HxPlanarMod::planeIsNew" ref="08312ea2bd120c4a2c798aa97650134b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HxPlanarMod::planeIsNew           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This may be used by derived modules to check if plane has changed. 
<p>

</div>
</div><p>
<a class="anchor" name="ca1369471d5eaf0aa46f9db4cf2c15ac"></a><!-- doxytag: member="HxPlanarMod::planeTouch" ref="ca1369471d5eaf0aa46f9db4cf2c15ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::planeTouch           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A dragger may call this to indicate a plane change. 
<p>

</div>
</div><p>
<a class="anchor" name="126e835df153f2a1029bfe4c588707e6"></a><!-- doxytag: member="HxPlanarMod::planeUntouch" ref="126e835df153f2a1029bfe4c588707e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::planeUntouch           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unset plane touched flag. 
<p>

</div>
</div><p>
<a class="anchor" name="a9473c241e5b6d6eec17177b2c160110"></a><!-- doxytag: member="HxPlanarMod::invertClippingPlane" ref="a9473c241e5b6d6eec17177b2c160110" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::invertClippingPlane           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inverts the clipping plane. 
<p>

</div>
</div><p>
<a class="anchor" name="e8b6486d5f783a20944630a93236f1a4"></a><!-- doxytag: member="HxPlanarMod::isClippingPlaneInverted" ref="e8b6486d5f783a20944630a93236f1a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HxPlanarMod::isClippingPlaneInverted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if clipping plane is inverted. 
<p>
If the clipping plane is inverted all geometry below the plane is clipped. Otherwise all geometry above the plane is clipped. 
</div>
</div><p>
<a class="anchor" name="f3f8e76347cd9a18ec732ff682c50af4"></a><!-- doxytag: member="HxPlanarMod::isAutoClippingPlane" ref="f3f8e76347cd9a18ec732ff682c50af4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HxPlanarMod::isAutoClippingPlane           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if clipping plane is in autoClipping mode, false otherwise. 
<p>

</div>
</div><p>
<a class="anchor" name="bfea2398c276ceb552dbf55e7c90bf2e"></a><!-- doxytag: member="HxPlanarMod::isClipping" ref="bfea2398c276ceb552dbf55e7c90bf2e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HxPlanarMod::isClipping           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if some other module is clipped by this plane. 
<p>

</div>
</div><p>
<a class="anchor" name="1a6e742e212e5b09d49026bf631ce136"></a><!-- doxytag: member="HxPlanarMod::createClipPlane" ref="1a6e742e212e5b09d49026bf631ce136" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::createClipPlane           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if clip plane is already created. 
<p>
If not, create it 
</div>
</div><p>
<a class="anchor" name="50102500a2d7b9b45f4f6870d775a57e"></a><!-- doxytag: member="HxPlanarMod::setAutoClippingPlane" ref="50102500a2d7b9b45f4f6870d775a57e" args="(bool autoState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::setAutoClippingPlane           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoState</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the clip plane autoClipping mode. 
<p>
If auto mode is set, the clipping plane is adjusted to clip the front of the plane related to the camera position, otherwise the clipping plane uses the <a class="el" href="class_hx_planar_mod.html">HxPlanarMod</a> normal. 
</div>
</div><p>
<a class="anchor" name="55e9c79188e4827fc2298230590a2ba8"></a><!-- doxytag: member="HxPlanarMod::adjustView" ref="55e9c79188e4827fc2298230590a2ba8" args="(int orientation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::adjustView           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>orientation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset viewers (not plane) to one of the major axes. 
<p>
Set <code>orientation</code> to 0,1, or 2 for X, Y, or Z direction. 
</div>
</div><p>
<a class="anchor" name="86665a54df1594332a311ce194f13279"></a><!-- doxytag: member="HxPlanarMod::computeFrame" ref="86665a54df1594332a311ce194f13279" args="(McDArray&lt; SbVec3f &gt; &amp;frameCoords, const float offset=0.f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::computeFrame           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; SbVec3f &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frameCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>offset</em> = <code>0.f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method computes the coordinates of the polygon which is the intersection of the bounding box with the current plane. 
<p>
The coordinates will be sorted such that when connecting consecutive coords the resulting polyhedral line will form the polygon boundary. The offset can be used to compute the polygon where the current plane is offset by the <code>offset</code> value. 
</div>
</div><p>
<a class="anchor" name="f5606d01cca999df82abbf9842854836"></a><!-- doxytag: member="HxPlanarMod::getIconColor" ref="f5606d01cca999df82abbf9842854836" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_mc_color.html">McColor</a> HxPlanarMod::getIconColor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Planar modules are lightsalmon. 
<p>

<p>
Reimplemented from <a class="el" href="class_hx_module.html#40403e8f4677b0a67779bb978826a577">HxModule</a>.
</div>
</div><p>
<a class="anchor" name="f241d22c162de54f7da7a870772bc8a8"></a><!-- doxytag: member="HxPlanarMod::parse" ref="f241d22c162de54f7da7a870772bc8a8" args="(Tcl_Interp *, int argc, char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int HxPlanarMod::parse           </td>
          <td>(</td>
          <td class="paramtype">Tcl_Interp *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse method. 
<p>

<p>
Reimplemented from <a class="el" href="class_hx_module.html#2bd2cf76decabee18c6c389d2a65fa7e">HxModule</a>.
<p>
Reimplemented in <a class="el" href="class_hx_ortho_slice_l_d_m.html#1a24ac89d561528123ecc72ee6ba04e3">HxOrthoSliceLDM</a>, and <a class="el" href="class_hx_arbitrary_cut.html#fd9ed6910097b173497bdb1f4b3db329">HxArbitraryCut</a>.
</div>
</div><p>
<a class="anchor" name="7891dbc26914b5ba0d9401643bc0c367"></a><!-- doxytag: member="HxPlanarMod::fire" ref="7891dbc26914b5ba0d9401643bc0c367" args="(int shouldCompute=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::fire           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>shouldCompute</em> = <code>1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls <a class="el" href="class_hx_planar_mod.html#126e835df153f2a1029bfe4c588707e6">planeUntouch()</a> if necessary. 
<p>
When the plane position or orientation is modified by calling one of the <a class="el" href="class_hx_planar_mod.html#b948b742375279c3e12599974cd89c1a">planeSet()</a> methods below, a flag is set and <a class="el" href="class_hx_planar_mod.html#08312ea2bd120c4a2c798aa97650134b">planeIsNew()</a> returns true. This flag is reset in this overloaded method after the object's update and compute method have been called and after all downstream objects are fired. 
<p>
Reimplemented from <a class="el" href="class_hx_object.html#063ea1cb961f946057ac1b5a44485df4">HxObject</a>.
</div>
</div><p>
<a class="anchor" name="3a69c209a6a94130cb5acff733368700"></a><!-- doxytag: member="HxPlanarMod::setPolygonOffsetEnabled" ref="3a69c209a6a94130cb5acff733368700" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::setPolygonOffsetEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If set to true an SoPolygonOffset node is inserted into the scene graph before all other nodes of the palnar module. 
<p>
This allows other modules to draw wireframe graphics into the same plane as this module without causing z-buffer fighting. On default, polygon offset is disabled because it introduces artifacts when enabling clipping planes. 
</div>
</div><p>
<a class="anchor" name="62a2e4d0445683c365e6258d008a50bc"></a><!-- doxytag: member="HxPlanarMod::getPolygonOffsetEnabled" ref="62a2e4d0445683c365e6258d008a50bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HxPlanarMod::getPolygonOffsetEnabled           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the module's geometry is rendered with polygon offset enabled or not. 
<p>

</div>
</div><p>
<a class="anchor" name="52465f0bb36af63e910c91177190a9a9"></a><!-- doxytag: member="HxPlanarMod::getPlaneLength" ref="52465f0bb36af63e910c91177190a9a9" args="(float &amp;uLength, float &amp;vLength, float *uMin=0, float *vMin=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxPlanarMod::getPlaneLength           </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>uLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>vLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>uMin</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>vMin</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return plane length into the plane coordinate system ( untransformed and without bounding box care). 
<p>
Optionally, you can also retrieve uMin and vMin coordinates (according to the plane origin). uMin and vMin are the lowest distances of the plane points from origin. 
<p>
Reimplemented in <a class="el" href="class_hx_ortho_slice_l_d_m.html#78cb315eecdc51e2a7c5eb34284bf863">HxOrthoSliceLDM</a>, and <a class="el" href="class_hx_arbitrary_cut.html#a6de4b801acdabde9f2a3f18154b18f9">HxArbitraryCut</a>.
</div>
</div><p>
<a class="anchor" name="4a9d1289ca82ceb173c107707aa25b0a"></a><!-- doxytag: member="HxPlanarMod::enableDragging" ref="4a9d1289ca82ceb173c107707aa25b0a" args="(bool enableIt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::enableDragging           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enableIt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable or Enable translation mouse dragging. 
<p>
This method may have no effect in case inherited classes doesn't have the possibility to drag the plane defined by this class. Default is enabled. 
</div>
</div><p>
<a class="anchor" name="1b71dec61fe8c933b4630edd9a8b8965"></a><!-- doxytag: member="HxPlanarMod::update" ref="1b71dec61fe8c933b4630edd9a8b8965" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxPlanarMod::update           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update method. 
<p>
Mostly check if input represents a 2D data. If yes, it calls virtual methods which will update the module GUI and graphical representations. 
<p>
Reimplemented from <a class="el" href="class_hx_object.html#094ceea17143c9bec9fb34709aebb0b2">HxObject</a>.
<p>
Reimplemented in <a class="el" href="class_hx_ortho_slice_l_d_m.html#c287f5fd2e9a03c33364446c7176c2e4">HxOrthoSliceLDM</a>, <a class="el" href="class_hx_oblique_slice_l_d_m.html#d0be70bc6c19fbb34ebdfcdc984d1955">HxObliqueSliceLDM</a>, and <a class="el" href="class_hx_arbitrary_cut.html#719770742e82bfd750b7bfa3c4c8c71c">HxArbitraryCut</a>.
</div>
</div><p>
<a class="anchor" name="99a06a49480159553c90373f6577c4c6"></a><!-- doxytag: member="HxPlanarMod::connectPlane" ref="99a06a49480159553c90373f6577c4c6" args="(HxPlanarMod *planarMod, bool state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::connectPlane           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hx_planar_mod.html">HxPlanarMod</a> *&nbsp;</td>
          <td class="paramname"> <em>planarMod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect or disconnect to other planarMod by interconnecting portOrigin &amp; portNormal depending on state flag. 
<p>

</div>
</div><p>
<a class="anchor" name="afdaef8fa4fe7035d49e00634e4819f0"></a><!-- doxytag: member="HxPlanarMod::resetRepToOrthoPlane" ref="afdaef8fa4fe7035d49e00634e4819f0" args="(OrthoPlane orthoPlane)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxPlanarMod::resetRepToOrthoPlane           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hx_planar_mod.html#d7b5fd6333e5de5c3e1bfe464ae68808">OrthoPlane</a>&nbsp;</td>
          <td class="paramname"> <em>orthoPlane</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method allows this plane and graphical representations displayed by inherited class over this plane to reset them to one of the 3 major orthogonal planes. 
<p>

</div>
</div><p>
<a class="anchor" name="46a07bc3319a7c5ab84f8cbd6e96a855"></a><!-- doxytag: member="HxPlanarMod::updatePlaneFromPorts" ref="46a07bc3319a7c5ab84f8cbd6e96a855" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxPlanarMod::updatePlaneFromPorts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update plane properties from normal &amp; origin. 
<p>

<p>
Reimplemented in <a class="el" href="class_hx_arbitrary_cut.html#50456900422261544135a925e1129acf">HxArbitraryCut</a>.
</div>
</div><p>
<a class="anchor" name="b948b742375279c3e12599974cd89c1a"></a><!-- doxytag: member="HxPlanarMod::planeSet" ref="b948b742375279c3e12599974cd89c1a" args="(const SbVec3f &amp;orig, const SbVec3f &amp;uVec, const SbVec3f &amp;vVec, const SbVec3f &amp;norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::planeSet           </td>
          <td>(</td>
          <td class="paramtype">const SbVec3f &amp;&nbsp;</td>
          <td class="paramname"> <em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SbVec3f &amp;&nbsp;</td>
          <td class="paramname"> <em>uVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SbVec3f &amp;&nbsp;</td>
          <td class="paramname"> <em>vVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SbVec3f &amp;&nbsp;</td>
          <td class="paramname"> <em>norm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets clipping plane. 
<p>

</div>
</div><p>
<a class="anchor" name="29b4173c98e62cb5c9f84b11ee5c84df"></a><!-- doxytag: member="HxPlanarMod::planeSetXY" ref="29b4173c98e62cb5c9f84b11ee5c84df" args="(const SbVec3f &amp;origin, float u=1, float v=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::planeSetXY           </td>
          <td>(</td>
          <td class="paramtype">const SbVec3f &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>u</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>v</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets clipping plane. 
<p>
Sets the plane to be parallel to the XY plane and have the given origin. 
</div>
</div><p>
<a class="anchor" name="3a0eb037ee014065be5b0b49b5cb1c13"></a><!-- doxytag: member="HxPlanarMod::planeSetZX" ref="3a0eb037ee014065be5b0b49b5cb1c13" args="(const SbVec3f &amp;origin, float u=1, float v=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::planeSetZX           </td>
          <td>(</td>
          <td class="paramtype">const SbVec3f &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>u</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>v</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets clipping plane. 
<p>
Sets the plane to be parallel to the ZX plane and have the given origin. 
</div>
</div><p>
<a class="anchor" name="e4b81a5058334709e3dc124053c3dedf"></a><!-- doxytag: member="HxPlanarMod::planeSetYZ" ref="e4b81a5058334709e3dc124053c3dedf" args="(const SbVec3f &amp;origin, float u=1, float v=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::planeSetYZ           </td>
          <td>(</td>
          <td class="paramtype">const SbVec3f &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>u</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>v</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets clipping plane. 
<p>
Sets the plane to be parallel to the ZY plane and have the given origin. 
</div>
</div><p>
<a class="anchor" name="1fc362405a759542918f43fcb06fcc58"></a><!-- doxytag: member="HxPlanarMod::planeSetOrig" ref="1fc362405a759542918f43fcb06fcc58" args="(const SbVec3f &amp;origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::planeSetOrig           </td>
          <td>(</td>
          <td class="paramtype">const SbVec3f &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the origin of the clipping plane. 
<p>

</div>
</div><p>
<a class="anchor" name="d77066d6d33ac5b9f9faaef747eb2e7f"></a><!-- doxytag: member="HxPlanarMod::planeInit" ref="d77066d6d33ac5b9f9faaef747eb2e7f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::planeInit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the clipping plane to be the XY plane. 
<p>

</div>
</div><p>
<a class="anchor" name="a22e3bde229eb48800c19ddfd156a040"></a><!-- doxytag: member="HxPlanarMod::transform" ref="a22e3bde229eb48800c19ddfd156a040" args="(const SbMatrix &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HxPlanarMod::transform           </td>
          <td>(</td>
          <td class="paramtype">const SbMatrix &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transforms the clipping plane using the given transformation matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="ace936009b8c6526307fa3d3b63223a4"></a><!-- doxytag: member="HxPlanarMod::isFirst" ref="ace936009b8c6526307fa3d3b63223a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HxPlanarMod::isFirst           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if there are no planar modules in object pool yet. 
<p>

</div>
</div><p>
<a class="anchor" name="e9fe4e5c1d343744dfc83bf414274772"></a><!-- doxytag: member="HxPlanarMod::updateClipPlane" ref="e9fe4e5c1d343744dfc83bf414274772" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxPlanarMod::updateClipPlane           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates clipping plane considering controlling data. 
<p>

</div>
</div><p>
<a class="anchor" name="94e4c60fd66a5e4c058239fcd06b7af4"></a><!-- doxytag: member="HxPlanarMod::updateDraggingActiveState" ref="94e4c60fd66a5e4c058239fcd06b7af4" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxPlanarMod::updateDraggingActiveState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Must be implemented by inherited classes in order to activate or deactivate plane dragging. 
<p>

<p>
Implemented in <a class="el" href="class_hx_ortho_slice_l_d_m.html#56acd0c902ac5cf7d7e0ad2527cb9031">HxOrthoSliceLDM</a>, and <a class="el" href="class_hx_arbitrary_cut.html#73d58ca4234213c9defb3cf7f7a34abf">HxArbitraryCut</a>.
</div>
</div><p>
<a class="anchor" name="d59c5a08f3f47f963ccd0a5618ca02de"></a><!-- doxytag: member="HxPlanarMod::resetRepToOrthoPlane" ref="d59c5a08f3f47f963ccd0a5618ca02de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxPlanarMod::resetRepToOrthoPlane           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the connected data represents a 2D data set, automatically reset graphical representations to the plane defined by the 2D data. 
<p>
Internally call <code><a class="el" href="class_hx_planar_mod.html#afdaef8fa4fe7035d49e00634e4819f0">resetRepToOrthoPlane(OrthoPlane orthoPlane)</a></code>. 
</div>
</div><p>
<a class="anchor" name="af70c0a9065c384a4f702ffb4d1ca772"></a><!-- doxytag: member="HxPlanarMod::is2DData" ref="af70c0a9065c384a4f702ffb4d1ca772" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HxPlanarMod::is2DData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if input represents a 2D data. 
<p>

</div>
</div><p>
<a class="anchor" name="909f41a18dbc13506881107c072d4818"></a><!-- doxytag: member="HxPlanarMod::find2DPlane" ref="909f41a18dbc13506881107c072d4818" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HxPlanarMod::find2DPlane           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the 2D plane connected to the portData. 
<p>
Return false if 2D plane hasn't been found. 
</div>
</div><p>
<a class="anchor" name="6bf28190161b1a759169359295485a30"></a><!-- doxytag: member="HxPlanarMod::setPlaneControllerPortsVisible" ref="6bf28190161b1a759169359295485a30" args="(bool areVisibles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HxPlanarMod::setPlaneControllerPortsVisible           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>areVisibles</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper method to set visibility of all ports which control the plane definition (translation and orientation). 
<p>

<p>
Reimplemented in <a class="el" href="class_hx_arbitrary_cut.html#4c2f7abd538a92c40c4d348032935a3e">HxArbitraryCut</a>.
</div>
</div><p>
<a class="anchor" name="9dccd084306925ed21d322b9913ba601"></a><!-- doxytag: member="HxPlanarMod::getTranslationPort" ref="9dccd084306925ed21d322b9913ba601" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_hx_port.html">HxPort</a>* HxPlanarMod::getTranslationPort           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inherited classes will have to return the port which will control the plane translation. 
<p>
Return 0 if such a controller doesn't exist. 
<p>
Implemented in <a class="el" href="class_hx_ortho_slice_l_d_m.html#2f0fae359f7543868f3edd4bd137722f">HxOrthoSliceLDM</a>, and <a class="el" href="class_hx_arbitrary_cut.html#bc7b54c7dedd21f90f5ab9ecbd183111">HxArbitraryCut</a>.
</div>
</div><p>
<a class="anchor" name="3bc309947eaf03bb41bb35f706675637"></a><!-- doxytag: member="HxPlanarMod::getResetToOrthoPlanePort" ref="3bc309947eaf03bb41bb35f706675637" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_hx_port.html">HxPort</a>* HxPlanarMod::getResetToOrthoPlanePort           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inherited classes will have to return the port which will be in charge of aligning the plane to a XY, XZ or YZ plane. 
<p>
Return 0 if such a controller doesn't exist. 
<p>
Implemented in <a class="el" href="class_hx_ortho_slice_l_d_m.html#4d38e071d5a06b0a09c737776f47f319">HxOrthoSliceLDM</a>, and <a class="el" href="class_hx_arbitrary_cut.html#a411d8a4d8cfee19c4d5e16251667cc3">HxArbitraryCut</a>.
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="169ac695509edbc9c163e382cf4863fa"></a><!-- doxytag: member="HxPlanarMod::HxBase" ref="169ac695509edbc9c163e382cf4863fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_hx_base.html">HxBase</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="6413e29fa2299c03f080cd5cd74265e4"></a><!-- doxytag: member="HxPlanarMod::portOrigin" ref="6413e29fa2299c03f080cd5cd74265e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hx_port3_d_point_list.html">HxPort3DPointList</a>* <a class="el" href="class_hx_planar_mod.html#6413e29fa2299c03f080cd5cd74265e4">HxPlanarMod::portOrigin</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Port defining plane origin. 
<p>
This port is a pointer on purpose. See <code><a class="el" href="class_hx_port3_d_point_list.html">HxPort3DPointList</a></code> for more information. 
</div>
</div><p>
<a class="anchor" name="408d2d4ddf662c4a74de32533d9bcaec"></a><!-- doxytag: member="HxPlanarMod::portNormal" ref="408d2d4ddf662c4a74de32533d9bcaec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hx_port3_d_point_list.html">HxPort3DPointList</a>* <a class="el" href="class_hx_planar_mod.html#408d2d4ddf662c4a74de32533d9bcaec">HxPlanarMod::portNormal</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Port defining plane normal. 
<p>
This port is a pointer on purpose. See <code><a class="el" href="class_hx_port3_d_point_list.html">HxPort3DPointList</a></code> for more information. 
</div>
</div><p>
<a class="anchor" name="894a3d388c296f8ceb85de558965d6de"></a><!-- doxytag: member="HxPlanarMod::portFrame" ref="894a3d388c296f8ceb85de558965d6de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hx_port_generic.html">HxPortGeneric</a> <a class="el" href="class_hx_planar_mod.html#894a3d388c296f8ceb85de558965d6de">HxPlanarMod::portFrame</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show or hide frame, set frame width, set frame color. 
<p>

</div>
</div><p>
<a class="anchor" name="737ab627ffd7055f73c412287689909f"></a><!-- doxytag: member="HxPlanarMod::puVec" ref="737ab627ffd7055f73c412287689909f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbVec3f <a class="el" href="class_hx_planar_mod.html#737ab627ffd7055f73c412287689909f">HxPlanarMod::puVec</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5adbcc176184eecbde29f4b4790a7036"></a><!-- doxytag: member="HxPlanarMod::pvVec" ref="5adbcc176184eecbde29f4b4790a7036" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SbVec3f <a class="el" href="class_hx_planar_mod.html#5adbcc176184eecbde29f4b4790a7036">HxPlanarMod::pvVec</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="de3f16ee44f3501c052ff545cbc9026e"></a><!-- doxytag: member="HxPlanarMod::changed" ref="de3f16ee44f3501c052ff545cbc9026e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_hx_planar_mod.html#de3f16ee44f3501c052ff545cbc9026e">HxPlanarMod::changed</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1dbba4d7c0ada026496c1858e95a906f"></a><!-- doxytag: member="HxPlanarMod::invert" ref="1dbba4d7c0ada026496c1858e95a906f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_hx_planar_mod.html#1dbba4d7c0ada026496c1858e95a906f">HxPlanarMod::invert</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="784abc6f32962abc10b8188deb6f9218"></a><!-- doxytag: member="HxPlanarMod::decal" ref="784abc6f32962abc10b8188deb6f9218" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_so_decal.html">SoDecal</a>* <a class="el" href="class_hx_planar_mod.html#784abc6f32962abc10b8188deb6f9218">HxPlanarMod::decal</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="361bbd4b25d16c425f72726f984beaec"></a><!-- doxytag: member="HxPlanarMod::clipPlane" ref="361bbd4b25d16c425f72726f984beaec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_so_auto_clip_plane.html">SoAutoClipPlane</a>* <a class="el" href="class_hx_planar_mod.html#361bbd4b25d16c425f72726f984beaec">HxPlanarMod::clipPlane</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cb9970dc61a2c35295c52a4ef13c5359"></a><!-- doxytag: member="HxPlanarMod::clippedModules" ref="cb9970dc61a2c35295c52a4ef13c5359" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_hx_base.html">HxBase</a>*&gt; <a class="el" href="class_hx_planar_mod.html#cb9970dc61a2c35295c52a4ef13c5359">HxPlanarMod::clippedModules</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e57b13ecd4d4c99324f8f0f5db7974af"></a><!-- doxytag: member="HxPlanarMod::m_separator" ref="e57b13ecd4d4c99324f8f0f5db7974af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_handle.html">McHandle</a>&lt;SoSeparator&gt; <a class="el" href="class_hx_planar_mod.html#e57b13ecd4d4c99324f8f0f5db7974af">HxPlanarMod::m_separator</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e52e717bcfa7743d952f7fef0d8b1570"></a><!-- doxytag: member="HxPlanarMod::m_isDraggingEnabled" ref="e52e717bcfa7743d952f7fef0d8b1570" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_hx_planar_mod.html#e52e717bcfa7743d952f7fef0d8b1570">HxPlanarMod::m_isDraggingEnabled</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To know if we allow plane dragging. 
<p>

</div>
</div><p>
<a class="anchor" name="e5b953b4adef7ffc2a4c21b2b1da18ab"></a><!-- doxytag: member="HxPlanarMod::m_is2DData" ref="e5b953b4adef7ffc2a4c21b2b1da18ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_hx_planar_mod.html#e5b953b4adef7ffc2a4c21b2b1da18ab">HxPlanarMod::m_is2DData</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To know if the connected is a kind of image. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>hxcore/<a class="el" href="hxcore_2_hx_planar_mod_8h.html">HxPlanarMod.h</a></ul>
<hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
