<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Amira: hxfield</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="AmiraDevRef.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>hxfield</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_o_i_n_t2_d.html">POINT2D</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_o_i_n_t3_d.html">POINT3D</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_r.html">TR</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_e_t.html">TET</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_jacobian.html">Jacobian</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_element3.html">EdgeElement3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_complex_vector_field3.html">HxComplexVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing a generic complex vector field.  <a href="class_hx_complex_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_vector_field3.html">HxUniformVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector field defined on a uniform lattice.  <a href="class_hx_uniform_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_hexa_complex_vector_field3.html">HxHexaComplexVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a hexahedral grid.  <a href="class_hx_hexa_complex_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_vector_field3.html">HxTetraVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector field on a tetrahedral grid.  <a href="class_hx_tetra_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_anna_vector_field3.html">HxAnnaVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an analytically defined vector field.  <a href="class_hx_anna_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_stacked_scalar_field3.html">HxStackedScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field consisting of parallel slices.  <a href="class_hx_stacked_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_reg_scalar_field3.html">HxRegScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field based on a regular lattice.  <a href="class_hx_reg_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_coord3.html">HxUniformCoord3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing uniform axis-aligned coordinates.  <a href="class_hx_uniform_coord3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_sym2_tensor_field3.html">HxTetraSym2TensorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a symmetric second order tenosr field on a tetrahedral grid.  <a href="class_hx_tetra_sym2_tensor_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_sym2_tensor_field3.html">HxSym2TensorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing a generic symmetric second order tensor field.  <a href="class_hx_sym2_tensor_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_reg_color_field3.html">HxRegColorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a color field based on a regular lattice.  <a href="class_hx_reg_color_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hexa_grid.html">HexaGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">New data-structure for hexahedral grids.  <a href="class_hexa_grid.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_hexa_grid_1_1_hexa.html">HexaGrid::Hexa</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hexahedron.  <a href="struct_hexa_grid_1_1_hexa.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_hexa_grid_1_1_face.html">HexaGrid::Face</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Faces (squares).  <a href="struct_hexa_grid_1_1_face.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_label_field3.html">HxUniformLabelField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a labeled volume with uniform coordinates.  <a href="class_hx_uniform_label_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_anna_location3.html">HxAnnaLocation3&lt; TAnnaFieldClass &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialized <a class="el" href="class_hx_location3.html">HxLocation3</a> class for <a class="el" href="class_hx_anna_vector_field3.html">HxAnnaVectorField3</a> and <a class="el" href="class_hx_anna_scalar_field3.html">HxAnnaScalarField3</a>.  <a href="class_hx_anna_location3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_hexa_complex_scalar_field3.html">HxHexaComplexScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a hexahedral grid.  <a href="class_hx_hexa_complex_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_edge_elem_complex_vector_field3.html">EdgeElemComplexVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This helper class implements evaluation of edge elements.  <a href="class_edge_elem_complex_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_edge_elem_complex_vector_field3.html">HxEdgeElemComplexVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector field based on Whitney-elements.  <a href="class_hx_edge_elem_complex_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_loc3_curvilinear.html">HxLoc3Curvilinear</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a general location in a curvilinear grid.  <a href="class_hx_loc3_curvilinear.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_loc3_tetra.html">HxLoc3Tetra</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a location within a tetrahedral grids.  <a href="class_hx_loc3_tetra.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetra_cut.html">TetraCut</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes intersection of a tetrahedral grid and a plane This class intersects an arbitrary cutting plane with any data field defined on a tetrahedral grid.  <a href="class_tetra_cut.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_multi_channel_field3.html">HxMultiChannelField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is a proxy object which groups multiple <a class="el" href="class_hx_reg_scalar_field3.html">HxRegScalarField3</a> objects (channels).  <a href="class_hx_multi_channel_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_data.html">HxTetraData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a data grid with regular coordinates.  <a href="class_hx_tetra_data.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_lattice3.html">HxLattice3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a data grid with regular coordinates.  <a href="class_hx_lattice3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_voxel_field_set.html">HxVoxelFieldSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class holds multiple fields defined on a voxel grid.  <a href="class_hx_voxel_field_set.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_voxel_e_field_set.html">HxVoxelEFieldSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set of complex valued electromagnetic fields.  <a href="class_hx_voxel_e_field_set.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_curvilinear_coord3.html">HxCurvilinearCoord3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing curvilinear coordinates.  <a href="class_hx_curvilinear_coord3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_coord3.html">HxCoord3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for all types of lattice coordinates.  <a href="class_hx_coord3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_read_raw_dialog.html">HxReadRawDialog</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_hexa_vector_field3.html">HxHexaVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a hexahedral grid.  <a href="class_hx_hexa_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_color_field3.html">HxColorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing a generic scalar field.  <a href="class_hx_color_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_stacked_label_field3.html">HxStackedLabelField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a labeled volume with stacked coordinates.  <a href="class_hx_stacked_label_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_sym2_tensor_field3.html">HxUniformSym2TensorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a symmetric second order tensor field defined on a uniform lattice.  <a href="class_hx_uniform_sym2_tensor_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_stacked_coord3.html">HxStackedCoord3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing stacked axis-aligned coordinates.  <a href="class_hx_stacked_coord3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_loc3_block.html">HxLoc3Block</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_hexa_grid.html">HxHexaGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class combines a standalone <a class="el" href="class_hexa_grid.html">HexaGrid</a> with Amira's HxVertexData.  <a href="class_hx_hexa_grid.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_scalar_field3.html">HxUniformScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field defined on a uniform lattice.  <a href="class_hx_uniform_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qx_reg_scalar_field3_info_tag.html">QxRegScalarField3InfoTag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_location3.html">HxLocation3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing a general location within a 3D field.  <a href="class_hx_location3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_select_roi.html">HxSelectRoi</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This module defines a region-of-interest with the shape of an axis-aligned 3D box.  <a href="class_hx_select_roi.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_hexa_scalar_field3.html">HxHexaScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a hexahedral grid.  <a href="class_hx_hexa_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_field_evaluator.html">HxFieldEvaluator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The abstract base class for field evaluators.  <a href="class_hx_field_evaluator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_eval_standard.html">HxEvalStandard</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for the standard eval mechanism provided by <a class="el" href="class_hx_field3.html">HxField3</a>.  <a href="class_hx_eval_standard.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_eval_lanczos.html">HxEvalLanczos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An evaluator implementing high-quality interpolation using the Lanczos3 kernel.  <a href="class_hx_eval_lanczos.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_eval_n_n.html">HxEvalNN</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An evaluator implementing a nearest neigbor lookup.  <a href="class_hx_eval_n_n.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_eval_label_field_linear.html">HxEvalLabelFieldLinear</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An evaluator implementing linear interpolation of label data to obtain interpolation without mixing of label values (e.g.  <a href="class_hx_eval_label_field_linear.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_label_lattice3.html">HxLabelLattice3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lattice with additional space for weights.  <a href="class_hx_label_lattice3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_complex_scalar_field3.html">HxTetraComplexScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a hexahedral grid.  <a href="class_hx_tetra_complex_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_complex_scalar_field3.html">HxUniformComplexScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field defined on a uniform lattice.  <a href="class_hx_uniform_complex_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_plan_data.html">HxPlanData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is used to store antenna parameters in hyperthermia planning.  <a href="class_hx_plan_data.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_scalar_field3.html">HxScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing a generic scalar field.  <a href="class_hx_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_reg_field3.html">HxRegField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an n-valued field defined on a regular lattice.  <a href="class_hx_reg_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_field3.html">HxTetraField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a hexahedral grid.  <a href="class_hx_tetra_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_edge_elem_vector_field3.html">HxEdgeElemVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector field based on Whitney-elements.  <a href="class_hx_edge_elem_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_port_channel_config.html">HxPortChannelConfig</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This port is used in class <a class="el" href="class_hx_multi_channel_field3.html">HxMultiChannelField3</a>.  <a href="class_hx_port_channel_config.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_block_structured_field3.html">HxBlockStructuredField3&lt; TFieldType &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common Implementation for (at least) Vector and Scalar fields of Block structured fields.  <a href="class_hx_block_structured_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_block_structured_scalar_field3.html">HxBlockStructuredScalarField3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_block_structured_vector_field3.html">HxBlockStructuredVectorField3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_color_field3.html">HxUniformColorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a color field defined on a uniform lattice.  <a href="class_hx_uniform_color_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_loc3_rectilinear.html">HxLoc3Rectilinear</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a general location in a rectilinear grid.  <a href="class_hx_loc3_rectilinear.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_vector_field3.html">HxVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing a generic vector field.  <a href="class_hx_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_hexa_data.html">HxHexaData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a data grid with regular coordinates.  <a href="class_hx_hexa_data.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoint.html">oint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 32 bit integer with an additional flag.  <a href="structoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_field3.html">HxField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic field in 3D space.  <a href="class_hx_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_multi_channel_field3.html">HxUniformMultiChannelField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded multi channel fields which only accepts channels with uniform coordinates.  <a href="class_hx_uniform_multi_channel_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_complex_scalar_field3.html">HxComplexScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing a generic complex scalar field.  <a href="class_hx_complex_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_reg_complex_vector_field3.html">HxRegComplexVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a complex vector field defined on a regular lattice.  <a href="class_hx_reg_complex_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_complex_component_field3.html">HxUniformComplexComponentField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represent a labeled volume with material bundle.  <a href="class_hx_uniform_complex_component_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_lattice3_crop_interface.html">HxLattice3CropInterface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface needed to apply crop editor to data object.  <a href="class_hx_lattice3_crop_interface.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_lattice3_crop_interface_impl_template.html">HxLattice3CropInterfaceImplTemplate&lt; PROXY &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_qx_read_raw_dialog.html">QxReadRawDialog</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_complex_vector_field3.html">HxTetraComplexVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a hexahedral grid.  <a href="class_hx_tetra_complex_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_loc3_uniform.html">HxLoc3Uniform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a general location with a uniform grid.  <a href="class_hx_loc3_uniform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_reg_vector_field3.html">HxRegVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a vector field based on a regular lattice.  <a href="class_hx_reg_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tetra_grid.html">TetraGrid</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tetra_grid_1_1_tetra.html">TetraGrid::Tetra</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tetrahedron.  <a href="struct_tetra_grid_1_1_tetra.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tetra_grid_1_1_triangle.html">TetraGrid::Triangle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="struct_tetra_grid_1_1_triangle.html">Triangle</a>.  <a href="struct_tetra_grid_1_1_triangle.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tetra_grid_1_1_edge.html">TetraGrid::Edge</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="struct_tetra_grid_1_1_edge.html">Edge</a>.  <a href="struct_tetra_grid_1_1_edge.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tetra_grid_1_1_edges_per_tetra.html">TetraGrid::EdgesPerTetra</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For each tetrahedron the indices of the six edges.  <a href="struct_tetra_grid_1_1_edges_per_tetra.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_loc3_stacked.html">HxLoc3Stacked</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a general location with a stacked coordinate grid.  <a href="class_hx_loc3_stacked.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_geodetic_data_interface.html">HxGeodeticDataInterface</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_geodetic_data_interface_impl_template.html">HxGeodeticDataInterfaceImplTemplate&lt; PROXY &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_loc3_hexa.html">HxLoc3Hexa</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a general location in a hexahedral grid.  <a href="class_hx_loc3_hexa.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_block_structured_grid.html">HxBlockStructuredGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A structure for grids that are composed of a number of curvilinear zones.  <a href="class_hx_block_structured_grid.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_loc3_regular.html">HxLoc3Regular</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represent a general location with a regular grid.  <a href="class_hx_loc3_regular.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_reg_complex_scalar_field3.html">HxRegComplexScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a complex scalar field defined on a regular lattice.  <a href="class_hx_reg_complex_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_rectilinear_coord3.html">HxRectilinearCoord3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing rectilinear coordinates.  <a href="class_hx_rectilinear_coord3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_port_multi_channel.html">HxPortMultiChannel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This port is used to toggle channels of a <a class="el" href="class_hx_multi_channel_field3.html">HxMultiChannelField3</a> on or off.  <a href="class_hx_port_multi_channel.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_reg_sym2_tensor_field3.html">HxRegSym2TensorField3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_scalar_field3.html">HxTetraScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a tetrahedral grid.  <a href="class_hx_tetra_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_field_set.html">HxTetraFieldSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class holds multiple fields defined on a tetrahedral grid.  <a href="class_hx_tetra_field_set.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_e_field_set.html">HxTetraEFieldSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set of complex valued electromagnetic fields.  <a href="class_hx_tetra_e_field_set.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_temperature_set.html">HxTetraTemperatureSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set of real valued temperature fields.  <a href="class_hx_tetra_temperature_set.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_edge_elem_set.html">HxTetraEdgeElemSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set of complex valued vector fields defined by edge elements.  <a href="class_hx_tetra_edge_elem_set.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_anna_scalar_field3.html">HxAnnaScalarField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an analytically defined scalar field.  <a href="class_hx_anna_scalar_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_tetra_grid.html">HxTetraGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class combines a standalone <a class="el" href="class_tetra_grid.html">TetraGrid</a> with Amira's <a class="el" href="class_hx_vertex_set.html">HxVertexSet</a>.  <a href="class_hx_tetra_grid.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_hexa_field3.html">HxHexaField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a scalar field on a hexahedral grid.  <a href="class_hx_hexa_field3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_multi_channel_field.html">HxMultiChannelField</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is a proxy object which groups multiple <a class="el" href="class_hx_reg_scalar_field3.html">HxRegScalarField3</a> objects (channels).  <a href="class_hx_multi_channel_field.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hx_uniform_complex_vector_field3.html">HxUniformComplexVectorField3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a complex vector field defined on a uniform lattice.  <a href="class_hx_uniform_complex_vector_field3.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g71652bc9837e498266f4c4378c1488b1">EPS</a>&nbsp;&nbsp;&nbsp;1E-8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g81288a39cb2f7217756275c99b5565c1">HXFIELD_API</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#geb99d06c3ebcb1de7946d70c3eb45c08">READ_RAW_NTEXTFIELDS</a>&nbsp;&nbsp;&nbsp;10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gb82802d878131cc995f34bb2ae09e732">READ_RAW_NRADIOBUTTONS</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g809543720c0198d15c91f8c18343b042">READ_RAW_NCOMBOBOXES</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g942fa29e807297e1e6ea848c5edf3e07">CHECK_GEODETIC</a>(field)&nbsp;&nbsp;&nbsp;HxGeodeticDataInterface::checkGeodeticTransformCoordinates(field)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gc76d9ddbb71bb31ca580c1e60f5cf97f">GEODETIC_EQUATOR_RATIO</a>&nbsp;&nbsp;&nbsp;0.00000899321012635460f</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g165fc71f87a970ae2e8de8991ccc37a6">EvalLatFunc</a> (<a class="el" href="class_hx_lattice3.html">HxLattice3</a> *, <a class="el" href="group__mclib.html#g198d31a7cf38338965096132873d192c">mculong</a>, float *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gdb394891517080e1656dc9c111659bb9">EvalNative</a> (void *userData, <a class="el" href="class_hx_location3.html">HxLocation3</a> *, void *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g881d79f65a2c7d7c2229ca2522bb4da7">EvalFloat</a> (void *userData, <a class="el" href="class_hx_location3.html">HxLocation3</a> *, float *)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gf2afe15193f52cc7963357f8f6acce73">HxCoordType</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce73d9b465887574c079ddfc3a4376e3d21a">c_undefined</a> =  0, 
<a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce737115bdb16447e2d4a2b1e55d7286a559">c_uniform</a>, 
<a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce73f9b101be644dd3c27480dcdbef9e5666">c_stacked</a>, 
<a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce73263c1932363ac239b0965103da68e97a">c_rectilinear</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce7372c3a3ad050b50e66cc216c1b5989050">c_uniform_oblique</a>, 
<a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce73c83a6796c412739294e86c53d76b21ef">c_stacked_oblique</a>, 
<a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce73360151a0119dcf90d32a61c4a0711a3c">c_rectilinear_oblique</a>, 
<a class="el" href="group__hxfield.html#ggf2afe15193f52cc7963357f8f6acce7330da36a349804648d464764eb30a1048">c_curvilinear</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration of regular coordinate types.  <a href="group__hxfield.html#gf2afe15193f52cc7963357f8f6acce73">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g33b982ff557e3bbd8f6286f2619bff27">HexaGrid::locatePoint</a> (<a class="el" href="class_mc_vec3f.html">McVec3f</a> pos, int &amp;iCell, <a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;barycentrics)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g42064dd975a5d090007ddd7b19867901">HexaGrid::octreeInvalidate</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g4037b9b17eddec86694ee5b92bf75de2">HexaGrid::octreeInfo</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_mat3f.html">McMat3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g91c79746a6ef182da78c22216832ac6a">HexaGrid::calcJacobianOfBarycentricsToWc</a> (int iCell, <a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_vec3f.html">McVec3f</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gfc98333c1c1488e52934b98156456e3f">HexaGrid::getCentroids</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void HXFIELD_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g64e19d5a77701ef5528eaa3aab3aa866">autoSetRange</a> (<a class="el" href="class_hx_spatial_data.html">HxSpatialData</a> *data, <a class="el" href="class_hx_port_multi_menu.html">HxPortMultiMenu</a> &amp;portMappingType, <a class="el" href="class_hx_port_float_text_n.html">HxPortFloatTextN</a> &amp;portLinearRange, <a class="el" href="class_hx_port_colormap.html">HxPortColormap</a> &amp;portColormap, int mapping_index=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These methods are used to initialize ports for example in HxOrthoSlice.  <a href="#g64e19d5a77701ef5528eaa3aab3aa866"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void HXFIELD_API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g3d9bf54add9deaf570f9ea657a549fa8">autoSetRangePortColormap</a> (<a class="el" href="class_hx_spatial_data.html">HxSpatialData</a> *data, <a class="el" href="class_hx_port_colormap.html">HxPortColormap</a> &amp;portColormap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g9e36ec7ca6feec3d8037392ba345c1f0">TetraGrid::TetraGrid</a> (<a class="el" href="class_hx_param_bundle.html">HxParamBundle</a> *parameters)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g9e36ec7ca6feec3d8037392ba345c1f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g22a403dda51a8b1cfcc618e668c5d05d">TetraGrid::~TetraGrid</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#g22a403dda51a8b1cfcc618e668c5d05d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g3e1a9b8a3d12b187c7639e866c484823">TetraGrid::clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes everything, creating an empty grid.  <a href="#g3e1a9b8a3d12b187c7639e866c484823"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g4daf44b8da172cead9b806202247273c">TetraGrid::getBoundingBox</a> (float box[6]) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns bounding box of point coordinates.  <a href="#g4daf44b8da172cead9b806202247273c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gfe53e435579f9ecc56bc8116303a1d2d">TetraGrid::sortTetrahedra</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort tetrahedra according to material type and z-direction.  <a href="#gfe53e435579f9ecc56bc8116303a1d2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g32911eaf01b72a63f40ca834339cd60d">TetraGrid::createTriangles2</a> (const int *aliasInfo=0, int nBoundaryTriangles=0, int(*pointIndices)[3]=0, unsigned char *ids=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts all faces (need to be called after topology changed).  <a href="#g32911eaf01b72a63f40ca834339cd60d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g2fb7c975ffa91d6df81c3d9e36c8b41d">TetraGrid::computeNormals</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes triangle normals.  <a href="#g2fb7c975ffa91d6df81c3d9e36c8b41d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#ga5becd91fd32f10266e332ec90e557a7">TetraGrid::setProjection</a> (SoProjection *projection)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gffce172b06d8685ccac97a3d6270facd">TetraGrid::createEdges</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts all edges (needs to be called after topology changed).  <a href="#gffce172b06d8685ccac97a3d6270facd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g0bb3aadea223292a4c83ace7aa96665f">TetraGrid::createEdgesPerTetra</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates edgesPerTetra.  <a href="#g0bb3aadea223292a4c83ace7aa96665f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g321ca5c84ba17342286ef9eb4e378e64">TetraGrid::fixOrientation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fix inverted tetrahedra.  <a href="#g321ca5c84ba17342286ef9eb4e378e64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g45ab40bfdeddf59204b22050dfc1b8e7">TetraGrid::makeObsolete</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks a tetrahedron as removed.  <a href="#g45ab40bfdeddf59204b22050dfc1b8e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g74a4561181b675677102c2342d6043b4">TetraGrid::isObsoleteTetra</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if a tetrahedron is marked obsolete, false otherwise.  <a href="#g74a4561181b675677102c2342d6043b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g27c9730bb58f526fb62256fd0f0c1a0b">TetraGrid::isObsoleteTriangle</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if a triangle is marked obsolete, false otherwise.  <a href="#g27c9730bb58f526fb62256fd0f0c1a0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gea6633685b1f025be0740eb25b86c7ad">TetraGrid::getOppositeFace</a> (int iTet, int iVert)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns opposite face of vertex iVert in tetra iTet.  <a href="#gea6633685b1f025be0740eb25b86c7ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gb366ebdefefd9e6a148f023dba8cd406">TetraGrid::getOppositeFaceAtEdge</a> (int iTet, int iFace, int from, int to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns opposite face of face iFace at edge from-to in tetra iTet.  <a href="#gb366ebdefefd9e6a148f023dba8cd406"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gf7db96ccc97b2bba463383e7c0990333">TetraGrid::getOppositeVertex</a> (int iTet, int iFace)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns opposite vertex of face iFace in tetra iTet.  <a href="#gf7db96ccc97b2bba463383e7c0990333"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g79aae71986fc05410a4428fdce89c6b0">TetraGrid::getOppositeTetra</a> (int iFace, int iTet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns opposite tetra of tetra iTet at face iFace.  <a href="#g79aae71986fc05410a4428fdce89c6b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gba98e8f16f98bda034a468a154a84401">TetraGrid::createTetraFromFaces</a> (int iTet, int *faces)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creates tetrahedron from 4 faces given.  <a href="#gba98e8f16f98bda034a468a154a84401"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g5e67567e1c9209e0ba9c9f42fffb3ee4">TetraGrid::removeObsoleteTetras</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes unused tetrahedrons.  <a href="#g5e67567e1c9209e0ba9c9f42fffb3ee4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g0a25336c5bc0ce7a3cd93558342f5502">TetraGrid::removeObsoleteTriangles</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes unused triangles.  <a href="#g0a25336c5bc0ce7a3cd93558342f5502"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#ge18cd8c62f752a368dc129e69e78a56d">TetraGrid::checkConsistency</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">performs a consistency check on the tetragrid.  <a href="#ge18cd8c62f752a368dc129e69e78a56d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gfe84d4a2ad0766a11dfbedce98a2754a">TetraGrid::computeVertexHints</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For every point find one triangle incident at that point.  <a href="#gfe84d4a2ad0766a11dfbedce98a2754a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g88fdfec606d89a39e16d3e39431a2056">TetraGrid::computeTetrasPerPoint</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g53ea85bd14dcff5378aa92172aa290e3">TetraGrid::computeAliasInfo</a> (<a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;aliases)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g9dbb3121ae9d5e16e5180ee06b31d624">TetraGrid::initFromAmiraMesh</a> (<a class="el" href="class_amira_mesh.html">AmiraMesh</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize tetrahedral grid from a <a class="el" href="class_amira_mesh.html">AmiraMesh</a> file descriptor.  <a href="#g9dbb3121ae9d5e16e5180ee06b31d624"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gddd982d4b7aca979cd4ea659ab092655">TetraGrid::rebuildOctree</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rebuilds octree.  <a href="#gddd982d4b7aca979cd4ea659ab092655"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gfa395cf23701c90ea9ff43e26ed43c5f">TetraGrid::isBoundaryEdge</a> (int vert1, int vert2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find out if edge is boundary edge  <a href="#gfa395cf23701c90ea9ff43e26ed43c5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#ge1e66f2839ae2f4d670eb05bdae4f728">TetraGrid::isBoundaryConditionEdge</a> (int vert1, int vert2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find out if edge is boundary condition edge  <a href="#ge1e66f2839ae2f4d670eb05bdae4f728"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g6359bebc8361c82ac8e389d85a87a554">TetraGrid::bisectEdge</a> (int iEdge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bisect edge  <a href="#g6359bebc8361c82ac8e389d85a87a554"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g998ceda16d413030b446da7b6871ca28">TetraGrid::bisectEdge</a> (int vert1, int vert2, <a class="el" href="class_mc_vec3f.html">McVec3f</a> *newVertex=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bisect edge  <a href="#g998ceda16d413030b446da7b6871ca28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g86983b1bb480ef0660080fdb1c7a0db6">TetraGrid::collapseEdge</a> (int vert1, int vert2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">collapse edge  <a href="#g86983b1bb480ef0660080fdb1c7a0db6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_mat3f.html">McMat3f</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#ga3a2491ae29bec2e487dd832cc8ae83d">TetraGrid::getCoordTransformMatrix</a> (int iTetra)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the coordinate transform matrix from local barycentric coordinates to world coordinates.  <a href="#ga3a2491ae29bec2e487dd832cc8ae83d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#ge30db9c6cef8588e0b36abc7d3fa6ce7">TetraGrid::detJ</a> (int iTet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determinant of Jacobi matrix for transformation to unit tetrahedron.  <a href="#ge30db9c6cef8588e0b36abc7d3fa6ce7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gdba2a246561faa48fc62cdfd0fd686fd">TetraGrid::getQuality</a> (int nr_tetrahedron, float &amp;determinante, float &amp;inner_radius, float &amp;outer_radius)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute determinant, inner and outer radius for tetrahedron.  <a href="#gdba2a246561faa48fc62cdfd0fd686fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g81556a38a8dbfc91ff23fcf11d30eb8e">TetraGrid::getEdgeQuality</a> (int iEdge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute edge quality.  <a href="#g81556a38a8dbfc91ff23fcf11d30eb8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g2d2968442d103838878629030db8ca88">TetraGrid::calcMinDet</a> (<a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &amp;tetraList, <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &amp;iTetWorst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute minimal determinant for list of tetras.  <a href="#g2d2968442d103838878629030db8ca88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gdbb6ed2e7d41387736093faceadc90b8">TetraGrid::calcMaxDiamRatio</a> (<a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &amp;tetraList, <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &amp;iTetWorst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute maximal diameter ratio for list of tetras.  <a href="#gdbb6ed2e7d41387736093faceadc90b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g4581594684f0fd86d19af041d78e44d5">TetraGrid::globalRefine</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global refinement.  <a href="#g4581594684f0fd86d19af041d78e44d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g2db4503eab26ef9ad4e0f8e3f763b9df">TetraGrid::getVolume</a> (int materialId=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The volume of the grid (default) or of the given material id.  <a href="#g2db4503eab26ef9ad4e0f8e3f763b9df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g9b88aeca41592e311062791bf8368be3">TetraGrid::getNumIslands</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The amount of islands, i.e.  <a href="#g9b88aeca41592e311062791bf8368be3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g9a728861f9cbc9965a6a84cafd30a9a7">TetraGrid::getConnectedElements</a> (unsigned int tetraIndex, <a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;tetras)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">face connected component search, starting from tetraIndex.  <a href="#g9a728861f9cbc9965a6a84cafd30a9a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g09a67b722574e7575be3c77569ee1207">TetraGrid::insertTriangle</a> (int index, int point1, int point2, int point3, int cell1, int cell2, int bnd, int bndCond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a triangle.  <a href="#g09a67b722574e7575be3c77569ee1207"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gc45c11565e682c1c44fb476960eccdf9">TetraGrid::addTriangle</a> (int point1, int point2, int point3, int cell1, int cell2, int bnd, int bndCond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a triangle to the grid.  <a href="#gc45c11565e682c1c44fb476960eccdf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gda65a2f77d70ee9d682cfb8c24ed7c9f">TetraGrid::updateFaceNormal</a> (int i, int insidePoint)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_vec3f.html">McVec3f</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g840c0f3e5328935eaf5c27524f36b336">HexaGrid::points</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of grid points.  <a href="#g840c0f3e5328935eaf5c27524f36b336"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; Hexa &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gfa3d7e5253e482a986bbf1547954abce">HexaGrid::hexas</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of hexahedrons.  <a href="#gfa3d7e5253e482a986bbf1547954abce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; unsigned char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g1643b57b372ea2a8c0d41c1c4d7fbbe1">HexaGrid::materialIds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For every hexahedron a material id.  <a href="#g1643b57b372ea2a8c0d41c1c4d7fbbe1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; Face &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g0437008a3f402d23d7b5ab8eca65a532">HexaGrid::faces</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of faces.  <a href="#g0437008a3f402d23d7b5ab8eca65a532"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gd28551daa55c81ba72bb5f245bf4183d">HexaGrid::hexasPerPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hexahedrons per point (optional).  <a href="#gd28551daa55c81ba72bb5f245bf4183d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g29b972d00beca094b2759e61f5e916f9">HexaGrid::numDuplicatedNodes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates how many points are duplicated.  <a href="#g29b972d00beca094b2759e61f5e916f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_hx_param_bundle.html">HxParamBundle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g1992a1075603dd3090b9d3e429838c90">HexaGrid::params</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to parameters of derived <a class="el" href="class_hx_hexa_grid.html">HxHexaGrid</a>.  <a href="#g1992a1075603dd3090b9d3e429838c90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_vec3f.html">McVec3f</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g9894d08d449b68db149c66ce4180ab51">HexaGrid::m_centerPoints</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computed on demand by the getCentroids method.  <a href="#g9894d08d449b68db149c66ce4180ab51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_mutex.html">McMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g864b3846c80385a35c97bdce855b35c6">HexaGrid::m_octreeMutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_vec3f.html">McVec3f</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#ge2a7cbf2881028b6343234e77f0cac83">TetraGrid::points</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of grid points.  <a href="#ge2a7cbf2881028b6343234e77f0cac83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gd6f8bde9089b1876c482093a41294712">TetraGrid::vertexHints</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For every point id of a triangle incident at that point.  <a href="#gd6f8bde9089b1876c482093a41294712"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; Tetra &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g5ff7ac0316c5079669e7c18fc3768108">TetraGrid::tetras</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of tetrahedrons.  <a href="#g5ff7ac0316c5079669e7c18fc3768108"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; unsigned char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g6c149d8dc81421f1ef5c8c5d87643135">TetraGrid::materialIds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For every tetrahedron a material id.  <a href="#g6c149d8dc81421f1ef5c8c5d87643135"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; EdgesPerTetra &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g6fe743d1070487ce510555c097366c76">TetraGrid::edgesPerTetra</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For every tetrahedron indices of its edges (optional).  <a href="#g6fe743d1070487ce510555c097366c76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; Triangle &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g863c144817b839ec5f4f31b5093cc1f0">TetraGrid::triangles</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of triangles.  <a href="#g863c144817b839ec5f4f31b5093cc1f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; Edge &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g50944d6b1ca3e59bc7c1f28cf9403a0f">TetraGrid::edges</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of edges (optional).  <a href="#g50944d6b1ca3e59bc7c1f28cf9403a0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#ge672232b9bae093ff5f71d1ce008c88f">TetraGrid::tetrasPerPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tetrahedrons per point (optional).  <a href="#ge672232b9bae093ff5f71d1ce008c88f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g5630d09298a315a836e2a2f301511fbb">TetraGrid::numDuplicatedNodes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates how many points are duplicated.  <a href="#g5630d09298a315a836e2a2f301511fbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_hx_param_bundle.html">HxParamBundle</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g209a7395d32583c46c76e795d712df31">TetraGrid::params</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to parameters of derived <a class="el" href="class_hx_tetra_grid.html">HxTetraGrid</a>.  <a href="#g209a7395d32583c46c76e795d712df31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_mc_static_octree.html">McStaticOctree</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#gc2b6cf0fe7ce4b234b31f8e8d2b4b0b2">TetraGrid::octree</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Octree for point location.  <a href="#gc2b6cf0fe7ce4b234b31f8e8d2b4b0b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SoProjection *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hxfield.html#g9f0fa3dc4d875a73a156482853f88fa4">TetraGrid::m_projection</a></td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g71652bc9837e498266f4c4378c1488b1"></a><!-- doxytag: member="TetraCut.h::EPS" ref="g71652bc9837e498266f4c4378c1488b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPS&nbsp;&nbsp;&nbsp;1E-8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g81288a39cb2f7217756275c99b5565c1"></a><!-- doxytag: member="HxFieldWinDLLApi.h::HXFIELD_API" ref="g81288a39cb2f7217756275c99b5565c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HXFIELD_API          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="geb99d06c3ebcb1de7946d70c3eb45c08"></a><!-- doxytag: member="QxReadRawDialog.h::READ_RAW_NTEXTFIELDS" ref="geb99d06c3ebcb1de7946d70c3eb45c08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define READ_RAW_NTEXTFIELDS&nbsp;&nbsp;&nbsp;10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gb82802d878131cc995f34bb2ae09e732"></a><!-- doxytag: member="QxReadRawDialog.h::READ_RAW_NRADIOBUTTONS" ref="gb82802d878131cc995f34bb2ae09e732" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define READ_RAW_NRADIOBUTTONS&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g809543720c0198d15c91f8c18343b042"></a><!-- doxytag: member="QxReadRawDialog.h::READ_RAW_NCOMBOBOXES" ref="g809543720c0198d15c91f8c18343b042" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define READ_RAW_NCOMBOBOXES&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g942fa29e807297e1e6ea848c5edf3e07"></a><!-- doxytag: member="HxGeodeticDataInterface.h::CHECK_GEODETIC" ref="g942fa29e807297e1e6ea848c5edf3e07" args="(field)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_GEODETIC          </td>
          <td>(</td>
          <td class="paramtype">field&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;HxGeodeticDataInterface::checkGeodeticTransformCoordinates(field)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gc76d9ddbb71bb31ca580c1e60f5cf97f"></a><!-- doxytag: member="HxGeodeticDataInterface.h::GEODETIC_EQUATOR_RATIO" ref="gc76d9ddbb71bb31ca580c1e60f5cf97f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEODETIC_EQUATOR_RATIO&nbsp;&nbsp;&nbsp;0.00000899321012635460f          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g165fc71f87a970ae2e8de8991ccc37a6"></a><!-- doxytag: member="HxLattice3.h::EvalLatFunc" ref="g165fc71f87a970ae2e8de8991ccc37a6" args="(HxLattice3 *, mculong, float *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="group__hxfield.html#g165fc71f87a970ae2e8de8991ccc37a6">EvalLatFunc</a>(<a class="el" href="class_hx_lattice3.html">HxLattice3</a> *, <a class="el" href="group__mclib.html#g198d31a7cf38338965096132873d192c">mculong</a>, float *)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gdb394891517080e1656dc9c111659bb9"></a><!-- doxytag: member="HxField3.h::EvalNative" ref="gdb394891517080e1656dc9c111659bb9" args="(void *userData, HxLocation3 *, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="group__hxfield.html#gdb394891517080e1656dc9c111659bb9">EvalNative</a>(void *userData, <a class="el" href="class_hx_location3.html">HxLocation3</a> *, void *)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g881d79f65a2c7d7c2229ca2522bb4da7"></a><!-- doxytag: member="HxField3.h::EvalFloat" ref="g881d79f65a2c7d7c2229ca2522bb4da7" args="(void *userData, HxLocation3 *, float *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="group__hxfield.html#g881d79f65a2c7d7c2229ca2522bb4da7">EvalFloat</a>(void *userData, <a class="el" href="class_hx_location3.html">HxLocation3</a> *, float *)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gf2afe15193f52cc7963357f8f6acce73"></a><!-- doxytag: member="HxCoordType.h::HxCoordType" ref="gf2afe15193f52cc7963357f8f6acce73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hxfield.html#gf2afe15193f52cc7963357f8f6acce73">HxCoordType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration of regular coordinate types. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggf2afe15193f52cc7963357f8f6acce73d9b465887574c079ddfc3a4376e3d21a"></a><!-- doxytag: member="c_undefined" ref="ggf2afe15193f52cc7963357f8f6acce73d9b465887574c079ddfc3a4376e3d21a" args="" -->c_undefined</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggf2afe15193f52cc7963357f8f6acce737115bdb16447e2d4a2b1e55d7286a559"></a><!-- doxytag: member="c_uniform" ref="ggf2afe15193f52cc7963357f8f6acce737115bdb16447e2d4a2b1e55d7286a559" args="" -->c_uniform</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggf2afe15193f52cc7963357f8f6acce73f9b101be644dd3c27480dcdbef9e5666"></a><!-- doxytag: member="c_stacked" ref="ggf2afe15193f52cc7963357f8f6acce73f9b101be644dd3c27480dcdbef9e5666" args="" -->c_stacked</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggf2afe15193f52cc7963357f8f6acce73263c1932363ac239b0965103da68e97a"></a><!-- doxytag: member="c_rectilinear" ref="ggf2afe15193f52cc7963357f8f6acce73263c1932363ac239b0965103da68e97a" args="" -->c_rectilinear</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggf2afe15193f52cc7963357f8f6acce7372c3a3ad050b50e66cc216c1b5989050"></a><!-- doxytag: member="c_uniform_oblique" ref="ggf2afe15193f52cc7963357f8f6acce7372c3a3ad050b50e66cc216c1b5989050" args="" -->c_uniform_oblique</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggf2afe15193f52cc7963357f8f6acce73c83a6796c412739294e86c53d76b21ef"></a><!-- doxytag: member="c_stacked_oblique" ref="ggf2afe15193f52cc7963357f8f6acce73c83a6796c412739294e86c53d76b21ef" args="" -->c_stacked_oblique</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggf2afe15193f52cc7963357f8f6acce73360151a0119dcf90d32a61c4a0711a3c"></a><!-- doxytag: member="c_rectilinear_oblique" ref="ggf2afe15193f52cc7963357f8f6acce73360151a0119dcf90d32a61c4a0711a3c" args="" -->c_rectilinear_oblique</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggf2afe15193f52cc7963357f8f6acce7330da36a349804648d464764eb30a1048"></a><!-- doxytag: member="c_curvilinear" ref="ggf2afe15193f52cc7963357f8f6acce7330da36a349804648d464764eb30a1048" args="" -->c_curvilinear</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g33b982ff557e3bbd8f6286f2619bff27"></a><!-- doxytag: member="HexaGrid::locatePoint" ref="g33b982ff557e3bbd8f6286f2619bff27" args="(McVec3f pos, int &amp;iCell, McVec3f &amp;barycentrics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HexaGrid::locatePoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_vec3f.html">McVec3f</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>iCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>barycentrics</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g42064dd975a5d090007ddd7b19867901"></a><!-- doxytag: member="HexaGrid::octreeInvalidate" ref="g42064dd975a5d090007ddd7b19867901" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HexaGrid::octreeInvalidate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g4037b9b17eddec86694ee5b92bf75de2"></a><!-- doxytag: member="HexaGrid::octreeInfo" ref="g4037b9b17eddec86694ee5b92bf75de2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HexaGrid::octreeInfo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g91c79746a6ef182da78c22216832ac6a"></a><!-- doxytag: member="HexaGrid::calcJacobianOfBarycentricsToWc" ref="g91c79746a6ef182da78c22216832ac6a" args="(int iCell, McVec3f &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_mat3f.html">McMat3f</a> HexaGrid::calcJacobianOfBarycentricsToWc           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_vec3f.html">McVec3f</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gfc98333c1c1488e52934b98156456e3f"></a><!-- doxytag: member="HexaGrid::getCentroids" ref="gfc98333c1c1488e52934b98156456e3f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_mc_vec3f.html">McVec3f</a>&gt;&amp; HexaGrid::getCentroids           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g64e19d5a77701ef5528eaa3aab3aa866"></a><!-- doxytag: member="HxScalarField3.h::autoSetRange" ref="g64e19d5a77701ef5528eaa3aab3aa866" args="(HxSpatialData *data, HxPortMultiMenu &amp;portMappingType, HxPortFloatTextN &amp;portLinearRange, HxPortColormap &amp;portColormap, int mapping_index=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HXFIELD_API autoSetRange           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hx_spatial_data.html">HxSpatialData</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_hx_port_multi_menu.html">HxPortMultiMenu</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>portMappingType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_hx_port_float_text_n.html">HxPortFloatTextN</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>portLinearRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_hx_port_colormap.html">HxPortColormap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>portColormap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mapping_index</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These methods are used to initialize ports for example in HxOrthoSlice. 
<p>

</div>
</div><p>
<a class="anchor" name="g3d9bf54add9deaf570f9ea657a549fa8"></a><!-- doxytag: member="HxScalarField3.h::autoSetRangePortColormap" ref="g3d9bf54add9deaf570f9ea657a549fa8" args="(HxSpatialData *data, HxPortColormap &amp;portColormap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HXFIELD_API autoSetRangePortColormap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hx_spatial_data.html">HxSpatialData</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_hx_port_colormap.html">HxPortColormap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>portColormap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g9e36ec7ca6feec3d8037392ba345c1f0"></a><!-- doxytag: member="TetraGrid::TetraGrid" ref="g9e36ec7ca6feec3d8037392ba345c1f0" args="(HxParamBundle *parameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TetraGrid::TetraGrid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_hx_param_bundle.html">HxParamBundle</a> *&nbsp;</td>
          <td class="paramname"> <em>parameters</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="g22a403dda51a8b1cfcc618e668c5d05d"></a><!-- doxytag: member="TetraGrid::~TetraGrid" ref="g22a403dda51a8b1cfcc618e668c5d05d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TetraGrid::~TetraGrid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<a class="anchor" name="g3e1a9b8a3d12b187c7639e866c484823"></a><!-- doxytag: member="TetraGrid::clear" ref="g3e1a9b8a3d12b187c7639e866c484823" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes everything, creating an empty grid. 
<p>

</div>
</div><p>
<a class="anchor" name="g4daf44b8da172cead9b806202247273c"></a><!-- doxytag: member="TetraGrid::getBoundingBox" ref="g4daf44b8da172cead9b806202247273c" args="(float box[6]) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::getBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>box</em>[6]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns bounding box of point coordinates. 
<p>

<p>
Reimplemented in <a class="el" href="class_hx_tetra_grid.html#754cde7603c42a4901f0373e7535b2bb">HxTetraGrid</a>.
</div>
</div><p>
<a class="anchor" name="gfe53e435579f9ecc56bc8116303a1d2d"></a><!-- doxytag: member="TetraGrid::sortTetrahedra" ref="gfe53e435579f9ecc56bc8116303a1d2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::sortTetrahedra           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sort tetrahedra according to material type and z-direction. 
<p>

</div>
</div><p>
<a class="anchor" name="g32911eaf01b72a63f40ca834339cd60d"></a><!-- doxytag: member="TetraGrid::createTriangles2" ref="g32911eaf01b72a63f40ca834339cd60d" args="(const int *aliasInfo=0, int nBoundaryTriangles=0, int(*pointIndices)[3]=0, unsigned char *ids=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::createTriangles2           </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>aliasInfo</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nBoundaryTriangles</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pointIndices</em>[3] = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>ids</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts all faces (need to be called after topology changed). 
<p>
In case of duplicated vertices two neighbouring tetrahedra may reference different points with truely identical coordinates. This situation will be checked and only a single triangle will be created between such tetrahedra. If you know in advance which vertices are duplicated, you may provide an <code>aliasInfo</code> array, denoting for each vertex the id of the original non-aliased vertex. If <code>aliasInfo</code> is zero, the required information will be computed by means of <a class="el" href="group__hxfield.html#g53ea85bd14dcff5378aa92172aa290e3">computeAliasInfo()</a>. Optionally, a list of boundary triangles can be passed to the methods. Each one is given by by 3 point indices. 
</div>
</div><p>
<a class="anchor" name="g2fb7c975ffa91d6df81c3d9e36c8b41d"></a><!-- doxytag: member="TetraGrid::computeNormals" ref="g2fb7c975ffa91d6df81c3d9e36c8b41d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::computeNormals           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes triangle normals. 
<p>
Need to be called after the coordinates of the grid vertices have been modified. This method is also called from createTriangles. 
</div>
</div><p>
<a class="anchor" name="ga5becd91fd32f10266e332ec90e557a7"></a><!-- doxytag: member="TetraGrid::setProjection" ref="ga5becd91fd32f10266e332ec90e557a7" args="(SoProjection *projection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::setProjection           </td>
          <td>(</td>
          <td class="paramtype">SoProjection *&nbsp;</td>
          <td class="paramname"> <em>projection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gffce172b06d8685ccac97a3d6270facd"></a><!-- doxytag: member="TetraGrid::createEdges" ref="gffce172b06d8685ccac97a3d6270facd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::createEdges           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts all edges (needs to be called after topology changed). 
<p>

</div>
</div><p>
<a class="anchor" name="g0bb3aadea223292a4c83ace7aa96665f"></a><!-- doxytag: member="TetraGrid::createEdgesPerTetra" ref="g0bb3aadea223292a4c83ace7aa96665f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::createEdgesPerTetra           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates edgesPerTetra. 
<p>

</div>
</div><p>
<a class="anchor" name="g321ca5c84ba17342286ef9eb4e378e64"></a><!-- doxytag: member="TetraGrid::fixOrientation" ref="g321ca5c84ba17342286ef9eb4e378e64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::fixOrientation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fix inverted tetrahedra. 
<p>
The volume of every tetrahedron is computed. If the volume is negative, the tetrahedron's vertices are swapped so that the volume gets positive. 
</div>
</div><p>
<a class="anchor" name="g45ab40bfdeddf59204b22050dfc1b8e7"></a><!-- doxytag: member="TetraGrid::makeObsolete" ref="g45ab40bfdeddf59204b22050dfc1b8e7" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::makeObsolete           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks a tetrahedron as removed. 
<p>
It doesn't get physically removed until the next call of <a class="el" href="group__hxfield.html#g5e67567e1c9209e0ba9c9f42fffb3ee4">removeObsoleteTetras()</a>. 
</div>
</div><p>
<a class="anchor" name="g74a4561181b675677102c2342d6043b4"></a><!-- doxytag: member="TetraGrid::isObsoleteTetra" ref="g74a4561181b675677102c2342d6043b4" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::isObsoleteTetra           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if a tetrahedron is marked obsolete, false otherwise. 
<p>

</div>
</div><p>
<a class="anchor" name="g27c9730bb58f526fb62256fd0f0c1a0b"></a><!-- doxytag: member="TetraGrid::isObsoleteTriangle" ref="g27c9730bb58f526fb62256fd0f0c1a0b" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::isObsoleteTriangle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if a triangle is marked obsolete, false otherwise. 
<p>

</div>
</div><p>
<a class="anchor" name="gea6633685b1f025be0740eb25b86c7ad"></a><!-- doxytag: member="TetraGrid::getOppositeFace" ref="gea6633685b1f025be0740eb25b86c7ad" args="(int iTet, int iVert)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::getOppositeFace           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iTet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iVert</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns opposite face of vertex iVert in tetra iTet. 
<p>

</div>
</div><p>
<a class="anchor" name="gb366ebdefefd9e6a148f023dba8cd406"></a><!-- doxytag: member="TetraGrid::getOppositeFaceAtEdge" ref="gb366ebdefefd9e6a148f023dba8cd406" args="(int iTet, int iFace, int from, int to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::getOppositeFaceAtEdge           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iTet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns opposite face of face iFace at edge from-to in tetra iTet. 
<p>

</div>
</div><p>
<a class="anchor" name="gf7db96ccc97b2bba463383e7c0990333"></a><!-- doxytag: member="TetraGrid::getOppositeVertex" ref="gf7db96ccc97b2bba463383e7c0990333" args="(int iTet, int iFace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::getOppositeVertex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iTet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns opposite vertex of face iFace in tetra iTet. 
<p>

</div>
</div><p>
<a class="anchor" name="g79aae71986fc05410a4428fdce89c6b0"></a><!-- doxytag: member="TetraGrid::getOppositeTetra" ref="g79aae71986fc05410a4428fdce89c6b0" args="(int iFace, int iTet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::getOppositeTetra           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iTet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns opposite tetra of tetra iTet at face iFace. 
<p>

</div>
</div><p>
<a class="anchor" name="gba98e8f16f98bda034a468a154a84401"></a><!-- doxytag: member="TetraGrid::createTetraFromFaces" ref="gba98e8f16f98bda034a468a154a84401" args="(int iTet, int *faces)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::createTetraFromFaces           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iTet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>faces</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creates tetrahedron from 4 faces given. 
<p>

</div>
</div><p>
<a class="anchor" name="g5e67567e1c9209e0ba9c9f42fffb3ee4"></a><!-- doxytag: member="TetraGrid::removeObsoleteTetras" ref="g5e67567e1c9209e0ba9c9f42fffb3ee4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::removeObsoleteTetras           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes unused tetrahedrons. 
<p>
A tetrahedron is considered not to be part of the grid if the value of tetras[i].points[0] is negative. This methods removes all such tetrahedrons. All arrays and indices of the grid are updated as necessary. 
</div>
</div><p>
<a class="anchor" name="g0a25336c5bc0ce7a3cd93558342f5502"></a><!-- doxytag: member="TetraGrid::removeObsoleteTriangles" ref="g0a25336c5bc0ce7a3cd93558342f5502" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::removeObsoleteTriangles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes unused triangles. 
<p>
A triangle is considered not to be part of the grid if the value of triangles[i].points[0] is negative. This methods removes all such triangles. All arrays and indices of the grid are updated as necessary. 
</div>
</div><p>
<a class="anchor" name="ge18cd8c62f752a368dc129e69e78a56d"></a><!-- doxytag: member="TetraGrid::checkConsistency" ref="ge18cd8c62f752a368dc129e69e78a56d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::checkConsistency           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
performs a consistency check on the tetragrid. 
<p>
returns one if grid is consistent, zero otherwise 
</div>
</div><p>
<a class="anchor" name="gfe84d4a2ad0766a11dfbedce98a2754a"></a><!-- doxytag: member="TetraGrid::computeVertexHints" ref="gfe84d4a2ad0766a11dfbedce98a2754a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::computeVertexHints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For every point find one triangle incident at that point. 
<p>
The results are stored in the vertexHints array. For points not referenced by any triangle the value of vertexHints is set to -1. This is the case for duplicated points. 
</div>
</div><p>
<a class="anchor" name="g88fdfec606d89a39e16d3e39431a2056"></a><!-- doxytag: member="TetraGrid::computeTetrasPerPoint" ref="g88fdfec606d89a39e16d3e39431a2056" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::computeTetrasPerPoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g53ea85bd14dcff5378aa92172aa290e3"></a><!-- doxytag: member="TetraGrid::computeAliasInfo" ref="g53ea85bd14dcff5378aa92172aa290e3" args="(McDArray&lt; int &gt; &amp;aliases)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::computeAliasInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aliases</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g9dbb3121ae9d5e16e5180ee06b31d624"></a><!-- doxytag: member="TetraGrid::initFromAmiraMesh" ref="g9dbb3121ae9d5e16e5180ee06b31d624" args="(AmiraMesh *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::initFromAmiraMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_amira_mesh.html">AmiraMesh</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize tetrahedral grid from a <a class="el" href="class_amira_mesh.html">AmiraMesh</a> file descriptor. 
<p>

</div>
</div><p>
<a class="anchor" name="gddd982d4b7aca979cd4ea659ab092655"></a><!-- doxytag: member="TetraGrid::rebuildOctree" ref="gddd982d4b7aca979cd4ea659ab092655" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::rebuildOctree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rebuilds octree. 
<p>

</div>
</div><p>
<a class="anchor" name="gfa395cf23701c90ea9ff43e26ed43c5f"></a><!-- doxytag: member="TetraGrid::isBoundaryEdge" ref="gfa395cf23701c90ea9ff43e26ed43c5f" args="(int vert1, int vert2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::isBoundaryEdge           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vert1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vert2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find out if edge is boundary edge 
<p>

</div>
</div><p>
<a class="anchor" name="ge1e66f2839ae2f4d670eb05bdae4f728"></a><!-- doxytag: member="TetraGrid::isBoundaryConditionEdge" ref="ge1e66f2839ae2f4d670eb05bdae4f728" args="(int vert1, int vert2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::isBoundaryConditionEdge           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vert1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vert2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
find out if edge is boundary condition edge 
<p>

</div>
</div><p>
<a class="anchor" name="g6359bebc8361c82ac8e389d85a87a554"></a><!-- doxytag: member="TetraGrid::bisectEdge" ref="g6359bebc8361c82ac8e389d85a87a554" args="(int iEdge)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::bisectEdge           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iEdge</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
bisect edge 
<p>

</div>
</div><p>
<a class="anchor" name="g998ceda16d413030b446da7b6871ca28"></a><!-- doxytag: member="TetraGrid::bisectEdge" ref="g998ceda16d413030b446da7b6871ca28" args="(int vert1, int vert2, McVec3f *newVertex=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::bisectEdge           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vert1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vert2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_vec3f.html">McVec3f</a> *&nbsp;</td>
          <td class="paramname"> <em>newVertex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
bisect edge 
<p>

</div>
</div><p>
<a class="anchor" name="g86983b1bb480ef0660080fdb1c7a0db6"></a><!-- doxytag: member="TetraGrid::collapseEdge" ref="g86983b1bb480ef0660080fdb1c7a0db6" args="(int vert1, int vert2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::collapseEdge           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vert1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vert2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
collapse edge 
<p>

</div>
</div><p>
<a class="anchor" name="ga3a2491ae29bec2e487dd832cc8ae83d"></a><!-- doxytag: member="TetraGrid::getCoordTransformMatrix" ref="ga3a2491ae29bec2e487dd832cc8ae83d" args="(int iTetra)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_mat3f.html">McMat3f</a> TetraGrid::getCoordTransformMatrix           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iTetra</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the coordinate transform matrix from local barycentric coordinates to world coordinates. 
<p>

</div>
</div><p>
<a class="anchor" name="ge30db9c6cef8588e0b36abc7d3fa6ce7"></a><!-- doxytag: member="TetraGrid::detJ" ref="ge30db9c6cef8588e0b36abc7d3fa6ce7" args="(int iTet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TetraGrid::detJ           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iTet</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determinant of Jacobi matrix for transformation to unit tetrahedron. 
<p>

</div>
</div><p>
<a class="anchor" name="gdba2a246561faa48fc62cdfd0fd686fd"></a><!-- doxytag: member="TetraGrid::getQuality" ref="gdba2a246561faa48fc62cdfd0fd686fd" args="(int nr_tetrahedron, float &amp;determinante, float &amp;inner_radius, float &amp;outer_radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::getQuality           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nr_tetrahedron</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>determinante</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>outer_radius</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute determinant, inner and outer radius for tetrahedron. 
<p>

</div>
</div><p>
<a class="anchor" name="g81556a38a8dbfc91ff23fcf11d30eb8e"></a><!-- doxytag: member="TetraGrid::getEdgeQuality" ref="g81556a38a8dbfc91ff23fcf11d30eb8e" args="(int iEdge)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TetraGrid::getEdgeQuality           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iEdge</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute edge quality. 
<p>

</div>
</div><p>
<a class="anchor" name="g2d2968442d103838878629030db8ca88"></a><!-- doxytag: member="TetraGrid::calcMinDet" ref="g2d2968442d103838878629030db8ca88" args="(McSmallArray&lt; int, 8 &gt; &amp;tetraList, McSmallArray&lt; int, 8 &gt; &amp;iTetWorst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TetraGrid::calcMinDet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tetraList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iTetWorst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute minimal determinant for list of tetras. 
<p>

</div>
</div><p>
<a class="anchor" name="gdbb6ed2e7d41387736093faceadc90b8"></a><!-- doxytag: member="TetraGrid::calcMaxDiamRatio" ref="gdbb6ed2e7d41387736093faceadc90b8" args="(McSmallArray&lt; int, 8 &gt; &amp;tetraList, McSmallArray&lt; int, 8 &gt; &amp;iTetWorst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TetraGrid::calcMaxDiamRatio           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tetraList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt; int, 8 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iTetWorst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute maximal diameter ratio for list of tetras. 
<p>

</div>
</div><p>
<a class="anchor" name="g4581594684f0fd86d19af041d78e44d5"></a><!-- doxytag: member="TetraGrid::globalRefine" ref="g4581594684f0fd86d19af041d78e44d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::globalRefine           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global refinement. 
<p>

</div>
</div><p>
<a class="anchor" name="g2db4503eab26ef9ad4e0f8e3f763b9df"></a><!-- doxytag: member="TetraGrid::getVolume" ref="g2db4503eab26ef9ad4e0f8e3f763b9df" args="(int materialId=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TetraGrid::getVolume           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>materialId</em> = <code>-1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The volume of the grid (default) or of the given material id. 
<p>
Note: Stored Material Ids start with zero, thus Parameter values must be decremented by 1. 
</div>
</div><p>
<a class="anchor" name="g9b88aeca41592e311062791bf8368be3"></a><!-- doxytag: member="TetraGrid::getNumIslands" ref="g9b88aeca41592e311062791bf8368be3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::getNumIslands           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The amount of islands, i.e. 
<p>
isolated regions within the grid 
</div>
</div><p>
<a class="anchor" name="g9a728861f9cbc9965a6a84cafd30a9a7"></a><!-- doxytag: member="TetraGrid::getConnectedElements" ref="g9a728861f9cbc9965a6a84cafd30a9a7" args="(unsigned int tetraIndex, McBitfield &amp;tetras)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long TetraGrid::getConnectedElements           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>tetraIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mc_bitfield.html">McBitfield</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tetras</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
face connected component search, starting from tetraIndex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tetras</em>&nbsp;</td><td>must be a bit field with the same size as the amount of tetrahedrons, wherein connected tetras of the region are marked. The return value indicates the size, i.e. the number of tetrahedrons of the region that contains tetra[<code>tetraIndex</code>]. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g09a67b722574e7575be3c77569ee1207"></a><!-- doxytag: member="TetraGrid::insertTriangle" ref="g09a67b722574e7575be3c77569ee1207" args="(int index, int point1, int point2, int point3, int cell1, int cell2, int bnd, int bndCond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::insertTriangle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cell1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cell2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bndCond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a triangle. 
<p>
The size of the triangle array is not modified. It must have been resized before. The method also recomputes the triangle normal. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>the index of the triangle to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point1</em>&nbsp;</td><td>the index of the first point of the triangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point2</em>&nbsp;</td><td>the index of the second point of the triangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point3</em>&nbsp;</td><td>the index of the third point of the triangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cell1</em>&nbsp;</td><td>the index of the first adjacent tetrahedron </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cell2</em>&nbsp;</td><td>the index of the second adjacent tetrahedron or -1, if the triangle is a boundary face with only one adjacent cell </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bnd</em>&nbsp;</td><td>a flag indicating if the traingle is a boundary face or not </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bndCnd</em>&nbsp;</td><td>the boundary condition id of the triangle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc45c11565e682c1c44fb476960eccdf9"></a><!-- doxytag: member="TetraGrid::addTriangle" ref="gc45c11565e682c1c44fb476960eccdf9" args="(int point1, int point2, int point3, int cell1, int cell2, int bnd, int bndCond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TetraGrid::addTriangle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>point3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cell1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cell2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bndCond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends a triangle to the grid. 
<p>
The size of the triangle array is enlarged by one. The method also recomputes the triangle normal. It returns the id of the new triangle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>point1</em>&nbsp;</td><td>the index of the first point of the triangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point2</em>&nbsp;</td><td>the index of the second point of the triangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point3</em>&nbsp;</td><td>the index of the third point of the triangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cell1</em>&nbsp;</td><td>the index of the first adjacent tetrahedron </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cell2</em>&nbsp;</td><td>the index of the second adjacent tetrahedron or -1, if the triangle is a boundary face with only one adjacent cell </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bnd</em>&nbsp;</td><td>a flag indicating if the traingle is a boundary face or not </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bndCnd</em>&nbsp;</td><td>the boundary condition id of the triangle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gda65a2f77d70ee9d682cfb8c24ed7c9f"></a><!-- doxytag: member="TetraGrid::updateFaceNormal" ref="gda65a2f77d70ee9d682cfb8c24ed7c9f" args="(int i, int insidePoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TetraGrid::updateFaceNormal           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>insidePoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g840c0f3e5328935eaf5c27524f36b336"></a><!-- doxytag: member="HexaGrid::points" ref="g840c0f3e5328935eaf5c27524f36b336" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_mc_vec3f.html">McVec3f</a>&gt; <a class="el" href="group__hxfield.html#g840c0f3e5328935eaf5c27524f36b336">HexaGrid::points</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of grid points. 
<p>

</div>
</div><p>
<a class="anchor" name="gfa3d7e5253e482a986bbf1547954abce"></a><!-- doxytag: member="HexaGrid::hexas" ref="gfa3d7e5253e482a986bbf1547954abce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;Hexa&gt; <a class="el" href="group__hxfield.html#gfa3d7e5253e482a986bbf1547954abce">HexaGrid::hexas</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of hexahedrons. 
<p>

</div>
</div><p>
<a class="anchor" name="g1643b57b372ea2a8c0d41c1c4d7fbbe1"></a><!-- doxytag: member="HexaGrid::materialIds" ref="g1643b57b372ea2a8c0d41c1c4d7fbbe1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;unsigned char&gt; <a class="el" href="group__hxfield.html#g1643b57b372ea2a8c0d41c1c4d7fbbe1">HexaGrid::materialIds</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For every hexahedron a material id. 
<p>

</div>
</div><p>
<a class="anchor" name="g0437008a3f402d23d7b5ab8eca65a532"></a><!-- doxytag: member="HexaGrid::faces" ref="g0437008a3f402d23d7b5ab8eca65a532" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;Face&gt; <a class="el" href="group__hxfield.html#g0437008a3f402d23d7b5ab8eca65a532">HexaGrid::faces</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of faces. 
<p>

</div>
</div><p>
<a class="anchor" name="gd28551daa55c81ba72bb5f245bf4183d"></a><!-- doxytag: member="HexaGrid::hexasPerPoint" ref="gd28551daa55c81ba72bb5f245bf4183d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt;int,8&gt; &gt; <a class="el" href="group__hxfield.html#gd28551daa55c81ba72bb5f245bf4183d">HexaGrid::hexasPerPoint</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hexahedrons per point (optional). 
<p>

</div>
</div><p>
<a class="anchor" name="g29b972d00beca094b2759e61f5e916f9"></a><!-- doxytag: member="HexaGrid::numDuplicatedNodes" ref="g29b972d00beca094b2759e61f5e916f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hxfield.html#g29b972d00beca094b2759e61f5e916f9">HexaGrid::numDuplicatedNodes</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates how many points are duplicated. 
<p>

</div>
</div><p>
<a class="anchor" name="g1992a1075603dd3090b9d3e429838c90"></a><!-- doxytag: member="HexaGrid::params" ref="g1992a1075603dd3090b9d3e429838c90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hx_param_bundle.html">HxParamBundle</a>&amp; <a class="el" href="group__hxfield.html#g1992a1075603dd3090b9d3e429838c90">HexaGrid::params</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reference to parameters of derived <a class="el" href="class_hx_hexa_grid.html">HxHexaGrid</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="g9894d08d449b68db149c66ce4180ab51"></a><!-- doxytag: member="HexaGrid::m_centerPoints" ref="g9894d08d449b68db149c66ce4180ab51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_mc_vec3f.html">McVec3f</a>&gt; <a class="el" href="group__hxfield.html#g9894d08d449b68db149c66ce4180ab51">HexaGrid::m_centerPoints</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computed on demand by the getCentroids method. 
<p>

</div>
</div><p>
<a class="anchor" name="g864b3846c80385a35c97bdce855b35c6"></a><!-- doxytag: member="HexaGrid::m_octreeMutex" ref="g864b3846c80385a35c97bdce855b35c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_mutex.html">McMutex</a> <a class="el" href="group__hxfield.html#g864b3846c80385a35c97bdce855b35c6">HexaGrid::m_octreeMutex</a><code> [protected, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ge2a7cbf2881028b6343234e77f0cac83"></a><!-- doxytag: member="TetraGrid::points" ref="ge2a7cbf2881028b6343234e77f0cac83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;<a class="el" href="class_mc_vec3f.html">McVec3f</a>&gt; <a class="el" href="group__hxfield.html#ge2a7cbf2881028b6343234e77f0cac83">TetraGrid::points</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of grid points. 
<p>

</div>
</div><p>
<a class="anchor" name="gd6f8bde9089b1876c482093a41294712"></a><!-- doxytag: member="TetraGrid::vertexHints" ref="gd6f8bde9089b1876c482093a41294712" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;int&gt; <a class="el" href="group__hxfield.html#gd6f8bde9089b1876c482093a41294712">TetraGrid::vertexHints</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For every point id of a triangle incident at that point. 
<p>

</div>
</div><p>
<a class="anchor" name="g5ff7ac0316c5079669e7c18fc3768108"></a><!-- doxytag: member="TetraGrid::tetras" ref="g5ff7ac0316c5079669e7c18fc3768108" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;Tetra&gt; <a class="el" href="group__hxfield.html#g5ff7ac0316c5079669e7c18fc3768108">TetraGrid::tetras</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of tetrahedrons. 
<p>

</div>
</div><p>
<a class="anchor" name="g6c149d8dc81421f1ef5c8c5d87643135"></a><!-- doxytag: member="TetraGrid::materialIds" ref="g6c149d8dc81421f1ef5c8c5d87643135" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;unsigned char&gt; <a class="el" href="group__hxfield.html#g6c149d8dc81421f1ef5c8c5d87643135">TetraGrid::materialIds</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For every tetrahedron a material id. 
<p>

</div>
</div><p>
<a class="anchor" name="g6fe743d1070487ce510555c097366c76"></a><!-- doxytag: member="TetraGrid::edgesPerTetra" ref="g6fe743d1070487ce510555c097366c76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;EdgesPerTetra&gt; <a class="el" href="group__hxfield.html#g6fe743d1070487ce510555c097366c76">TetraGrid::edgesPerTetra</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For every tetrahedron indices of its edges (optional). 
<p>

</div>
</div><p>
<a class="anchor" name="g863c144817b839ec5f4f31b5093cc1f0"></a><!-- doxytag: member="TetraGrid::triangles" ref="g863c144817b839ec5f4f31b5093cc1f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;Triangle&gt; <a class="el" href="group__hxfield.html#g863c144817b839ec5f4f31b5093cc1f0">TetraGrid::triangles</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of triangles. 
<p>

</div>
</div><p>
<a class="anchor" name="g50944d6b1ca3e59bc7c1f28cf9403a0f"></a><!-- doxytag: member="TetraGrid::edges" ref="g50944d6b1ca3e59bc7c1f28cf9403a0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt;Edge&gt; <a class="el" href="group__hxfield.html#g50944d6b1ca3e59bc7c1f28cf9403a0f">TetraGrid::edges</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of edges (optional). 
<p>

</div>
</div><p>
<a class="anchor" name="ge672232b9bae093ff5f71d1ce008c88f"></a><!-- doxytag: member="TetraGrid::tetrasPerPoint" ref="ge672232b9bae093ff5f71d1ce008c88f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_d_array.html">McDArray</a>&lt; <a class="el" href="class_mc_small_array.html">McSmallArray</a>&lt;int,8&gt; &gt; <a class="el" href="group__hxfield.html#ge672232b9bae093ff5f71d1ce008c88f">TetraGrid::tetrasPerPoint</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tetrahedrons per point (optional). 
<p>

</div>
</div><p>
<a class="anchor" name="g5630d09298a315a836e2a2f301511fbb"></a><!-- doxytag: member="TetraGrid::numDuplicatedNodes" ref="g5630d09298a315a836e2a2f301511fbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__hxfield.html#g5630d09298a315a836e2a2f301511fbb">TetraGrid::numDuplicatedNodes</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates how many points are duplicated. 
<p>

</div>
</div><p>
<a class="anchor" name="g209a7395d32583c46c76e795d712df31"></a><!-- doxytag: member="TetraGrid::params" ref="g209a7395d32583c46c76e795d712df31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_hx_param_bundle.html">HxParamBundle</a>&amp; <a class="el" href="group__hxfield.html#g209a7395d32583c46c76e795d712df31">TetraGrid::params</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reference to parameters of derived <a class="el" href="class_hx_tetra_grid.html">HxTetraGrid</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="gc2b6cf0fe7ce4b234b31f8e8d2b4b0b2"></a><!-- doxytag: member="TetraGrid::octree" ref="gc2b6cf0fe7ce4b234b31f8e8d2b4b0b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mc_static_octree.html">McStaticOctree</a>&lt;int&gt; <a class="el" href="group__hxfield.html#gc2b6cf0fe7ce4b234b31f8e8d2b4b0b2">TetraGrid::octree</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Octree for point location. 
<p>

</div>
</div><p>
<a class="anchor" name="g9f0fa3dc4d875a73a156482853f88fa4"></a><!-- doxytag: member="TetraGrid::m_projection" ref="g9f0fa3dc4d875a73a156482853f88fa4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SoProjection* <a class="el" href="group__hxfield.html#g9f0fa3dc4d875a73a156482853f88fa4">TetraGrid::m_projection</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr class="footer"/><address style="text-align: right;"><small>
<a href="http://www.vsg3d.com/" target="_blank">Amira</a> Developer Reference
- &copy; 2005 - 2011 <a href="http://www.zib.de/" target="_blank">Zuse Institute Berlin</a>,
<a href="http://www.vsg3d.com" target="_blank">Visualization Sciences Group, SAS</a>
- Generated on 10 Oct 2013 using <a href="http://www.doxygen.org/" target="_blank">doxygen</a> 1.4.7
</small></address>
</body>
</html>
