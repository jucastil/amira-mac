<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head><title>Amira Online Help</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="../Amira.css" type="text/css" />
<script type="text/javascript" src="../MathJax/MathJax.js?config=default.js"></script>
</head>
<body lang="en">


<p></p>
<h2><a name="A1">11.8 Writing <font face="helvetica">Virtual Reality Option</font> Custom Modules</a></h2>
<p><font face="helvetica">Amira</font> can be easily extended by writing new I/O routines, data types,
modules, and other components. Details about this are described in the
<font face="helvetica">Developer Option</font> User's Guide.</p>
<p>In order to write custom modules which provide specific interaction
features in a VR environment, Open Inventor nodes interpreting events
generated by the 3D input device have to be inserted into the scene graph.
In particular, the 3D input device generates events of type <em>SoTrackerEvent</em> and <em>SoControllerButtonEvent</em>. These two event classes
have been introduced in Open Inventor 3.0. For more information about
these classes please refer to the Open Inventor documentation. <font face="helvetica">Amira</font>
itself provides an additional class <em>Hx3DWandBase</em> which provides
some additional information about the virtual 3D wand. Among others,
this class also allows to user to highlight the wand in order to provide
some visual feedback during interaction.</p>
<p>Below we present the source code of a sample <font face="helvetica">VRSettings</font> module which just
displays a number of cubes. The cubes then can be picked and transformed
using the 3D wand. The source code of the module is contained in the
<font face="helvetica">Developer Option</font> demo package. The particular files are called <em>MyVRDemo.h</em>
and <em>MyVRDemo.cpp</em>. The module can also be directly created from the
popup menu of the <font face="helvetica">VRSettings</font> control module.</p>
<p>Here is the listing of the header file:</p>
<p><font size="1"></font></p><pre>
/////////////////////////////////////////////////////////////////////
//
// Illustrates 3D interaction in a VR environment
//
/////////////////////////////////////////////////////////////////////
#ifndef MY_VR_DEMO_H
#define MY_VR_DEMO_H

#include &lt;Inventor/nodes/SoSeparator.h&gt;

#include &lt;McHandle.h&gt;
#include &lt;hxcore/HxModule.h&gt;
#include &lt;hxcore/HxPortButtonList.h&gt;
#include &lt;mypackage/mypackageAPI.h&gt;

class MYPACKAGE_API MyVRDemo : public HxModule
{
    HX_HEADER(MyVRDemo);

  public:
    MyVRDemo();
    virtual void compute();
    HxPortButtonList portAction;

  protected:
    ~MyVRDemo();

    McHandle&lt;SoSeparator&gt; scene;
    McHandle&lt;SoSeparator&gt; activeCube;

    bool isMoving;
    SbVec3f refPos;
    SbMatrix refMatrix;
    SbRotation refRotInverse;

    void createScene(SoSeparator* scene);
    SoSeparator* checkCube(const SbVec3f&amp; pos);
    void trackerEvent(SoEventCallback* node);
    void controllerEvent(SoEventCallback* node);

    static void trackerEventCB(void* userData, SoEventCallback* node);
    static void controllerEventCB(void* userData, SoEventCallback* node);
};

#endif
</pre><p><font size="1">
</font></p>
<p>Here is the listing of the source file:</p>
<p><font size="0"></font></p><pre>
/////////////////////////////////////////////////////////////////////
//
// Illustrates 3D interaction in a VR environment
//
/////////////////////////////////////////////////////////////////////
#include &lt;stdlib.h&gt;

#include &lt;Inventor/nodes/SoCube.h&gt;
#include &lt;Inventor/nodes/SoMaterial.h&gt;
#include &lt;Inventor/nodes/SoEventCallback.h&gt;
#include &lt;Inventor/nodes/SoMatrixTransform.h&gt;
#include &lt;Inventor/events/SoTrackerEvent.h&gt;
#include &lt;Inventor/events/SoControllerButtonEvent.h&gt;

#include &lt;hxcore/Hx3DWandBase.h&gt;
#include &lt;mypackage/MyVRDemo.h&gt;

HX_INIT_CLASS(MyVRDemo,HxModule)

MyVRDemo::MyVRDemo() :
    HxModule(HxObject::getClassTypeId()),
    portAction(this,"action",1)
{
    isMoving = 0;
    portAction.setLabel(0,"Reset");
    scene = new SoSeparator;
    createScene(scene);
    showGeom(scene);
}

MyVRDemo::~MyVRDemo()
{
    hideGeom(scene);
}

void MyVRDemo::compute()
{
    if (portAction.isNew() &amp;&amp; portAction.getIndex()==0)
        createScene(scene);
}

void MyVRDemo::createScene(SoSeparator* scene)
{
    scene-&gt;removeAllChildren();

    SoEventCallback* cb = new SoEventCallback;
    cb-&gt;addEventCallback(SoTrackerEvent::getClassTypeId(),
        trackerEventCB, this);
    cb-&gt;addEventCallback(SoControllerButtonEvent::getClassTypeId(),
        controllerEventCB, this);
    scene-&gt;addChild(cb);

    for (int j=0; j&lt;4; j++) {
        for (int i=0; i&lt;4; i++) {
            SoSeparator* child = new SoSeparator;

            SoMatrixTransform* xform = new SoMatrixTransform;
            SbMatrix M;
            M.setTranslate(SbVec3f(i*3.f,j*3.f,0));
            xform-&gt;matrix.setValue(M);

            SoMaterial* mat = new SoMaterial;
            float hue = (rand()%1000)/1000.;
            mat-&gt;diffuseColor.setHSVValue(hue,1.f,.8f);

            SoCube* cube = new SoCube;

            child-&gt;addChild(xform);
            child-&gt;addChild(mat);
            child-&gt;addChild(cube);

            scene-&gt;addChild(child);
        }
    }
}

SoSeparator* MyVRDemo::checkCube(const SbVec3f&amp; p)
{
    for (int iChild=1; iChild&lt;scene-&gt;getNumChildren(); iChild++) {
        SoSeparator* child = (SoSeparator*) scene-&gt;getChild(iChild);
        SoMatrixTransform* xform = (SoMatrixTransform*) child-&gt;getChild(0);
        const SbMatrix&amp; M = xform-&gt;matrix.getValue();

        SbVec3f q;
        M.inverse().multVecMatrix(p,q);
        if (fabs(q[0])&lt;1 &amp;&amp; fabs(q[1])&lt;1 &amp;&amp; fabs(q[2])&lt;1) {
            if (activeCube.ptr()!=child) {
                if (activeCube) {
                    SoMaterial* mat = (SoMaterial*) activeCube-&gt;getChild(1);
                    mat-&gt;emissiveColor = SbColor(0.f,0.f,0.f);
                }
                SoMaterial* mat = (SoMaterial*) child-&gt;getChild(1);
                mat-&gt;emissiveColor = mat-&gt;diffuseColor[0];
                activeCube = child;
            }
            return activeCube;
        }
    }

    if (activeCube) {
        SoMaterial* mat = (SoMaterial*) activeCube-&gt;getChild(1);
        mat-&gt;emissiveColor = SbColor(0.f,0.f,0.f);
        activeCube = 0;
    }

    return 0;
}

void MyVRDemo::trackerEventCB(void* userData, SoEventCallback* node)
{
    MyVRDemo* me = (MyVRDemo*) userData;
    me-&gt;trackerEvent(node);
}

void MyVRDemo::trackerEvent(SoEventCallback* node)
{
    SoTrackerEvent* e = (SoTrackerEvent*) node-&gt;getEvent();
    Hx3DWandBase* wand = GET_WAND(e);

    if (activeCube &amp;&amp; isMoving) {
        if (!wand-&gt;getButton(0)) {
            node-&gt;setHandled();
            isMoving = 0;
            return;
        }

        SbMatrix T1; T1.setTranslate(-refPos);
        SbMatrix R; R.setRotate(refRotInverse*wand-&gt;orientation());
        SbMatrix T2; T2.setTranslate(wand-&gt;origin());
        
        SoMatrixTransform* xform = (SoMatrixTransform*) activeCube-&gt;getChild(0);
        xform-&gt;matrix = SbMatrix(refMatrix*T1*R*T2);

        wand-&gt;setHighlight(true);
        node-&gt;setHandled();
        return;
    }

    if (checkCube(wand-&gt;top()))
        node-&gt;setHandled();
}

void MyVRDemo::controllerEventCB(void* userData, SoEventCallback* node)
{
    MyVRDemo* me = (MyVRDemo*) userData;
    me-&gt;controllerEvent(node);
}

void MyVRDemo::controllerEvent(SoEventCallback* node)
{
    if (activeCube) {
        SoTrackerEvent* e = (SoTrackerEvent*) node-&gt;getEvent();
        Hx3DWandBase* wand = GET_WAND(e);
    
        if (wand-&gt;wasButtonPressed(0)) {
            SoMatrixTransform* xform = (SoMatrixTransform*) activeCube-&gt;getChild(0);
            refRotInverse = wand-&gt;orientation().inverse();
            refPos = wand-&gt;origin();
            refMatrix = xform-&gt;matrix.getValue();

            wand-&gt;setHighlight(true);
            isMoving = 1;
        }
        
        if (wand-&gt;wasButtonReleased(0))
            isMoving = 0;

        node-&gt;setHandled();
    }
}

</pre><p><font size="0">
</font></p>
<p>

</p></body>
</html>
