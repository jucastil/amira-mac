<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head><title>Amira Online Help</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="../Amira.css" type="text/css" />
<script type="text/javascript" src="../MathJax/MathJax.js?config=default.js"></script>
</head>
<body lang="en">


<p></p>
<h3><a name="A1">27.5.2 Transformations of Spatial Data Objects</a></h3>
<p>In <font face="helvetica">Amira</font>, all data objects which are embedded in 3D space are derived from
the class <tt>HxSpatialData</tt> defined in the subdirectory <tt>kernel/Amira</tt> (see class hierarchy in <a class="link" href="HxDev-datahierarchy.html#A1">Section 27.1.1</a>).
On the one hand, this class provides a virtual method <tt>getBoundingBox</tt>
which derived classes should redefine. On the other hand, it allows the user
to transform the data object using an arbitrary geometric transformation.
The transformation is stored in an Open Inventor <em>SoTransform</em> node.
This node is applied automatically to any display module attached to a
transformed data object.</p>
<p>In total there are three different coordinate systems:
</p>
<ul><li>The <em>world coordinate system</em> is the system the
 camera of the 3D viewer is defined in.
 </li><li>The <em>table coordinate system</em> is usually the same as the world
 coordinate system. However, it might be different if special modules
 displaying, for example, the geometry of a radiotherapy device is used.
 These modules should call the method <tt>HxBase::useWorldCoords</tt> with
 a non-zero argument in their constructor. Later they may then call
 the method <tt>HxController::setWorldToTableTransform</tt> of the global
 object <tt>theController</tt>. In this way they can cause all other
 objects to be transformed simultaneously.
 </li><li>Finally, the <em>local coordinate</em> system is defined by the
 transformation node stored for objects of type <tt>HxSpatialData</tt>.
 This transformation can be modified interactively using the
 transformation editor. Transformations can be shared between multiple
 data objects using the method <tt>HxBase::setControllingData</tt>. 
 Typically, all display modules attached to a data object will share its
 transformation matrix, so that the geometry generated by these modules
 is transformed automatically when the data itself is transformed.
 </li>
</ul><p></p>
<p>The transformation node of a spatial data object may be accessed using the
<tt>SoTransform* HxSpatialData::getTransform()</tt> method, which may return a
NULL pointer when the data object is not transformed.
Often it is easier to use <tt>HxSpatialData::getTransform(SbMatrix&amp;
matrix)</tt> instead, which returns the current transformation matrix or the
identity matrix when there is no transformation. This matrix is to be
applied by multiplying it to a vector from the right-hand side. It
transforms vectors from the local coordinate system to the table or world
coordinate system.</p>
<p>If you want to transform table or world coordinates to local coordinates,
use <tt>HxSpatialData::getInverseTransform( SbMatrix&amp; matrix)</tt>. For
example, consider the following code which transforms the lower left front
corner of object A into the local coordinate system of a second object B:</p>
<p><font size="2"></font></p><pre>
    float bbox[6];
    SbVec3f originWorld,originB;
    SbMatrix matrixA, inverseMatrixB;

    // Get origin in local coordinates of A
    fieldA-&gt;getBoundingBox(bbox);
    SbVec3f origin(bbox[0],bbox[1],bbox[2]);

    // Transform origin to world coordinates:
    fieldA-&gt;getTransform(matrixA);
    matrixA.multVecMatrix(origin,originWorld);

    // Transform origin from world coords to local coords of B
    fieldB-&gt;getInverseTransform(inverseMatrixB);
    inverseMatrixB.multVecMatrix(originWorld,originB);
</pre><p><font size="2"></font></p>
<p>Instead of this two-step approach, the two matrices could also be combined:</p>
<p><font size="2"></font></p><pre>
    SbMatrix allInOne = matrixA;
    allInOne.multRight(inverseMatrixB);

    allInOne.multVecMatrix(origin,originB);
</pre><p><font size="2"></font></p>
<p>Note that the same result is obtained in the following way:</p>
<p><font size="2"></font></p><pre>
    SbMatrix allInOne = inverseMatrixB;
    allInOne.multLeft(matrixA);

    allInOne.multVecMatrix(origin,originB);
</pre><p><font size="2"></font></p>
<p>Since the transformation could contain a translational part, special
attention should be paid when directional vectors are transformed. In this
case the method <tt>HxSpatialData::getTransformNoTranslation( SbMatrix&amp;
matrix)</tt> should be used.</p>
<p></p>
<p></p>
<p>
</p></body>
</html>
