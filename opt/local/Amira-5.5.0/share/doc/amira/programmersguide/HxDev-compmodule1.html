<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head><title>Amira Online Help</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="../Amira.css" type="text/css" />
<script type="text/javascript" src="../MathJax/MathJax.js?config=default.js"></script>
</head>
<body lang="en">


<p></p>
<h3><a name="A1">26.1.1 Version 1: Skeleton of a Compute Module</a></h3>
<p>The first version of our module does not yet produce any output. It simply
scans the input image and prints the number of voxels above and below the
threshold.</p>
<p>Like most other modules, our compute module consists of a header file
containing the class declaration as well as a source file containing the
actual code (or the class definition). Let us look at the header file
<tt>MyComputeThreshold1.h</tt> first:</p>
<p><font size="2"></font></p><pre>
/////////////////////////////////////////////////////////////////
//
// Example of a compute module (version 1)
//
/////////////////////////////////////////////////////////////////
#ifndef MY_COMPUTE_THRESHOLD_H
#define MY_COMPUTE_THRESHOLD_H

#include &lt;hxcore/HxCompModule.h&gt;
#include &lt;hxcore/HxPortFloatTextN.h&gt;
#include &lt;mypackage/mypackageAPI.h&gt;

class MYPACKAGE_API MyComputeThreshold1 : public HxCompModule
{
    // This macro is required for all modules and data objects
    HX_HEADER(MyComputeThreshold1);

  public:
    // Every module must have a default constructor.
    MyComputeThreshold1();

    // This virtual method will be called when the port changes.
    virtual void compute();

    // A port providing float text input fields.
    HxPortFloatTextN portRange;
};

#endif
</pre><p><font size="2"></font></p>
<p>As usual in C++ code, the file starts with a define statement that
prevents the contents of the file from being included multiple times.
Then three header files are included. <tt>HxCompModule.h</tt> contains the
definition of the base class of our compute module. The next file, <tt>HxPortFloatTextN.h</tt>, contains the definition of a <em>port</em> we want to
use in our class.
A port represents an input parameter of a module. In our case we use a port
of type <tt>HxPortFloatTextN</tt>. This port provides one or more text fields
where the user can enter floating point numbers. The required text fields
and labels are created automatically within the port constructor. As a
programmer you simply put some ports into your module, specifying their
types and labels, and do not have to bother creating a user interface
for it.</p>
<p>Following <tt>HxPortFloatTextN.h</tt>, the package header file <tt>mypackageAPI.h</tt>
is included. This file provides import and export storage-class specifiers
for Windows systems. These are encoded in the macro <tt>MYPACKAGE_API</tt>.
A class declared without this macro will not be accessible from outside the
DLL it is defined in. On Unix systems the macro is empty and can be
omitted.</p>
<p>In the rest of the header file nothing more is done than deriving a new
class from <tt>HxCompModule</tt> and defining two member functions, namely
the constructor and an overloaded virtual method called <tt>compute</tt>. The
<tt>compute</tt> method is called when the module has been created and
whenever a change of state occurs on one of the module's input data objects
or ports. In fact, a connection to an input data object is also established
by a port, as we shall see later on. In this example we just declare one
port in our class, specifically an instance of type <tt>HxPortFloatTextN</tt>.
The corresponding source file looks like this:</p>
<p><font size="2"></font></p><pre>
/////////////////////////////////////////////////////////////////
//
// Example of a compute module (version 1)
//
/////////////////////////////////////////////////////////////////

#include &lt;hxcore/HxMessage.h&gt;
#include &lt;hxfield/HxUniformScalarField3.h&gt;
#include &lt;mypackage/MyComputeThreshold1.h&gt;

HX_INIT_CLASS(MyComputeThreshold1,HxCompModule) // required macro

MyComputeThreshold1::MyComputeThreshold1() :
    HxCompModule(HxUniformScalarField3::getClassTypeId()),
    portRange(this,"range",2) // we want to have two float fields
{
}

void MyComputeThreshold1::compute()
{
    // Access the input data object. The member portData, which
    // is of type HxConnection, is inherited from HxModule.
    HxUniformScalarField3* field =
        (HxUniformScalarField3*) portData.source();

    // Check whether the input port is connected
    if (!field) return;

    // Get the input parameters from the user interface:
    float minValue = portRange.getValue(0);
    float maxValue = portRange.getValue(1);
    
    // Access size of data volume:
    const int* dims = field-&gt;lattice.dims();

    // Now loop through the whole field and count the pixels.
    int belowCnt=0, aboveCnt=0;
    for (int k=0; k&lt;dims[2]; k++) {
        for (int j=0; j&lt;dims[1]; j++) {
            for (int i=0; i&lt;dims[0]; i++) {
                // This function returns the value at the specific
                // grid node. It implicitly casts the result
                // to float if necessary.
                float value = field-&gt;evalReg(i,j,k);
                if (value&lt;minValue)
                    belowCnt++;
                else if (value&gt;maxValue)
                    aboveCnt++;
            }
        }
    }

    // Finally print the result.
    theMsg-&gt;printf("%d voxels &lt; %g, %d voxels &gt; %g\n",
        belowCnt, minValue, aboveCnt, maxValue);
}
</pre><p><font size="2"></font></p>
<p>Following the include statements and the obligatory <tt>HX_INIT_CLASS</tt>
macro, the constructor is defined. The usual C++ syntax must be used in
order to call the constructors of the base class and the class members. The
constructor of the base class <tt>HxCompModule</tt> takes the class type of
the input data object to which this module can be connected. <font face="helvetica">Amira</font> uses a
special run-time type information system that is independent of the rtti
feature provided by the newer ANSI C++ compilers.
The second method we have to implement is the <tt>compute</tt> method. We
first retrieve a pointer to our input data object through a member called
<tt>portData</tt>. This port is inherited from the base class <tt>HxModule</tt>,
i.e., every module has this member. The port is of type <tt>HxConnection</tt>
and it is represented as a blue line in the user interface (if connected).
The rest of the compute method is rather straightforward. The way the
actual data are accessed and how the computation is performed, of course, is
highly specific to the input data class and the task the module performs.
In this case we simply loop over all voxels of the input image and count
the number of voxels below the minimum value and above the maximum value.
In order to access a voxel's value, we use the <em>evalReg</em> method. This
method is provided by any scalar field with regular coordinates, i.e., by
any instance of class <tt>HxRegScalarField3</tt>. Regardless of the primitive
data type of the field, the result will always be cast to float.
Once you have compiled the <tt>mypackage</tt> demo package, you can load the
file <tt>lobus.am</tt> from <font face="helvetica">Amira</font>`s <tt>data/tutorials</tt> directory and attach

the module to it. Try to type in different threshold values, or use
different input data sets. Instructions for compiling local packages are
provided in <a class="link" href="HxDev-compiling.html#A1">Section 23.5 (Compiling and Debugging)</a>.</p>
<p></p>
<p></p>
<p>
</p></body>
</html>
